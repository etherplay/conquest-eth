{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "hardhat-deploy/solc_0.8/diamond/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondCut {\n    enum FacetCutAction {Add, Replace, Remove}\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "hardhat-deploy/solc_0.8/diamond/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\n\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n    }\n\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\n    }\n\n    struct DiamondStorage {\n        // maps function selector to the facet address and\n        // the position of the selector in the facetFunctionSelectors.selectors array\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n        // maps facet addresses to function selectors\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n        // facet addresses\n        address[] facetAddresses;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n    }\n\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    // Internal function version of diamondCut\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else {\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();        \n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);            \n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress != _facetAddress, \"LibDiamondCut: Can't replace function with same function\");\n            removeFunction(ds, oldFacetAddress, selector);\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        // if function does not exist then do nothing and return\n        require(_facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            removeFunction(ds, oldFacetAddress, selector);\n        }\n    }\n\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\n        enforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\n        ds.facetAddresses.push(_facetAddress);\n    }    \n\n\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {        \n        require(_facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n        // an immutable function is a function defined directly in a diamond\n        require(_facetAddress != address(this), \"LibDiamondCut: Can't remove immutable function\");\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete ds.selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n            }\n            ds.facetAddresses.pop();\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n        }\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            require(_calldata.length == 0, \"LibDiamondCut: _init is address(0) but_calldata is not empty\");\n        } else {\n            require(_calldata.length > 0, \"LibDiamondCut: _calldata is empty but _init is not address(0)\");\n            if (_init != address(this)) {\n                enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\n            }\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\n            if (!success) {\n                if (error.length > 0) {\n                    // bubble up the error\n                    revert(string(error));\n                } else {\n                    revert(\"LibDiamondCut: _init function reverted\");\n                }\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    },
    "hardhat-deploy/solc_0.8/diamond/UsingDiamondOwner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./libraries/LibDiamond.sol\";\n\ncontract UsingDiamondOwner {\n    modifier onlyOwner() {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        require(msg.sender == ds.contractOwner, \"Only owner is allowed to perform this action\");\n        _;\n    }\n}\n"
    },
    "hardhat-deploy/solc_0.8/proxy/Proxied.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract Proxied {\n    /// @notice to be used by initialisation / postUpgrade function so that only the proxy's admin can execute them\n    /// It also allows these functions to be called inside a contructor\n    /// even if the contract is meant to be used without proxy\n    modifier proxied() {\n        address proxyAdminAddress = _proxyAdmin();\n        // With hardhat-deploy proxies\n        // the proxyAdminAddress is zero only for the implementation contract\n        // if the implementation contract want to be used as a standalone/immutable contract\n        // it simply has to execute the `proxied` function\n        // This ensure the proxyAdminAddress is never zero post deployment\n        // And allow you to keep the same code for both proxied contract and immutable contract\n        if (proxyAdminAddress == address(0)) {\n            // ensure can not be called twice when used outside of proxy : no admin\n            // solhint-disable-next-line security/no-inline-assembly\n            assembly {\n                sstore(\n                    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103,\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n                )\n            }\n        } else {\n            require(msg.sender == proxyAdminAddress);\n        }\n        _;\n    }\n\n    modifier onlyProxyAdmin() {\n        require(msg.sender == _proxyAdmin(), \"NOT_AUTHORIZED\");\n        _;\n    }\n\n    function _proxyAdmin() internal view returns (address ownerAddress) {\n        // solhint-disable-next-line security/no-inline-assembly\n        assembly {\n            ownerAddress := sload(0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103)\n        }\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n}\n"
    },
    "solidity-kit/solc_0_8/ERC165/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceID The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "solidity-kit/solc_0_8/ERC721/implementations/BasicERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IERC721Receiver.sol\";\nimport \"../interfaces/IERC721.sol\";\nimport \"../interfaces/UsingERC721Errors.sol\";\nimport \"../interfaces/IERC721WithBlocknumber.sol\";\nimport \"./ImplementingERC721Internal.sol\";\nimport \"../../utils/UsingGenericErrors.sol\";\n\nimport \"../../openzeppelin/contracts/utils/Address.sol\";\n\nabstract contract BasicERC721 is IERC721, IERC721WithBlocknumber, ImplementingERC721Internal, UsingERC721Errors {\n    using Openzeppelin_Address for address;\n\n    bytes4 internal constant ERC721_RECEIVED = 0x150b7a02;\n\n    uint256 internal constant OPERATOR_FLAG = 0x8000000000000000000000000000000000000000000000000000000000000000;\n\n    mapping(uint256 => uint256) internal _owners;\n    mapping(address => uint256) internal _balances;\n    mapping(address => mapping(address => bool)) internal _operatorsForAll;\n    mapping(uint256 => address) internal _operators;\n\n    /// @inheritdoc IERC721\n    function approve(address operator, uint256 tokenID) external override {\n        (address owner, uint256 nonce) = _ownerAndNonceOf(tokenID);\n        if (owner == address(0)) {\n            revert NonExistentToken(tokenID);\n        }\n        if (msg.sender != owner && !isApprovedForAll(owner, msg.sender)) {\n            revert UsingGenericErrors.NotAuthorized();\n        }\n        _approveFor(owner, nonce, operator, tokenID);\n    }\n\n    /// @inheritdoc IERC721\n    function transferFrom(address from, address to, uint256 tokenID) external override {\n        (address owner, uint256 nonce, bool operatorEnabled) = _ownerNonceAndOperatorEnabledOf(tokenID);\n        if (owner == address(0)) {\n            revert NonExistentToken(tokenID);\n        }\n        if (from != owner) {\n            revert NotOwner(from, owner);\n        }\n        if (to == address(0) || to == address(this)) {\n            revert InvalidAddress(to);\n        }\n        if (msg.sender != from) {\n            if (!(operatorEnabled && _operators[tokenID] == msg.sender) && !isApprovedForAll(from, msg.sender)) {\n                revert UsingGenericErrors.NotAuthorized();\n            }\n        }\n        _transferFrom(from, to, tokenID, (nonce >> 24) != 0);\n    }\n\n    /// @inheritdoc IERC721\n    function safeTransferFrom(address from, address to, uint256 tokenID) external override {\n        safeTransferFrom(from, to, tokenID, \"\");\n    }\n\n    /// @inheritdoc IERC721\n    function setApprovalForAll(address operator, bool approved) external override {\n        _setApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /// @inheritdoc IERC721\n    function balanceOf(address owner) public view virtual override returns (uint256 balance) {\n        if (owner == address(0)) {\n            revert InvalidAddress(owner);\n        }\n        balance = _balances[owner];\n    }\n\n    /// @inheritdoc IERC721\n    function ownerOf(uint256 tokenID) external view override returns (address owner) {\n        owner = _ownerOf(tokenID);\n        if (owner == address(0)) {\n            revert NonExistentToken(tokenID);\n        }\n    }\n\n    /// @inheritdoc IERC721\n    function getApproved(uint256 tokenID) external view override returns (address operator) {\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(tokenID);\n        if (owner == address(0)) {\n            revert NonExistentToken(tokenID);\n        }\n        if (operatorEnabled) {\n            return _operators[tokenID];\n        } else {\n            return address(0);\n        }\n    }\n\n    /// @inheritdoc IERC721\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool isOperator) {\n        return _operatorsForAll[owner][operator];\n    }\n\n    /// @inheritdoc IERC721\n    function safeTransferFrom(address from, address to, uint256 tokenID, bytes memory data) public override {\n        (address owner, uint256 nonce, bool operatorEnabled) = _ownerNonceAndOperatorEnabledOf(tokenID);\n        if (owner == address(0)) {\n            revert NonExistentToken(tokenID);\n        }\n        if (owner != from) {\n            revert NotOwner(from, owner);\n        }\n\n        if (to == address(0) || to == address(this)) {\n            revert InvalidAddress(to);\n        }\n\n        if (msg.sender != from) {\n            if (!(operatorEnabled && _operators[tokenID] == msg.sender) && !isApprovedForAll(from, msg.sender)) {\n                revert UsingGenericErrors.NotAuthorized();\n            }\n        }\n        _safeTransferFrom(from, to, tokenID, (nonce >> 24) != 0, data);\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceID) public view virtual override returns (bool) {\n        /// 0x01ffc9a7 is ERC165.\n        /// 0x80ac58cd is ERC721\n        /// 0x5b5e139f is for ERC721 metadata\n        return interfaceID == 0x01ffc9a7 || interfaceID == 0x80ac58cd || interfaceID == 0x5b5e139f;\n    }\n\n    /// @inheritdoc IERC721WithBlocknumber\n    function ownerAndLastTransferBlockNumberOf(\n        uint256 tokenID\n    ) external view override returns (address owner, uint256 blockNumber) {\n        (address currentOwner, uint256 nonce) = _ownerAndNonceOf(tokenID);\n        owner = currentOwner;\n        blockNumber = (nonce >> 24);\n    }\n\n    /// @inheritdoc IERC721WithBlocknumber\n    function ownerAndLastTransferBlockNumberList(\n        uint256[] calldata tokenIDs\n    ) external view virtual returns (OwnerData[] memory ownersData) {\n        ownersData = new OwnerData[](tokenIDs.length);\n        for (uint256 i = 0; i < tokenIDs.length; i++) {\n            uint256 data = _owners[tokenIDs[i]];\n            ownersData[i].owner = address(uint160(data));\n            ownersData[i].lastTransferBlockNumber = (data >> 184) & 0xFFFFFFFFFFFFFFFF;\n        }\n    }\n\n    // ------------------------------------------------------------------------------------------------------------------\n    // INTERNALS\n    // ------------------------------------------------------------------------------------------------------------------\n\n    function _burn(uint256 tokenID) internal {\n        address owner = _ownerOf(tokenID);\n        if (owner == address(0)) {\n            revert NonExistentToken(tokenID);\n        }\n        _balances[owner]--;\n        _owners[tokenID] = (block.number << 184);\n        emit Transfer(owner, address(0), tokenID);\n    }\n\n    function _safeMint(address to, uint256 tokenID, bool remintingAllowed) internal {\n        (address owner, uint256 nonce, ) = _ownerNonceAndOperatorEnabledOf(tokenID);\n        if (owner != address(0)) {\n            revert TokenAlreadyExists(tokenID);\n        }\n        if (!remintingAllowed && nonce != 0) {\n            revert TokenCannotBeReminted(tokenID);\n        }\n        _safeTransferFrom(address(0), to, tokenID, false, \"\");\n    }\n\n    function _safeTransferFrom(address from, address to, uint256 tokenID, bool registered, bytes memory data) internal {\n        _transferFrom(from, to, tokenID, registered);\n        if (to.isContract()) {\n            if (!_checkOnERC721Received(msg.sender, from, to, tokenID, data)) {\n                revert TransferRejected();\n            }\n        }\n    }\n\n    function _transferFrom(address from, address to, uint256 tokenID, bool registered) internal virtual {\n        unchecked {\n            _balances[to]++;\n            if (registered) {\n                _balances[from]--;\n            }\n        }\n\n        // We encode the blockNumber in the token nonce. We can then use it for count voting.\n        _owners[tokenID] = (block.number << 184) | uint256(uint160(to));\n        emit Transfer(from, to, tokenID);\n    }\n\n    /// @dev See approve.\n    function _approveFor(address owner, uint256 nonce, address operator, uint256 tokenID) internal override {\n        uint256 blockNumber = nonce >> 24;\n        uint256 newNonce = nonce + 1;\n        if (newNonce >> 24 != blockNumber) {\n            revert NonceOverflow();\n        }\n        if (operator == address(0)) {\n            _owners[tokenID] = (newNonce << 160) | uint256(uint160(owner));\n        } else {\n            _owners[tokenID] = OPERATOR_FLAG | ((newNonce << 160) | uint256(uint160(owner)));\n            _operators[tokenID] = operator;\n        }\n        emit Approval(owner, operator, tokenID);\n    }\n\n    /// @dev See setApprovalForAll.\n    function _setApprovalForAll(address sender, address operator, bool approved) internal override {\n        _operatorsForAll[sender][operator] = approved;\n\n        emit ApprovalForAll(sender, operator, approved);\n    }\n\n    /// @dev Check if receiving contract accepts erc721 transfers.\n    /// @param operator The address of the operator.\n    /// @param from The from address, may be different from msg.sender.\n    /// @param to The adddress we want to transfer to.\n    /// @param tokenID The id of the token we would like to transfer.\n    /// @param data Any additional data to send with the transfer.\n    /// @return Whether the expected value of 0x150b7a02 is returned.\n    function _checkOnERC721Received(\n        address operator,\n        address from,\n        address to,\n        uint256 tokenID,\n        bytes memory data\n    ) internal returns (bool) {\n        bytes4 retval = IERC721Receiver(to).onERC721Received(operator, from, tokenID, data);\n        return (retval == ERC721_RECEIVED);\n    }\n\n    /// @dev Get the owner of a token.\n    /// @param tokenID The token to query.\n    function _ownerOf(uint256 tokenID) internal view virtual returns (address owner) {\n        return address(uint160(_owners[tokenID]));\n    }\n\n    /// @dev Get the owner and operatorEnabled status of a token.\n    /// @param tokenID The token to query.\n    /// @return owner The owner of the token.\n    /// @return operatorEnabled Whether or not operators are enabled for this token.\n    function _ownerAndOperatorEnabledOf(\n        uint256 tokenID\n    ) internal view virtual returns (address owner, bool operatorEnabled) {\n        uint256 data = _owners[tokenID];\n        owner = address(uint160(data));\n        operatorEnabled = (data & OPERATOR_FLAG) == OPERATOR_FLAG;\n    }\n\n    /// @dev Get the owner and the permit nonce of a token.\n    /// @param tokenID The token to query.\n    /// @return owner The owner of the token.\n    /// @return nonce the nonce for permit (also incluse the blocknumer in the 64 higer bits (88 bits in total))\n    function _ownerAndNonceOf(uint256 tokenID) internal view virtual override returns (address owner, uint256 nonce) {\n        uint256 data = _owners[tokenID];\n        owner = address(uint160(data));\n        nonce = (data >> 160) & 0xFFFFFFFFFFFFFFFFFFFFFF;\n    }\n\n    // @dev Get the owner, the permit nonce of a token and operatorEnabled status of a token.\n    /// @param tokenID The token to query.\n    /// @return owner The owner of the token.\n    /// @return nonce the nonce for permit (also incluse the blocknumer in the 64 higer bits (88 bits in total))\n    /// @return operatorEnabled Whether or not operators are enabled for this token.\n    function _ownerNonceAndOperatorEnabledOf(\n        uint256 tokenID\n    ) internal view virtual returns (address owner, uint256 nonce, bool operatorEnabled) {\n        uint256 data = _owners[tokenID];\n        owner = address(uint160(data));\n        operatorEnabled = (data & OPERATOR_FLAG) == OPERATOR_FLAG;\n        nonce = (data >> 160) & 0xFFFFFFFFFFFFFFFFFFFFFF;\n    }\n}\n"
    },
    "solidity-kit/solc_0_8/ERC721/implementations/ImplementingERC721Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract ImplementingERC721Internal {\n    function _ownerAndNonceOf(uint256 tokenID) internal view virtual returns (address owner, uint256 nonce);\n\n    function _approveFor(\n        address owner,\n        uint256 nonce,\n        address operator,\n        uint256 tokenID\n    ) internal virtual;\n\n    function _setApprovalForAll(\n        address sender,\n        address operator,\n        bool approved\n    ) internal virtual;\n}\n"
    },
    "solidity-kit/solc_0_8/ERC721/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../../ERC165/interfaces/IERC165.sol\";\nimport \"./UsingERC721Events.sol\";\n\ninterface IERC721Supply {\n    /// @notice return the total number of token in existence\n    function totalSupply() external view returns (uint256);\n}\n\ninterface IERC721 is IERC165, UsingERC721Events {\n    /// @notice Get the number of tokens owned by an address.\n    /// @param owner The address to look for.\n    /// @return balance The number of tokens owned by the address.\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /// @notice Get the owner of a token.\n    /// @param tokenID The id of the token.\n    /// @return owner The address of the token owner.\n    function ownerOf(uint256 tokenID) external view returns (address owner);\n\n    /// @notice Transfer a token between 2 addresses letting the receiver knows of the transfer.\n    /// @param from The sender of the token.\n    /// @param to The recipient of the token.\n    /// @param tokenID The id of the token.\n    /// @param data Additional data.\n    function safeTransferFrom(address from, address to, uint256 tokenID, bytes calldata data) external;\n\n    /// @notice Transfer a token between 2 addresses letting the receiver know of the transfer.\n    /// @param from The send of the token.\n    /// @param to The recipient of the token.\n    /// @param tokenID The id of the token.\n    function safeTransferFrom(address from, address to, uint256 tokenID) external;\n\n    /// @notice Transfer a token between 2 addresses.\n    /// @param from The sender of the token.\n    /// @param to The recipient of the token.\n    /// @param tokenID The id of the token.\n    function transferFrom(address from, address to, uint256 tokenID) external;\n\n    /// @notice Approve an operator to transfer a specific token on the senders behalf.\n    /// @param operator The address receiving the approval.\n    /// @param tokenID The id of the token.\n    function approve(address operator, uint256 tokenID) external;\n\n    /// @notice Set the approval for an operator to manage all the tokens of the sender.\n    /// @param operator The address receiving the approval.\n    /// @param approved The determination of the approval.\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /// @notice Get the approved operator for a specific token.\n    /// @param tokenID The id of the token.\n    /// @return operator The address of the operator.\n    function getApproved(uint256 tokenID) external view returns (address operator);\n\n    /// @notice Check if the sender approved the operator to transfer any of its tokens.\n    /// @param owner The address of the owner.\n    /// @param operator The address of the operator.\n    /// @return isOperator The status of the approval.\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "solidity-kit/solc_0_8/ERC721/interfaces/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\n\ninterface IERC721Metadata is IERC721 {\n    /// @notice A descriptive name for a collection of NFTs in this contract\n    function name() external view returns (string memory name);\n\n    /// @notice An abbreviated name for NFTs in this contract\n    function symbol() external view returns (string memory symbol);\n\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n    /// @dev Throws if `tokenID` is not a valid NFT. URIs are defined in RFC\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\n    ///  Metadata JSON Schema\".\n    /// @param tokenID id of the token being queried.\n    function tokenURI(uint256 tokenID) external view returns (string memory);\n}\n"
    },
    "solidity-kit/solc_0_8/ERC721/interfaces/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC721Receiver {\n    /// @notice Handle the receipt of an NFT\n    /// @dev The ERC721 smart contract calls this function on the recipient\n    ///  after a `transfer`. This function MAY throw to revert and reject the\n    ///  transfer. Return of other than the magic value MUST result in the\n    ///  transaction being reverted.\n    ///  Note: the contract address is always the message sender.\n    /// @param operator The address which called `safeTransferFrom` function\n    /// @param from The address which previously owned the token\n    /// @param tokenID The NFT identifier which is being transferred\n    /// @param data Additional data with no specified format\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    ///  unless throwing\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenID,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "solidity-kit/solc_0_8/ERC721/interfaces/IERC721WithBlocknumber.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC721WithBlocknumber {\n    /// @notice Get the owner of a token and the blockNumber of the last transfer, useful to voting mechanism.\n    /// @param tokenID The id of the token.\n    /// @return owner The address of the token owner.\n    /// @return blockNumber The blocknumber at which the last transfer of that id happened.\n    function ownerAndLastTransferBlockNumberOf(uint256 tokenID)\n        external\n        view\n        returns (address owner, uint256 blockNumber);\n\n    struct OwnerData {\n        address owner;\n        uint256 lastTransferBlockNumber;\n    }\n\n    /// @notice Get the list of owner of a token and the blockNumber of its last transfer, useful to voting mechanism.\n    /// @param tokenIDs The list of token ids to check.\n    /// @return ownersData The list of (owner, lastTransferBlockNumber) for each ids given as input.\n    function ownerAndLastTransferBlockNumberList(uint256[] calldata tokenIDs)\n        external\n        view\n        returns (OwnerData[] memory ownersData);\n}\n"
    },
    "solidity-kit/solc_0_8/ERC721/interfaces/UsingERC721Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface UsingERC721Errors {\n    /// @notice The token does not exist\n    /// @param tokenID id of the expected token\n    error NonExistentToken(uint256 tokenID);\n\n    /// @notice The token already exists\n    /// @param tokenID id of the expected token\n    error TokenAlreadyExists(uint256 tokenID);\n\n    /// @notice The token was minted prior and cannot be reminted\n    /// @param tokenID id of the expected token\n    error TokenCannotBeReminted(uint256 tokenID);\n\n    /// @notice The address from which the token is sent is not the current owner\n    /// @param provided the address expected to be the current owner\n    /// @param currentOwner the current owner\n    error NotOwner(address provided, address currentOwner);\n\n    /// @notice An invalid address is specified (for example: zero address)\n    /// @param addr invalid address\n    error InvalidAddress(address addr);\n\n    /// @notice The Transfer was rejected by the destination\n    error TransferRejected();\n\n    /// @notice The Nonce overflowed, make a transfer to self to allow new nonces.\n    error NonceOverflow();\n}\n"
    },
    "solidity-kit/solc_0_8/ERC721/interfaces/UsingERC721Events.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface UsingERC721Events {\n    /// @notice Triggered when a token is transferred\n    /// @param from the account the token is sent from\n    /// @param to the account the token is sent to\n    /// @param tokenID id of the token being sent\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenID);\n\n    /// @notice Triggered when a token is approved to be sent by another account\n    ///  Note tat the approval get reset when a Transfer event for that same token is emitted.\n    /// @param owner current owner of the token\n    /// @param approved account who can know transfer on the owner's behalf\n    /// @param tokenID id of the token being approved\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenID);\n\n    /// @notice Triggered when an account approve or disaprove another to transfer on its behalf\n    /// @param owner the account granting rights over all of its token\n    /// @param operator account who can know transfer on the owner's behalf\n    /// @param approved whether it is approved or not\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n}\n"
    },
    "solidity-kit/solc_0_8/openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Openzeppelin_Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "solidity-kit/solc_0_8/utils/UsingGenericErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface UsingGenericErrors {\n    /// @notice Not authorized to perform this operation\n    error NotAuthorized();\n\n    /// @notice Token cannot be transfered\n    error NonTransferable();\n\n    /// @notice function is not implemented\n    error NotImplemented();\n}\n"
    },
    "src/alliances/AllianceRegistry.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity 0.8.9;\n\nimport \"hardhat-deploy/solc_0.8/proxy/Proxied.sol\";\nimport \"../interfaces/IAlliance.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n// import \"hardhat/console.sol\";\n\ncontract AllianceRegistry is Proxied {\n    using ECDSA for bytes32;\n\n    uint8 internal constant MAX_NUM_ALLIANCES = 4;\n\n    mapping(address => mapping(IAlliance => uint256)) internal _allianceNonces;\n    struct AllianceRow {\n        IAlliance alliance;\n        uint96 joinTime;\n    }\n    struct Alliances {\n        AllianceRow alliance0;\n        AllianceRow alliance1;\n        AllianceRow alliance2;\n        AllianceRow alliance3;\n    }\n    mapping(address => Alliances) internal _alliances;\n\n    event AllianceLink(IAlliance indexed alliance, address indexed player, bool joining);\n\n    function getAllianceDataAtSlot(address player, uint8 slot)\n        external\n        view\n        returns (\n            IAlliance alliance,\n            uint96 joinTime,\n            uint256 nonce\n        )\n    {\n        Alliances storage alliances = _alliances[player];\n        if (slot == 0) {\n            alliance = alliances.alliance0.alliance;\n            joinTime = alliances.alliance0.joinTime;\n        } else if (slot == 1) {\n            alliance = alliances.alliance1.alliance;\n            joinTime = alliances.alliance1.joinTime;\n        } else if (slot == 2) {\n            alliance = alliances.alliance2.alliance;\n            joinTime = alliances.alliance2.joinTime;\n        } else if (slot == 3) {\n            alliance = alliances.alliance3.alliance;\n            joinTime = alliances.alliance3.joinTime;\n        }\n\n        nonce = _allianceNonces[player][alliance];\n    }\n\n    function getAllianceData(address player, IAlliance alliance) public view returns (uint96 joinTime, uint256 nonce) {\n        nonce = _allianceNonces[player][alliance];\n\n        Alliances storage alliances = _alliances[player];\n        if (alliances.alliance0.alliance == alliance) {\n            joinTime = alliances.alliance0.joinTime;\n        } else if (alliances.alliance1.alliance == alliance) {\n            joinTime = alliances.alliance1.joinTime;\n        } else if (alliances.alliance2.alliance == alliance) {\n            joinTime = alliances.alliance2.joinTime;\n        } else if (alliances.alliance3.alliance == alliance) {\n            joinTime = alliances.alliance3.joinTime;\n        }\n    }\n\n    function havePlayersAnAllianceInCommon(\n        address player1,\n        address player2,\n        uint256 timestamp\n    ) external view returns (IAlliance alliance, uint96 joinTime) {\n        Alliances storage p1Alliances = _alliances[player1];\n        Alliances storage p2Alliances = _alliances[player2];\n\n        AllianceRow[4] memory player1Alliances;\n        AllianceRow[4] memory player2Alliances;\n        uint256 num1 = 0;\n        uint256 num2 = 0;\n\n        for (uint256 i = 0; i < 4; i++) {\n            if (i == num1) {\n                AllianceRow memory allianceRow;\n                if (i == 0) {\n                    allianceRow = p1Alliances.alliance0;\n                } else if (i == 1) {\n                    allianceRow = p1Alliances.alliance1;\n                } else if (i == 2) {\n                    allianceRow = p1Alliances.alliance2;\n                } else if (i == 3) {\n                    allianceRow = p1Alliances.alliance3;\n                }\n                if (address(allianceRow.alliance) == address(0)) {\n                    // console.log(\"p1 exhausted\");\n                    return (alliance, joinTime); // the alliance leave ensure that there is no gap // TODO\n                }\n                player1Alliances[num1++] = allianceRow;\n            }\n            for (uint256 j = 0; j < 4; j++) {\n                if (j == num2) {\n                    AllianceRow memory allianceRow;\n                    if (j == 0) {\n                        allianceRow = p2Alliances.alliance0;\n                    } else if (j == 1) {\n                        allianceRow = p2Alliances.alliance1;\n                    } else if (j == 2) {\n                        allianceRow = p2Alliances.alliance2;\n                    } else if (j == 3) {\n                        allianceRow = p2Alliances.alliance3;\n                    }\n                    if (address(allianceRow.alliance) == address(0)) {\n                        // console.log(\"p2 exhausted\");\n                        // return (alliance, joinTime); // the alliance leave ensure that there is no gap // TODO\n                        break;\n                    }\n                    player2Alliances[num2++] = allianceRow;\n                }\n\n                if (player1Alliances[i].alliance == player2Alliances[j].alliance) {\n                    if (player1Alliances[i].joinTime >= player2Alliances[j].joinTime) {\n                        if (player1Alliances[i].joinTime < timestamp) {\n                            return (player1Alliances[i].alliance, player1Alliances[i].joinTime);\n                        } else {\n                            // TODO check greater ?\n                            alliance = player1Alliances[i].alliance;\n                            joinTime = player1Alliances[i].joinTime;\n                        }\n                    } else {\n                        if (player2Alliances[j].joinTime < timestamp) {\n                            return (player2Alliances[j].alliance, player2Alliances[j].joinTime);\n                        } else {\n                            // TODO check greater ?\n                            alliance = player2Alliances[j].alliance;\n                            joinTime = player2Alliances[j].joinTime;\n                        }\n                    }\n                }\n            }\n        }\n        // console.log(address(alliance));\n        // console.log(joinTime);\n    }\n\n    // -----------------------------------------------------------------------------------------------------\n    // FROM PLAYER\n    // -----------------------------------------------------------------------------------------------------\n\n    function joinAlliance(IAlliance alliance, bytes calldata data) external returns (bool joined) {\n        Alliances storage alliances = _alliances[msg.sender];\n        uint256 slot = 0;\n        if (address(alliances.alliance0.alliance) != address(0)) {\n            slot++;\n        }\n        if (address(alliances.alliance1.alliance) != address(0)) {\n            slot++;\n        }\n        if (address(alliances.alliance2.alliance) != address(0)) {\n            slot++;\n        }\n        require(address(alliances.alliance3.alliance) == address(0), \"MAX_NUM_ALLIANCES_REACHED\");\n\n        joined = alliance.requestToJoin(msg.sender, data);\n        if (joined) {\n            if (slot == 0) {\n                alliances.alliance0.alliance = alliance;\n                alliances.alliance0.joinTime = uint96(block.timestamp);\n            } else if (slot == 1) {\n                alliances.alliance1.alliance = alliance;\n                alliances.alliance1.joinTime = uint96(block.timestamp);\n            } else if (slot == 2) {\n                alliances.alliance2.alliance = alliance;\n                alliances.alliance2.joinTime = uint96(block.timestamp);\n            } else if (slot == 3) {\n                alliances.alliance3.alliance = alliance;\n                alliances.alliance3.joinTime = uint96(block.timestamp);\n            }\n\n            emit AllianceLink(alliance, msg.sender, true);\n        }\n    }\n\n    function leaveAlliance(IAlliance alliance) external {\n        _leaveAlliance(msg.sender, alliance);\n        try alliance.playerHasLeft(msg.sender) {} catch {}\n        // TODO ensure callback not failed due to low gas (1/64 rule)\n    }\n\n    // -----------------------------------------------------------------------------------------------------\n    // FROM ALLIANCE\n    // -----------------------------------------------------------------------------------------------------\n\n    function addPlayerToAlliance(\n        address player,\n        uint32 nonce,\n        bytes calldata signature\n    ) external {\n        _addPlayerToAlliance(player, nonce, signature);\n    }\n\n    struct PlayerSubmission {\n        address addr;\n        uint32 nonce;\n        bytes signature;\n    }\n\n    function addMultiplePlayersToAlliance(PlayerSubmission[] calldata playerSubmissions) external {\n        for (uint256 i = 0; i < playerSubmissions.length; i++) {\n            _addPlayerToAlliance(playerSubmissions[i].addr, playerSubmissions[i].nonce, playerSubmissions[i].signature);\n        }\n    }\n\n    function ejectPlayerFromAlliance(address player) external {\n        _leaveAlliance(player, IAlliance(msg.sender));\n    }\n\n    // -----------------------------------------------------------------------------------------------------\n    // INTERNAL\n    // -----------------------------------------------------------------------------------------------------\n\n    function _addPlayerToAlliance(\n        address player,\n        uint32 nonce,\n        bytes calldata signature\n    ) internal {\n        IAlliance alliance = IAlliance(msg.sender);\n\n        Alliances storage alliances = _alliances[player];\n        uint256 slot = 0;\n        if (address(alliances.alliance0.alliance) != address(0)) {\n            require(alliances.alliance0.alliance != alliance, \"ALREADY_JOINED\");\n            slot++;\n        }\n        if (address(alliances.alliance1.alliance) != address(0)) {\n            require(alliances.alliance1.alliance != alliance, \"ALREADY_JOINED\");\n            slot++;\n        }\n        if (address(alliances.alliance2.alliance) != address(0)) {\n            require(alliances.alliance2.alliance != alliance, \"ALREADY_JOINED\");\n            slot++;\n        }\n        require(alliances.alliance3.alliance != alliance, \"ALREADY_JOINED\");\n        require(address(alliances.alliance3.alliance) == address(0), \"MAX_NUM_ALLIANCES_REACHED\");\n\n        uint256 currentNonce = _allianceNonces[player][alliance];\n        require(currentNonce == nonce, \"INVALID_NONCE\");\n\n        bytes memory message;\n        if (nonce == 0) {\n            message = abi.encodePacked(\n                \"\\x19Ethereum Signed Message:\\n56\",\n                \"Join Alliance 0x0000000000000000000000000000000000000000\"\n            );\n            _writeUintAsHex(message, 28 + 55, uint160(msg.sender));\n        } else {\n            message = abi.encodePacked(\n                \"\\x19Ethereum Signed Message:\\n76\",\n                \"Join Alliance 0x0000000000000000000000000000000000000000 (nonce:          0)\"\n            );\n            _writeUintAsHex(message, 28 + 55, uint160(msg.sender));\n            _writeUintAsDecimal(message, 28 + 74, nonce);\n        }\n\n        // console.log(string(message));\n\n        bytes32 digest = keccak256(message);\n\n        address signer = digest.recover(signature);\n        require(player == signer, \"INVALID_SIGNATURE\");\n\n        if (slot == 0) {\n            alliances.alliance0.alliance = alliance;\n            alliances.alliance0.joinTime = uint96(block.timestamp);\n        } else if (slot == 1) {\n            alliances.alliance1.alliance = alliance;\n            alliances.alliance1.joinTime = uint96(block.timestamp);\n        } else if (slot == 2) {\n            alliances.alliance2.alliance = alliance;\n            alliances.alliance2.joinTime = uint96(block.timestamp);\n        } else if (slot == 3) {\n            alliances.alliance3.alliance = alliance;\n            alliances.alliance3.joinTime = uint96(block.timestamp);\n        }\n        _allianceNonces[player][alliance] = nonce + 1;\n\n        emit AllianceLink(alliance, player, true);\n\n        _checkERC1155AndCallSafeTransfer(msg.sender, address(0), player, uint256(uint160(address(alliance))), 1);\n        emit TransferSingle(msg.sender, address(0), player, uint256(uint160(address(alliance))), 1);\n    }\n\n    bytes internal constant hexAlphabet = \"0123456789abcdef\";\n    bytes internal constant decimalAlphabet = \"0123456789\";\n\n    function _writeUintAsHex(\n        bytes memory data,\n        uint256 endPos,\n        uint256 num\n    ) internal pure {\n        while (num != 0) {\n            data[endPos--] = bytes1(hexAlphabet[num % 16]);\n            num /= 16;\n        }\n    }\n\n    function _writeUintAsDecimal(\n        bytes memory data,\n        uint256 endPos,\n        uint256 num\n    ) internal pure {\n        while (num != 0) {\n            data[endPos--] = bytes1(decimalAlphabet[num % 10]);\n            num /= 10;\n        }\n    }\n\n    function _leaveAlliance(address player, IAlliance alliance) internal {\n        Alliances storage alliances = _alliances[player];\n\n        IAlliance lastSlotAlliance;\n        uint96 lastSlotJoinTime;\n\n        require(address(alliances.alliance0.alliance) != address(0), \"NOT_PART_OF_ANY_ALLIANCE\");\n\n        if (address(alliances.alliance1.alliance) == address(0)) {\n            lastSlotAlliance = alliances.alliance0.alliance;\n            lastSlotJoinTime = alliances.alliance0.joinTime;\n            alliances.alliance0.alliance = IAlliance(address(0));\n            alliances.alliance0.joinTime = 0;\n        } else {\n            if (address(alliances.alliance2.alliance) == address(0)) {\n                lastSlotAlliance = alliances.alliance1.alliance;\n                lastSlotJoinTime = alliances.alliance1.joinTime;\n                alliances.alliance1.alliance = IAlliance(address(0));\n                alliances.alliance1.joinTime = 0;\n            } else {\n                if (address(alliances.alliance3.alliance) == address(0)) {\n                    lastSlotAlliance = alliances.alliance2.alliance;\n                    lastSlotJoinTime = alliances.alliance2.joinTime;\n                    alliances.alliance2.alliance = IAlliance(address(0));\n                    alliances.alliance2.joinTime = 0;\n                } else {\n                    lastSlotAlliance = alliances.alliance3.alliance;\n                    lastSlotJoinTime = alliances.alliance3.joinTime;\n                    alliances.alliance3.alliance = IAlliance(address(0));\n                    alliances.alliance3.joinTime = 0;\n                }\n            }\n        }\n\n        if (alliance != lastSlotAlliance) {\n            if (alliances.alliance0.alliance == alliance) {\n                alliances.alliance0.alliance = lastSlotAlliance;\n                alliances.alliance0.joinTime = lastSlotJoinTime;\n            } else if (alliances.alliance1.alliance == alliance) {\n                alliances.alliance1.alliance = lastSlotAlliance;\n                alliances.alliance1.joinTime = lastSlotJoinTime;\n            } else if (alliances.alliance2.alliance == alliance) {\n                alliances.alliance2.alliance = lastSlotAlliance;\n                alliances.alliance2.joinTime = lastSlotJoinTime;\n            } else {\n                revert(\"NOT_PART_OF_THE_ALLIANCE\");\n            }\n        }\n\n        emit AllianceLink(alliance, player, false);\n        emit TransferSingle(msg.sender, player, address(0), uint256(uint160(address(alliance))), 1);\n    }\n\n    function _msgSender() internal view returns (address) {\n        return msg.sender; // TODO metatx\n    }\n\n    // ---------------------------------------------------------------------\n    // Support For ERC-1155\n    // ---------------------------------------------------------------------\n\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    function balanceOf(address owner, uint256 id) external view returns (uint256 balance) {\n        require(id == uint160(id), \"INVALID_ID\");\n        (uint96 joinTime, ) = getAllianceData(owner, IAlliance(address(uint160(id))));\n        if (joinTime > 0) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory balances)\n    {\n        balances = new uint256[](owners.length);\n        for (uint256 i = 0; i < owners.length; i++) {\n            require(ids[i] == uint160(ids[i]), \"INVALID_ID\");\n            (uint96 joinTime, ) = getAllianceData(owners[i], IAlliance(address(uint160(ids[i]))));\n            if (joinTime > 0) {\n                balances[i] = 1;\n            } else {\n                balances[i] = 0;\n            }\n        }\n    }\n\n    function isApprovedForAll(address, address) external pure returns (bool) {\n        return false;\n    }\n\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool) {\n        return interfaceID == 0xd9b67a26 || interfaceID == 0x01ffc9a7;\n    }\n\n    function _checkERC1155AndCallSafeTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 value\n    ) internal returns (bool) {\n        if (!Address.isContract(to)) {\n            return true;\n        }\n\n        return ERC1155TokenReceiver(to).onERC1155Received(operator, from, id, value, \"\") == 0xf23a6e61;\n    }\n}\n\ninterface ERC1155TokenReceiver {\n    function onERC1155Received(\n        address _operator,\n        address _from,\n        uint256 _id,\n        uint256 _value,\n        bytes calldata _data\n    ) external returns (bytes4);\n}\n"
    },
    "src/alliances/BasicAlliance.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"./AllianceRegistry.sol\";\n// import \"../interfaces/IAlliance.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\ncontract BasicAlliance {\n    using ECDSA for bytes32;\n\n    event AdminSet(address newAdmin);\n\n    AllianceRegistry internal immutable _allianceRegistry;\n    address public admin;\n\n    string internal _baseURI;\n    BasicAlliance internal _factory;\n\n    mapping(address => uint32) public memberNonces;\n\n    // constructor(AllianceRegistry allianceRegistry, AllianceRegistry.PlayerSubmission[] memory playerSubmissions) {\n    //     _allianceRegistry = allianceRegistry;\n    //     _allianceRegistry.addMultiplePlayersToAlliance(playerSubmissions);\n    // }\n\n    constructor(AllianceRegistry allianceRegistry, address initialAdmin, string memory initialBaseURI) {\n        _allianceRegistry = allianceRegistry;\n        admin = initialAdmin;\n        emit AdminSet(initialAdmin);\n        require(bytes(initialBaseURI).length > 0, \"NEEDS_BASE_URI\");\n        _baseURI = initialBaseURI;\n    }\n\n    function baseURI() public view returns (string memory) {\n        if (address(_factory) == address(0)) {\n            return _baseURI;\n        } else {\n            return _factory.baseURI();\n        }\n    }\n\n    function setBaseURI(string memory newBaseURI) external onlyIfFactory {\n        require(msg.sender == admin, \"NOT_ALLOWED\");\n        require(bytes(newBaseURI).length > 0, \"NEEDS_BASE_URI\");\n        _baseURI = newBaseURI;\n    }\n\n    function setAdmin(address newAdmin) external {\n        require(msg.sender == admin, \"NOT_ALLOWED\");\n        admin = newAdmin;\n        emit AdminSet(newAdmin);\n    }\n\n    function initInstance(BasicAlliance factory) external {\n        require(bytes(_baseURI).length == 0, \"ALREADY_INITIALISED_FACTORY\");\n        require(address(_factory) == address(0), \"ALREADY_INITIALISED_CLONE\");\n        _factory = factory;\n    }\n\n    function frontendURI() external view returns (string memory) {\n        return string(bytes.concat(bytes(baseURI()), bytes(Strings.toHexString(uint256(uint160(address(this))), 20))));\n    }\n\n    function setAdminAndAddMembers(\n        address newAdmin,\n        AllianceRegistry.PlayerSubmission[] calldata playerSubmissions\n    ) public onlyIfInstance {\n        address currentAdmin = admin;\n        require(currentAdmin == address(0) || msg.sender == currentAdmin, \"NOT_ALLOWED\");\n        admin = newAdmin;\n        if (playerSubmissions.length > 0) {\n            _allianceRegistry.addMultiplePlayersToAlliance(playerSubmissions);\n        }\n    }\n\n    function addMembers(AllianceRegistry.PlayerSubmission[] calldata playerSubmissions) external onlyIfInstance {\n        require(msg.sender == admin, \"NOT_ALLOWED\");\n        _allianceRegistry.addMultiplePlayersToAlliance(playerSubmissions);\n    }\n\n    function removeMember(address player) external onlyIfInstance {\n        require(msg.sender == admin, \"NOT_ALLOWED\");\n        _allianceRegistry.ejectPlayerFromAlliance(player);\n    }\n\n    function claimInvite(\n        address player,\n        uint32 nonce,\n        bytes calldata signature,\n        uint32 inviteNonce,\n        bytes calldata inviteSignature\n    ) external onlyIfInstance {\n        uint256 currentNonce = memberNonces[player];\n        require(currentNonce == inviteNonce, \"INVALID_NONCE\");\n        memberNonces[player] = inviteNonce + 1;\n\n        bytes memory message;\n        if (inviteNonce == 0) {\n            message = abi.encodePacked(\n                \"\\x19Ethereum Signed Message:\\n111\",\n                \"Invite Player 0x0000000000000000000000000000000000000000 To Alliance 0x0000000000000000000000000000000000000000\"\n            );\n            _writeUintAsHex(message, 29 + 55, uint160(player));\n            _writeUintAsHex(message, 29 + 110, uint160(address(this)));\n        } else {\n            message = abi.encodePacked(\n                \"\\x19Ethereum Signed Message:\\n131\",\n                \"Invite Player 0x0000000000000000000000000000000000000000 To Alliance 0x0000000000000000000000000000000000000000 (nonce:          0)\"\n            );\n            _writeUintAsHex(message, 29 + 55, uint160(player));\n            _writeUintAsHex(message, 29 + 110, uint160(address(this)));\n            _writeUintAsDecimal(message, 29 + 129, inviteNonce);\n        }\n        bytes32 digest = keccak256(message);\n\n        address signer = digest.recover(inviteSignature);\n        require(admin == signer, \"INVALID_INVITE_SIGNATURE\");\n\n        _allianceRegistry.addPlayerToAlliance(player, nonce, signature);\n    }\n\n    function instantiate(\n        address initialAdmin,\n        AllianceRegistry.PlayerSubmission[] calldata playerSubmissions,\n        bytes32 salt\n    ) external onlyIfFactory {\n        address newAlliance = Clones.cloneDeterministic(address(this), keccak256(abi.encodePacked(salt, msg.sender)));\n        BasicAlliance(newAlliance).initInstance(this);\n        BasicAlliance(newAlliance).setAdminAndAddMembers(initialAdmin, playerSubmissions);\n    }\n\n    function getAddress(bytes32 salt) external view onlyIfFactory returns (address) {\n        return\n            Clones.predictDeterministicAddress(\n                address(this),\n                keccak256(abi.encodePacked(salt, msg.sender)),\n                address(this)\n            );\n    }\n\n    // function requestToJoin(address player, bytes calldata data) external view returns (bool) {\n    //     if (player == _initialMember) {\n    //         return true;\n    //     } else {\n    //         bytes32 digest = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", \"Add \", ));\n    //         address signer = digest.recover(signature);\n    //         require(_outerspace.allianceJoinTime(signer, this), \"ONLY_ALLIANCE_MEMBER_CAN_INVITE\");\n    //     }\n    // }\n\n    // function playerHasLeft(address player) external {\n\n    // }\n\n    // TODO library\n    bytes internal constant hexAlphabet = \"0123456789abcdef\";\n    bytes internal constant decimalAlphabet = \"0123456789\";\n\n    function _writeUintAsHex(bytes memory data, uint256 endPos, uint256 num) internal pure {\n        while (num != 0) {\n            data[endPos--] = bytes1(hexAlphabet[num % 16]);\n            num /= 16;\n        }\n    }\n\n    function _writeUintAsDecimal(bytes memory data, uint256 endPos, uint256 num) internal pure {\n        while (num != 0) {\n            data[endPos--] = bytes1(decimalAlphabet[num % 10]);\n            num /= 10;\n        }\n    }\n\n    modifier onlyIfFactory() {\n        require(address(_factory) == address(0), \"ONLY_FACTORY_ALLOWED\");\n        _;\n    }\n\n    modifier onlyIfInstance() {\n        require(address(_factory) != address(0), \"FACTORY_NOT_ALLOWED\");\n        _;\n    }\n}\n"
    },
    "src/alliances/FactionRegistry.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity 0.8.9;\n\nimport \"hardhat-deploy/solc_0.8/proxy/Proxied.sol\";\nimport \"../interfaces/IAlliance.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../outerspace/interfaces/IOnStakeChange.sol\";\n\nimport \"../conquest_token/PlayToken.sol\";\nimport {EntryPass} from \"../conquest_token/EntryPass.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract FactionRegistry is Proxied, IOnStakeChange {\n    using ECDSA for bytes32;\n\n    uint256 internal constant LARGE_CONSTANT = 1e24; // Using a large constant\n\n    // --------------------------------------------------------------------------------------------\n    // EVENTS\n    // --------------------------------------------------------------------------------------------\n    event FactionPledge(uint8 indexed faction, address indexed player);\n    event FactionClaimed(uint8 indexed faction, address indexed player, uint256 amount);\n    event PlayerActivated(uint8 indexed faction, address indexed player);\n\n    // --------------------------------------------------------------------------------------------\n    // IMMUTABLES\n    // --------------------------------------------------------------------------------------------\n    uint256 internal immutable PLEDGE_FIRST_AMOUNT;\n    uint256 internal immutable REWARD_PER_PERIOD_PER_PLAYER;\n    PlayToken internal immutable PLAY_TOKEN;\n\n    EntryPass internal immutable ENTRY_PASS;\n    uint256 internal immutable MINIMUM_CLAIM;\n    uint256 internal immutable PERIOD_LENGTH;\n    uint256 internal immutable CLAIM_BALANCE_CAP;\n    // --------------------------------------------------------------------------------------------\n\n    // --------------------------------------------------------------------------------------------\n    // State\n    // --------------------------------------------------------------------------------------------\n    mapping(address => uint8) internal _factions;\n\n    mapping(uint8 => uint256) internal _stakePerFaction;\n\n    struct FactionCounter {\n        uint128 activePlayers;\n        uint128 stake;\n    }\n    mapping(address => mapping(uint256 => bool)) public activePlayers;\n    mapping(address => mapping(uint256 => bool)) public claimed;\n    mapping(uint8 => mapping(uint256 => FactionCounter)) public _factionsPerPeriod;\n\n    address public game;\n\n    mapping(uint8 => uint256) public factionNumPlayers;\n\n    // --------------------------------------------------------------------------------------------\n    // Constructor\n    // --------------------------------------------------------------------------------------------\n    struct Config {\n        PlayToken playToken;\n        EntryPass entryPass;\n        uint256 allegienceNumTokensGiven;\n        uint256 rewardPerPeriodPerPlayer;\n        uint256 periodLength;\n        uint256 minimumClaim;\n        uint256 claimBalanceCap;\n    }\n\n    constructor(Config memory config) {\n        ENTRY_PASS = config.entryPass;\n        PLAY_TOKEN = config.playToken;\n        PLEDGE_FIRST_AMOUNT = config.allegienceNumTokensGiven;\n        REWARD_PER_PERIOD_PER_PLAYER = config.rewardPerPeriodPerPlayer;\n        PERIOD_LENGTH = config.periodLength;\n        MINIMUM_CLAIM = config.minimumClaim;\n        CLAIM_BALANCE_CAP = config.claimBalanceCap;\n        _postUpgrade();\n    }\n\n    function postUpgrade(Config calldata) external onlyProxyAdmin {\n        _postUpgrade();\n    }\n\n    function _postUpgrade() internal {}\n\n    function setGame(address game_) external {\n        require(game == address(0), \"ALREADY_SET\");\n        game = game_;\n    }\n\n    // ------------------------------------------------------------------------\n    // SETTERS\n    // ------------------------------------------------------------------------\n\n    /// @inheritdoc IOnStakeChange\n    function add(address player, uint256 amount) external override onlyGame {\n        _add(player, amount);\n    }\n\n    /// @inheritdoc IOnStakeChange\n    function remove(address player, uint256 amount) external override onlyGame {\n        _remove(player, amount);\n    }\n\n    /// @inheritdoc IOnStakeChange\n    function move(address from, address to, uint256 amount) external override onlyGame {\n        _remove(from, amount);\n        _add(to, amount);\n    }\n\n    function activatePlayer(address player) external onlyGame {\n        uint8 faction = _factions[msg.sender];\n        if (faction != 0) {\n            _activatePlayer(faction, player);\n        }\n    }\n\n    function pledgeAllegiance(uint8 faction, uint256 entryPassId) external {\n        ENTRY_PASS.burn(entryPassId);\n        if (faction == 0) {\n            revert(\"Faction 0 is reserved, it signify no allegiance pledged yet to any faction\");\n        }\n\n        uint8 existingFaction = _factions[msg.sender];\n\n        if (existingFaction != 0) {\n            revert(\"You are already pledge allegiance to a faction, it can be changed\");\n        }\n        _factions[msg.sender] = faction;\n        factionNumPlayers[faction]++;\n\n        _activatePlayer(faction, msg.sender);\n\n        uint256 currentPeriod = _getCurrentPeriod();\n        uint256 previousPeriod = currentPeriod - 1;\n        claimed[msg.sender][previousPeriod] = true;\n        PLAY_TOKEN.mint(msg.sender, PLEDGE_FIRST_AMOUNT);\n        emit FactionPledge(faction, msg.sender);\n    }\n\n    function claimTokens() external {\n        address player = msg.sender;\n        if (\n            player == 0x7AdFBF844aD50313f2A887056D55Cae0511B457B ||\n            player == 0xCE31b9502bFBBeD26a74014aC555dde18d55bc95 ||\n            player == 0xfb02455c9AFfAF1EADd7FfBA75e2b822cECe0F5d ||\n            player == 0xCfEAaB72F0DB72b2E8b1eA6B2eD6E0E843a2AA2C ||\n            player == 0xB7c5E91e2EBAD49390281b3F58cC58430B0dc32C ||\n            player == 0xBeba1Fa59251963240E955f1F1F501144E499951 ||\n            player == 0x85305201AaC36f5F81bA4F1B6697F7f46EAe95Ac ||\n            player == 0xD268e78d2AeF1c0f877Cb272a733b225cc199666 ||\n            player == 0x06BD6fb488D0B5Ca5e23169B290e3e32cF298db2 ||\n            player == 0x1585D5345914D5d71C1F6320b9922eA862c8bf3d ||\n            player == 0x376530B9dA185C81DAB866a58FF4AEF67F6bA166 ||\n            player == 0x29938706F3892e71A37E5400B4cBf2f6281FEc91 ||\n            player == 0x5d63B57610aAd34eeA4c034b641521Bb521fb87a ||\n            player == 0xDeA7AC44F984d0Cf8f286CCe4577fA2468BA87c6 ||\n            player == 0x3994Ce54E39c2205a77ED9CC4ab6dbf8038461e8 ||\n            player == 0xb59Bca057092c50A13a67603Bd30026101aA10d9 ||\n            player == 0x6b96AbC3bcbB8D5c025436043de6aA86A3Eb9c99 ||\n            player == 0xe7B936719d3e528a82341326BD4b7D0fEeE1FFa3 ||\n            player == 0x4f68ADE7D2994De5Bb9E759CE42951b91957ce0d ||\n            player == 0x304fc8b5d3D30518069D4a34050CAc911c1C4EF2 ||\n            player == 0xE70c7E8e28F1e38E43F7587753E34ab17Aa084ac ||\n            player == 0xD388E1f8Aa9770753eeFB26963cfc8fa836f28Ef ||\n            player == 0x6505cC117600c19598D6B6768075dc88259bBc4e ||\n            player == 0xe9f710A7200f39FA8811918C03c1223B31913BbA ||\n            player == 0x85Ba73346a03ef093ecD6666Be64BB169aDBa98C\n        ) {\n            revert(\"INVALID\");\n        }\n        uint8 faction = _factions[msg.sender];\n        if (faction == 0) {\n            revert(\"You need to pledge allegiance to a faction first\");\n        }\n\n        uint256 currentPeriod = _getCurrentPeriod();\n        uint256 previousPeriod = currentPeriod - 1;\n\n        require(!claimed[msg.sender][previousPeriod], \"ALREADY_CLAIMED\");\n        claimed[msg.sender][previousPeriod] = true;\n        _activatePlayer(faction, msg.sender);\n\n        uint256 tokenPerPlayerOfThisFaction = MINIMUM_CLAIM;\n        if (activePlayers[msg.sender][previousPeriod]) {\n            tokenPerPlayerOfThisFaction = _computeClaimAmount(faction, previousPeriod);\n            if (tokenPerPlayerOfThisFaction < MINIMUM_CLAIM) {\n                tokenPerPlayerOfThisFaction = MINIMUM_CLAIM;\n            }\n        }\n        if (tokenPerPlayerOfThisFaction > 0) {\n            uint256 balance = PLAY_TOKEN.balanceOf(msg.sender);\n            uint256 cap = CLAIM_BALANCE_CAP < tokenPerPlayerOfThisFaction\n                ? tokenPerPlayerOfThisFaction\n                : CLAIM_BALANCE_CAP;\n            if (balance < cap) {\n                uint256 newBalance = balance + tokenPerPlayerOfThisFaction;\n                if (newBalance > cap) {\n                    tokenPerPlayerOfThisFaction = cap - balance;\n                }\n                PLAY_TOKEN.mint(msg.sender, tokenPerPlayerOfThisFaction);\n            }\n        }\n        emit FactionClaimed(faction, msg.sender, tokenPerPlayerOfThisFaction);\n    }\n\n    // ------------------------------------------------------------------------\n    // GETTERS\n    // ------------------------------------------------------------------------\n\n    function getClaimInfo(\n        address player,\n        uint256 time\n    ) external view returns (bool invalid, bool wasActive, bool alreadyClaimed, uint256 amount) {\n        uint8 faction = _factions[player];\n        if (faction == 0) {\n            invalid = true;\n        } else {\n            uint256 currentPeriod = (time / PERIOD_LENGTH);\n            uint256 previousPeriod = currentPeriod - 1;\n            alreadyClaimed = claimed[player][previousPeriod];\n            wasActive = activePlayers[player][previousPeriod];\n            if (wasActive) {\n                amount = _computeClaimAmount(faction, previousPeriod);\n            }\n            if (amount < MINIMUM_CLAIM) {\n                amount = MINIMUM_CLAIM;\n            }\n        }\n    }\n\n    struct Faction {\n        uint256 currentStake; // mapping(uint8 => uint256) internal _stakePerFaction;\n        uint256 previousActivePlayers; // mapping(uint8 => mapping(uint256 => FactionCounter)) public _factionsPerPeriod;\n        uint256 previousStake; // same as above\n    }\n\n    function getFactionsFromPreviousPeriod() external view returns (Faction[] memory factions) {\n        factions = new Faction[](4);\n        uint256 currentPeriod = _getCurrentPeriod();\n        uint256 previousPeriod = currentPeriod - 1;\n        for (uint8 i = 1; i < 5; i++) {\n            factions[i - 1] = Faction({\n                currentStake: _stakePerFaction[i],\n                previousActivePlayers: _factionsPerPeriod[i][previousPeriod].activePlayers,\n                previousStake: _factionsPerPeriod[i][previousPeriod].stake\n            });\n        }\n    }\n\n    function factionOf(address player) external view returns (uint8) {\n        return _factions[player];\n    }\n\n    function isFromSameFaction(address player1, address player2) external view returns (bool) {\n        return _factions[player1] == _factions[player2];\n    }\n\n    // ------------------------------------------------------------------------\n    // INTERNAL SETTERS\n    // ------------------------------------------------------------------------\n\n    function _add(address player, uint256 amount) internal {\n        if (amount == 0) {\n            return;\n        }\n        uint8 faction = _factions[player];\n        if (faction == 0) {\n            return;\n        }\n        _activatePlayer(faction, player);\n        _addToFaction(faction, amount);\n    }\n\n    function _remove(address player, uint256 amount) internal {\n        if (amount == 0) {\n            return;\n        }\n        uint8 faction = _factions[player];\n        if (faction == 0) {\n            return;\n        }\n        _removeFromFaction(faction, amount);\n    }\n\n    function _addToFaction(uint8 faction, uint256 amount) internal {\n        uint256 newStake = _stakePerFaction[faction];\n        newStake += amount;\n        _factionsPerPeriod[faction][_getCurrentPeriod()].stake = uint128(newStake);\n        _stakePerFaction[faction] = newStake;\n    }\n\n    function _removeFromFaction(uint8 faction, uint256 amount) internal {\n        uint256 newStake = _stakePerFaction[faction];\n        newStake -= amount;\n        _factionsPerPeriod[faction][_getCurrentPeriod()].stake = uint128(newStake);\n        _stakePerFaction[faction] = newStake;\n    }\n\n    function _activatePlayer(uint8 faction, address player) internal {\n        uint256 currentPeriod = _getCurrentPeriod();\n        if (!activePlayers[player][currentPeriod]) {\n            activePlayers[player][currentPeriod] = true;\n            _factionsPerPeriod[faction][currentPeriod].activePlayers++;\n        }\n\n        emit PlayerActivated(faction, player);\n    }\n\n    // ------------------------------------------------------------------------\n    // INTERNAL GETTERS\n    // ------------------------------------------------------------------------\n\n    function _computeClaimAmount(\n        uint8 faction,\n        uint256 previousPeriod\n    ) internal view returns (uint256 tokenPerPlayerOfThisFaction) {\n        uint256 factionWeight = 0;\n        uint256 totalWeight = 0;\n        uint256 factionPlayers = 0;\n        uint256 totalActivePlayers = 0;\n        uint256 numFactions = 0;\n        for (uint8 i = 1; i < 5; i++) {\n            uint256 tmpActivePlayers = _factionsPerPeriod[i][previousPeriod].activePlayers;\n            totalActivePlayers += tmpActivePlayers;\n            uint256 stake = _factionsPerPeriod[i][previousPeriod].stake;\n            if (stake == 0) {\n                // in case we missed update, we use previous's previous stake\n                // TODO use modulo 2 for period\n                stake = _factionsPerPeriod[i][previousPeriod - 1].stake;\n                // in case we missed update, we use current stake\n                if (stake == 0) {\n                    stake = _stakePerFaction[i];\n                }\n            }\n            uint256 tmpWeight;\n            if (stake == 0) {\n                tmpWeight = LARGE_CONSTANT / PLEDGE_FIRST_AMOUNT;\n            } else {\n                numFactions++;\n                tmpWeight = LARGE_CONSTANT / (stake > PLEDGE_FIRST_AMOUNT ? stake : PLEDGE_FIRST_AMOUNT);\n            }\n\n            totalWeight += tmpWeight;\n            if (i == faction) {\n                factionWeight = tmpWeight;\n                factionPlayers = tmpActivePlayers;\n            }\n        }\n\n        uint256 tokensToDistribute = totalActivePlayers * REWARD_PER_PERIOD_PER_PLAYER;\n        uint256 tokenForFaction = (tokensToDistribute * factionWeight) / totalWeight;\n        tokenPerPlayerOfThisFaction = tokenForFaction / factionPlayers;\n\n        // console.log(\"totalActivePlayers %i\", totalActivePlayers);\n        // console.log(\"numFactions %i\", numFactions);\n        // console.log(\"totalWeight %i\", totalWeight);\n        // console.log(\"factionWeight %i\", factionWeight);\n        // console.log(\"factionPlayers %i\", factionPlayers);\n    }\n\n    function _getCurrentPeriod() internal view returns (uint256) {\n        return (block.timestamp / PERIOD_LENGTH);\n    }\n\n    modifier onlyGame() {\n        require(msg.sender == game, \"ONLY_GAME_ALLOWED\");\n        _;\n    }\n}\n"
    },
    "src/base/erc20/ERC20BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nabstract contract ERC20BaseInternal {\n    function _approveFor(\n        address owner,\n        address target,\n        uint256 amount\n    ) internal virtual;\n\n    function name() public virtual returns (string memory);\n\n    function _mint(address to, uint256 amount) internal virtual;\n\n    function _burnFrom(address from, uint256 amount) internal virtual;\n\n    function _internal_totalSupply() internal view virtual returns (uint256);\n}\n"
    },
    "src/base/erc20/UsingERC20Base.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"./ERC20BaseInternal.sol\";\nimport \"../../libraries/Constants.sol\";\n\ninterface IBurnReceiver {\n    function onTokenBurn(\n        address,\n        uint256,\n        bytes calldata\n    ) external returns (bool);\n}\n\ninterface ITransferReceiver {\n    function onTokenTransfer(\n        address,\n        uint256,\n        bytes calldata\n    ) external returns (bool);\n}\n\ninterface IPaidForReceiver {\n    function onTokenPaidFor(\n        address payer,\n        address forAddress,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n}\n\ninterface IApprovalReceiver {\n    function onTokenApproval(\n        address,\n        uint256,\n        bytes calldata\n    ) external returns (bool);\n}\n\nabstract contract UsingERC20Base is IERC20, ERC20BaseInternal {\n    using Address for address;\n\n    uint256 internal _totalSupply;\n    mapping(address => uint256) internal _balances;\n    mapping(address => mapping(address => uint256)) internal _allowances;\n\n    function _internal_totalSupply() internal view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function totalSupply() external view override returns (uint256) {\n        return _internal_totalSupply();\n    }\n\n    function balanceOf(address owner) external view override returns (uint256) {\n        return _balances[owner];\n    }\n\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        if (owner == address(this)) {\n            // see transferFrom: address(this) allows anyone\n            return Constants.UINT256_MAX;\n        }\n        return _allowances[owner][spender];\n    }\n\n    function decimals() external pure virtual returns (uint8) {\n        return uint8(18);\n    }\n\n    function transfer(address to, uint256 amount) external override returns (bool) {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function transferAlongWithETH(address payable to, uint256 amount) external payable returns (bool) {\n        _transfer(msg.sender, to, amount);\n        to.transfer(msg.value);\n        return true;\n    }\n\n    function distributeAlongWithETH(address payable[] calldata tos, uint256 totalAmount)\n        external\n        payable\n        returns (bool)\n    {\n        uint256 val = msg.value / tos.length;\n        require(msg.value == val * tos.length, \"INVALID_MSG_VALUE\");\n        uint256 amount = totalAmount / tos.length;\n        require(totalAmount == amount * tos.length, \"INVALID_TOTAL_AMOUNT\");\n        for (uint256 i = 0; i < tos.length; i++) {\n            _transfer(msg.sender, tos[i], amount);\n            tos[i].transfer(val);\n        }\n        return true;\n    }\n\n    function distributeVariousAmountsAlongWithETH(address payable[] calldata tos, uint256[] calldata amounts)\n        external\n        payable\n        returns (bool)\n    {\n        uint256 val = msg.value / tos.length;\n        require(msg.value == val * tos.length, \"INVALID_MSG_VALUE\");\n        require(tos.length == amounts.length, \"NOT_SAME_LENGTH\");\n        for (uint256 i = 0; i < tos.length; i++) {\n            _transfer(msg.sender, tos[i], amounts[i]);\n            tos[i].transfer(val);\n        }\n        return true;\n    }\n\n    function distributeVariousAmountsOfTokenAndETH(\n        address payable[] calldata tos,\n        uint256[] calldata tokenAmounts,\n        uint256[] calldata etherAmounts\n    ) external payable returns (bool) {\n        uint256 totalETHSent = 0;\n        require(tos.length == tokenAmounts.length, \"TOKEN_NOT_SAME_LENGTH\");\n        require(tos.length == etherAmounts.length, \"ETH_NOT_SAME_LENGTH\");\n        for (uint256 i = 0; i < tos.length; i++) {\n            if (tokenAmounts[i] != 0) {\n                _transfer(msg.sender, tos[i], tokenAmounts[i]);\n            }\n            if (etherAmounts[i] != 0) {\n                tos[i].transfer(etherAmounts[i]);\n                totalETHSent += etherAmounts[i];\n            }\n        }\n        require(msg.value == totalETHSent, \"INVALID_MSG_VALUE\");\n        return true;\n    }\n\n    function transferAndCall(\n        address to,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool) {\n        _transfer(msg.sender, to, amount);\n        return ITransferReceiver(to).onTokenTransfer(msg.sender, amount, data);\n    }\n\n    function transferFromAndCall(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool) {\n        _transferFrom(from, to, amount);\n        return ITransferReceiver(to).onTokenTransfer(from, amount, data);\n    }\n\n    function payForAndCall(\n        address forAddress,\n        address to,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool) {\n        _transfer(msg.sender, to, amount);\n        return IPaidForReceiver(to).onTokenPaidFor(msg.sender, forAddress, amount, data);\n    }\n\n    // TODO ?\n    // function transferFromForAndCall(\n    //     address forAddress,\n    //     address from,\n    //     address to,\n    //     uint256 amount,\n    //     bytes calldata data\n    // ) external returns (bool) {\n    //     _transferFrom(from, to, amount);\n    //     return ITransferForReceiver(to).onTokenTransferFor(from, forAddress, amount, data);\n    // }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external override returns (bool) {\n        _transferFrom(from, to, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        // TODO support metatx ?\n        _approveFor(msg.sender, spender, amount);\n        return true;\n    }\n\n    function approveAndCall(\n        address spender,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool) {\n        _approveFor(msg.sender, spender, amount);\n        return IApprovalReceiver(spender).onTokenApproval(msg.sender, amount, data);\n    }\n\n    function _approveFor(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal override {\n        require(owner != address(0) && spender != address(0), \"INVALID_ZERO_ADDRESS\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        // anybody can transfer from this\n        // this allow mintAndApprovedCall without gas overhead\n        if (msg.sender != from && from != address(this)) {\n            uint256 currentAllowance = _allowances[from][msg.sender];\n            if (currentAllowance != Constants.UINT256_MAX) {\n                // save gas when allowance is maximal by not reducing it (see https://github.com/ethereum/EIPs/issues/717)\n                require(currentAllowance >= amount, \"NOT_AUTHOIZED_ALLOWANCE\");\n                _allowances[from][msg.sender] = currentAllowance - amount;\n            }\n        }\n        _transfer(from, to, amount);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(to != address(0), \"INVALID_ZERO_ADDRESS\");\n        require(to != address(this), \"INVALID_THIS_ADDRESS\");\n        uint256 currentBalance = _balances[from];\n        require(currentBalance >= amount, \"NOT_ENOUGH_TOKENS\");\n        _balances[from] = currentBalance - amount;\n        _balances[to] += amount;\n        emit Transfer(from, to, amount);\n    }\n\n    function _transferAllIfAny(address from, address to) internal {\n        uint256 balanceLeft = _balances[from];\n        if (balanceLeft > 0) {\n            _balances[from] = 0;\n            _balances[to] += balanceLeft;\n            emit Transfer(from, to, balanceLeft);\n        }\n    }\n\n    function _mint(address to, uint256 amount) internal override {\n        _totalSupply += amount;\n        _balances[to] += amount;\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burnFrom(address from, uint256 amount) internal override {\n        uint256 currentBalance = _balances[from];\n        require(currentBalance >= amount, \"NOT_ENOUGH_TOKENS\");\n        _balances[from] = currentBalance - amount;\n        _totalSupply -= amount;\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "src/base/erc20/WithPermitAndFixedDomain.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"./ERC20BaseInternal.sol\";\nimport \"../../interfaces/IERC2612Standalone.sol\";\n\nabstract contract WithPermitAndFixedDomain is ERC20BaseInternal, IERC2612Standalone {\n    bytes32 internal constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    bytes32 public immutable override DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) internal _nonces;\n\n    constructor(string memory version) {\n        if (bytes(version).length == 0) {\n            version = \"1\";\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,address verifyingContract)\"),\n                keccak256(bytes(name())),\n                keccak256(bytes(version)),\n                address(this)\n            )\n        );\n    }\n\n    function nonces(address owner) external view override returns (uint256) {\n        return _nonces[owner];\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(owner != address(0), \"INVALID_ZERO_ADDRESS\");\n\n        uint256 currentNonce = _nonces[owner];\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, currentNonce, deadline))\n            )\n        );\n        require(owner == ecrecover(digest, v, r, s), \"INVALID_SIGNATURE\");\n        require(deadline == 0 || block.timestamp <= deadline, \"TOO_LATE\");\n\n        _nonces[owner] = currentNonce + 1;\n        _approveFor(owner, spender, value);\n    }\n}\n"
    },
    "src/base/utils/UsingOwner.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../../interfaces/IERC165.sol\";\n\ncontract UsingOwner is IERC165 {\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    address public owner;\n\n    constructor(address _owner) {\n        _transferOwnership(_owner);\n    }\n\n    function transferOwnership(address newOwner) external onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"NOT_AUTHORIZED\");\n        _;\n    }\n\n    function supportsInterface(bytes4 interfaceID) external pure virtual override returns (bool) {\n        return interfaceID == 0x7f5828d0 || interfaceID == 0x01ffc9a7;\n    }\n\n    function _transferOwnership(address newOwner) internal {\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n}\n"
    },
    "src/conquest_token/ConquestCredits.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../base/erc20/UsingERC20Base.sol\";\nimport \"../base/erc20/WithPermitAndFixedDomain.sol\";\nimport \"hardhat-deploy/solc_0.8/proxy/Proxied.sol\";\nimport \"./IReward.sol\";\nimport \"../base/utils/UsingOwner.sol\";\n\ncontract ConquestCredits is UsingOwner, UsingERC20Base, WithPermitAndFixedDomain, IReward {\n    event GeneratorEnabled(address generator, bool enabled);\n\n    mapping(address => bool) public generators;\n\n    string public constant symbol = \"CRED0\";\n\n    constructor(address initialOwner) UsingOwner(initialOwner) WithPermitAndFixedDomain(\"1\") {}\n\n    function name() public pure override returns (string memory) {\n        return \"Conquest v0 Credits\";\n    }\n\n    function setGenerator(address generator, bool enabled) external onlyOwner {\n        generators[generator] = enabled;\n        emit GeneratorEnabled(generator, enabled);\n    }\n\n    function reward(address to, uint256 amount) external onlyGenerators {\n        _mint(to, amount);\n    }\n\n    modifier onlyGenerators() {\n        require(generators[msg.sender], \"NOT_AUTHORIZED\");\n        _;\n    }\n}\n"
    },
    "src/conquest_token/EntryPass.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"solidity-kit/solc_0_8/ERC721/implementations/BasicERC721.sol\";\nimport \"solidity-kit/solc_0_8/ERC721/interfaces/IERC721Metadata.sol\";\n\ncontract EntryPass is BasicERC721, IERC721Metadata {\n    error NotABurner(address);\n    error NotAMinter(address);\n    error NotAnAdmin(address);\n    error FailedToTransferNativeToken(address);\n    error InvalidAmount(uint256 value, uint256 numRecipients);\n\n    event Burner(address burner, bool enabled);\n    event Minter(address burner, bool enabled);\n    event Admin(address account);\n\n    mapping(address => bool) public minters;\n    mapping(address => bool) public burners;\n    address public admin;\n\n    string public constant symbol = \"ENTRY\";\n\n    constructor(address initialAdmin) {\n        admin = initialAdmin;\n        emit Admin(initialAdmin);\n    }\n\n    function setAdmin(address newAdmin) external {\n        if (msg.sender != admin) {\n            revert NotAnAdmin(msg.sender);\n        }\n        admin = newAdmin;\n        emit Admin(newAdmin);\n    }\n\n    function setMinter(address minter, bool enabled) external {\n        if (msg.sender != admin) {\n            revert NotAnAdmin(msg.sender);\n        }\n        minters[minter] = enabled;\n        emit Minter(minter, enabled);\n    }\n\n    function setBurner(address burner, bool enabled) external {\n        if (msg.sender != admin) {\n            revert NotAnAdmin(msg.sender);\n        }\n        burners[burner] = enabled;\n        emit Burner(burner, enabled);\n    }\n\n    function name() public pure override returns (string memory) {\n        return \"Conquest Endurance Entry Pass\";\n    }\n\n    function tokenURI(uint256 tokenID) external view returns (string memory) {}\n\n    function mint(address payable to, uint256 id) external payable {\n        if (!minters[msg.sender]) {\n            revert NotAMinter(msg.sender);\n        }\n\n        _safeMint(to, id, false);\n\n        _sendNativeTokens(to, msg.value);\n    }\n\n    struct MintData {\n        uint256 id;\n        address payable to;\n    }\n\n    function mintMultiple(MintData[] calldata mintData) external payable {\n        if (!minters[msg.sender]) {\n            revert NotAMinter(msg.sender);\n        }\n\n        uint256 amountPerToken = msg.value / mintData.length;\n        if (amountPerToken * mintData.length != msg.value) {\n            revert InvalidAmount(msg.value, mintData.length);\n        }\n\n        for (uint256 i = 0; i < mintData.length; i++) {\n            address payable to = mintData[i].to;\n            _safeMint(to, mintData[i].id, false);\n            _sendNativeTokens(to, amountPerToken);\n        }\n    }\n\n    function burn(uint256 id) external {\n        if (!burners[msg.sender]) {\n            revert NotABurner(msg.sender);\n        }\n        _burn(id);\n    }\n\n    function _sendNativeTokens(address payable to, uint256 value) internal {\n        if (value > 0) {\n            (bool success, ) = to.call{value: value}(\"\");\n            if (!success) {\n                revert FailedToTransferNativeToken(to);\n            }\n        }\n    }\n}\n"
    },
    "src/conquest_token/IReward.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\ninterface IReward {\n    function reward(address to, uint256 amount) external;\n}\n"
    },
    "src/conquest_token/PlayToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../base/erc20/UsingERC20Base.sol\";\nimport \"../base/erc20/WithPermitAndFixedDomain.sol\";\nimport \"hardhat-deploy/solc_0.8/proxy/Proxied.sol\";\n\ncontract PlayToken is UsingERC20Base, WithPermitAndFixedDomain, Proxied {\n    event Burner(address burner, bool enabled);\n    event Minter(address burner, bool enabled);\n    event Admin(address account);\n\n    mapping(address => bool) public minters;\n    mapping(address => bool) public burners;\n\n    address public admin;\n\n    address public restrictedTransfer;\n\n    constructor(address initialAdmin) WithPermitAndFixedDomain(\"1\") {\n        _postUpgrade(initialAdmin);\n    }\n\n    function postUpgrade(address initialAdmin) external onlyProxyAdmin {\n        _postUpgrade(initialAdmin);\n    }\n\n    function _postUpgrade(address initialAdmin) internal {\n        if (admin != initialAdmin) {\n            admin = initialAdmin;\n            emit Admin(initialAdmin);\n        }\n    }\n\n    string public constant symbol = \"PLAY\";\n\n    function name() public pure override returns (string memory) {\n        return \"Play\";\n    }\n\n    function setBurner(address burner, bool enabled) external {\n        require(msg.sender == admin, \"NOT_ALLOWED_ADMIN\");\n        burners[burner] = enabled;\n        emit Burner(burner, enabled);\n    }\n\n    function setMinter(address minter, bool enabled) external {\n        require(msg.sender == admin, \"NOT_ALLOWED_ADMIN\");\n        minters[minter] = enabled;\n        emit Minter(minter, enabled);\n    }\n\n    function setAdmin(address newAdmin) external {\n        require(msg.sender == admin, \"NOT_ALLOWED_ADMIN\");\n        admin = newAdmin;\n        emit Admin(newAdmin);\n    }\n\n    function mint(address to, uint256 amount) external payable {\n        require(minters[msg.sender], \"NOT_ALLOWED_MINTER\");\n\n        _mint(to, amount);\n    }\n\n    function mintMultiple(address[] calldata tos, uint256[] calldata amounts) external payable {\n        require(minters[msg.sender], \"NOT_ALLOWED_MINTER\");\n\n        for (uint256 i = 0; i < tos.length; i ++) {\n            _mint(tos[i], amounts[i]);\n        }\n    }\n\n    function burn(address from, uint256 amount) external {\n        require(burners[msg.sender], \"NOT_ALLOWED_BURNER\");\n        _burnFrom(from, amount);\n    }\n\n     function burnAllMultiple(address[] calldata froms) external {\n        require(burners[msg.sender], \"NOT_ALLOWED_BURNER\");\n        for (uint256 i = 0; i < froms.length; i++) {\n            _burnFrom(froms[i], _balances[froms[i]]);\n        }\n        \n    }\n\n    function setRestrictedTransfer(address newRestrictedTransfer) external {\n        require(msg.sender == admin, \"NOT_ALLOWED_ADMIN\");\n        restrictedTransfer = newRestrictedTransfer;\n    }\n\n    function _transfer(address from, address to, uint256 amount) internal override {\n        if (restrictedTransfer != address(0)) {\n            require(from == restrictedTransfer || to == restrictedTransfer, \"RESTRICTED_TRANSFER\");\n        }\n        super._transfer(from, to, amount);\n    }\n}\n"
    },
    "src/conquest_token/PlayTokenWithOwnSAIHandler.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../base/erc20/UsingERC20Base.sol\";\nimport \"../base/erc20/WithPermitAndFixedDomain.sol\";\nimport \"hardhat-deploy/solc_0.8/proxy/Proxied.sol\";\nimport \"./SDAIHandler.sol\";\n\n// TODO remove\nimport \"hardhat/console.sol\";\n\ncontract PlayTokenWithOwnSAIHandler is UsingERC20Base, WithPermitAndFixedDomain, Proxied {\n    uint256 internal constant DECIMALS_18 = 1000000000000000000;\n    uint256 public immutable numTokensPerNativeTokenAt18Decimals;\n\n    SDAIHandler public sdaiHandler;\n\n    constructor(uint256 _numTokensPerNativeTokenAt18Decimals, WXDAI _wxdai, SDAI _sdai) WithPermitAndFixedDomain(\"1\") {\n        numTokensPerNativeTokenAt18Decimals = _numTokensPerNativeTokenAt18Decimals;\n        _postUpgrade(_numTokensPerNativeTokenAt18Decimals, _wxdai, _sdai);\n    }\n\n    function postUpgrade(\n        uint256 _numTokensPerNativeTokenAt18Decimals,\n        WXDAI _wxdai,\n        SDAI _sdai\n    ) external onlyProxyAdmin {\n        _postUpgrade(_numTokensPerNativeTokenAt18Decimals, _wxdai, _sdai);\n    }\n\n    function _postUpgrade(uint256, WXDAI _wxdai, SDAI _sdai) internal {\n        if (address(_wxdai) != address(0) && address(_sdai) != address(0)) {\n            sdaiHandler = new SDAIHandler(address(this), _wxdai, _sdai);\n            uint256 xdaiAmount = address(this).balance;\n            sdaiHandler.deposit{value: xdaiAmount}();\n        }\n    }\n\n    string public constant symbol = \"PLAY\";\n\n    function name() public pure override returns (string memory) {\n        return \"Play\";\n    }\n\n    function mint(address to, uint256 amount) external payable {\n        uint256 xdaiAmount = msg.value;\n        require((xdaiAmount * numTokensPerNativeTokenAt18Decimals) / DECIMALS_18 == amount, \"INVALID_AMOUNT\");\n\n        if (address(sdaiHandler) != address(0)) {\n            sdaiHandler.deposit{value: xdaiAmount}();\n        }\n\n        _mint(to, amount);\n    }\n\n    function burn(address payable to, uint256 amount) external {\n        _burnFrom(msg.sender, amount);\n        uint256 xDaiAmount = (amount * DECIMALS_18) / numTokensPerNativeTokenAt18Decimals;\n\n        if (address(sdaiHandler) != address(0)) {\n            sdaiHandler.withdraw(to, amount);\n        } else {\n            to.transfer((amount * DECIMALS_18) / numTokensPerNativeTokenAt18Decimals);\n        }\n    }\n\n    function redeemInterest(address payable to) external returns (uint256) {\n        // TODO only admin\n        if (address(sdaiHandler) != address(0)) {\n            uint256 expectedTotalAmount = (_totalSupply * DECIMALS_18) / numTokensPerNativeTokenAt18Decimals;\n            // TODO remove\n            console.log(\"expectedTotalAmount\");\n            console.log(expectedTotalAmount);\n\n            return sdaiHandler.redeemInterest(to, expectedTotalAmount);\n        }\n        return 0;\n    }\n\n    // TODO remove\n    function nativeBalanceOf(address account) external view returns (uint256) {\n        return account.balance;\n    }\n\n    // TODO remove\n    function withdrawAll(address payable to) external {\n        sdaiHandler.withdraw(to, type(uint256).max);\n    }\n}\n"
    },
    "src/conquest_token/RewardsGenerator.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"hardhat-deploy/solc_0.8/proxy/Proxied.sol\";\nimport \"../outerspace/interfaces/IOnStakeChange.sol\";\nimport \"./IReward.sol\";\n\ncontract RewardsGenerator is IERC20, Proxied, IOnStakeChange {\n    uint256 internal constant PRECISION = 1e24;\n    uint256 internal constant DECIMALS_18_MILLIONTH = 1000000000000; // 1 millionth of a token so that it matches with REWARD_RATE_millionth\n\n    uint256 public immutable REWARD_RATE_millionth;\n    uint256 public immutable FIXED_REWARD_RATE_thousands_millionth;\n\n    event GameEnabled(address indexed game, uint256 weight, uint256 timestamp);\n\n    struct GlobalState {\n        uint40 lastUpdateTime;\n        uint104 totalRewardPerPointAtLastUpdate; // PRECISION = 1e24\n        uint112 totalPoints;\n    }\n    GlobalState _global;\n\n    struct SharedRatePerAccount {\n        uint112 points;\n        uint104 totalRewardPerPointAccounted; // PRECISION = 1e24\n        // we do not pack here as we want to keep precision\n        uint112 rewardsToWithdraw;\n    }\n\n    mapping(address => SharedRatePerAccount) _sharedRateRewardPerAccount;\n\n    struct FixedRate {\n        uint112 toWithdraw;\n        uint40 lastTime;\n    }\n    mapping(address => FixedRate) internal _fixedRateRewardPerAccount;\n\n    mapping(address => uint256) internal _games;\n\n    IReward public immutable reward;\n\n    struct Config {\n        uint256 rewardRateMillionth;\n        uint256 fixedRewardRateThousandsMillionth;\n    }\n\n    struct InitialAccount {\n        address account;\n        uint256 amount;\n    }\n\n    bool internal _init;\n\n    constructor(\n        IReward rewardAddress,\n        Config memory config,\n        address[] memory initialGames,\n        InitialAccount[] memory initialAccounts\n    ) {\n        reward = rewardAddress;\n        REWARD_RATE_millionth = config.rewardRateMillionth;\n        FIXED_REWARD_RATE_thousands_millionth = config.fixedRewardRateThousandsMillionth;\n\n        _postUpgrade(rewardAddress, config, initialGames, initialAccounts);\n    }\n\n    function postUpgrade(\n        IReward rewardAddress,\n        Config memory config,\n        address[] memory initialGames,\n        InitialAccount[] memory initialAccounts\n    ) external onlyProxyAdmin {\n        _postUpgrade(rewardAddress, config, initialGames, initialAccounts);\n    }\n\n    function _postUpgrade(\n        IReward,\n        Config memory,\n        address[] memory initialGames,\n        InitialAccount[] memory initialAccounts\n    ) internal {\n        if (!_init) {\n            for (uint256 i = 0; i < initialGames.length; i++) {\n                _enableGame(initialGames[i], 1000000000000000000);\n            }\n            for (uint256 i = 0; i < initialAccounts.length; i++) {\n                _add(initialAccounts[i].account, initialAccounts[i].amount);\n            }\n            _init = true;\n        }\n    }\n\n    string public constant symbol = \"POINT\";\n\n    function name() public pure returns (string memory) {\n        return \"Conquest v0 Points\";\n    }\n\n    function enableGame(address game, uint256 weight) external onlyProxyAdmin {\n        _enableGame(game, weight);\n    }\n\n    function _enableGame(address game, uint256 weight) internal {\n        _games[game] = weight;\n        emit GameEnabled(game, weight, block.timestamp);\n    }\n\n    /// @inheritdoc IOnStakeChange\n    function add(address account, uint256 amount) external override onlyGames {\n        _add(account, amount);\n    }\n\n    function _add(address account, uint256 amount) internal {\n        if (amount == 0) {\n            return;\n        }\n\n        (uint256 totalPointsSoFar, uint256 accountPointsSoFar) = _update(account);\n\n        unchecked {\n            // update total points and the account's point, their reward will be counted on next interaction.\n            _global.totalPoints = uint112(totalPointsSoFar + amount);\n            _sharedRateRewardPerAccount[account].points = uint112(accountPointsSoFar + amount);\n        }\n        emit Transfer(address(0), account, amount);\n    }\n\n    /// @inheritdoc IOnStakeChange\n    function remove(address account, uint256 amount) external override onlyGames {\n        _remove(account, amount);\n    }\n\n    function _remove(address account, uint256 amount) internal {\n        if (amount == 0) {\n            return;\n        }\n\n        // update the amount generated, store it in\n        (uint256 totalPointsSoFar, uint256 accountPointsSoFar) = _update(account);\n\n        unchecked {\n            // update total points and the account's point, their reward will be counted on next interaction.\n            _global.totalPoints = uint112(totalPointsSoFar - amount);\n            _sharedRateRewardPerAccount[account].points = uint112(accountPointsSoFar - amount);\n        }\n        emit Transfer(account, address(0), amount);\n    }\n\n    /// @inheritdoc IOnStakeChange\n    function move(address from, address to, uint256 amount) external override onlyGames {\n        _remove(from, amount);\n        _add(to, amount);\n    }\n\n    function totalSupply() external view override returns (uint256) {\n        return _global.totalPoints;\n    }\n\n    function balanceOf(address owner) external view override returns (uint256) {\n        return _sharedRateRewardPerAccount[owner].points;\n    }\n\n    function allowance(address, address) external pure override returns (uint256) {\n        return 0;\n    }\n\n    function decimals() external pure virtual returns (uint8) {\n        return uint8(18);\n    }\n\n    function transfer(address, uint256) external returns (bool) {\n        revert(\"NON_TRANSFERABLE\");\n    }\n\n    function approve(address, uint256) external returns (bool) {\n        revert(\"NON_TRANSFERABLE\");\n    }\n\n    function transferFrom(address, address, uint256) external returns (bool) {\n        revert(\"NON_TRANSFERABLE\");\n    }\n\n    /// @notice update the global pool rate\n    function update() external {\n        _updateGlobal();\n    }\n\n    function lastUpdated() external view returns (uint256) {\n        return _global.lastUpdateTime;\n    }\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // For Accounts\n    // ---------------------------------------------------------------------------------------------------------------\n\n    /// @notice claim the rewards earned so far in the shared pool\n    function claimSharedPoolRewards(address to) external {\n        address account = msg.sender;\n        uint256 accountPointsSoFar = _sharedRateRewardPerAccount[account].points;\n\n        (, uint256 totalRewardPerPoint) = _updateGlobal();\n        uint256 amount = _computeRewardsEarned(\n            _sharedRateRewardPerAccount[account].totalRewardPerPointAccounted,\n            accountPointsSoFar,\n            totalRewardPerPoint,\n            _sharedRateRewardPerAccount[account].rewardsToWithdraw\n        );\n        _sharedRateRewardPerAccount[account].totalRewardPerPointAccounted = uint104(totalRewardPerPoint);\n\n        if (amount > 0) {\n            _sharedRateRewardPerAccount[account].rewardsToWithdraw = 0;\n            reward.reward(to, amount);\n        }\n    }\n\n    /// @notice claim the rewards earned so far using a fixed rate per point\n    function claimFixedRewards(address to) external {\n        address account = msg.sender;\n        uint256 amount = earnedFromFixedRate(account);\n        if (amount > 0) {\n            _fixedRateRewardPerAccount[account].lastTime = uint40(block.timestamp);\n            _fixedRateRewardPerAccount[account].toWithdraw = 0;\n            reward.reward(to, amount);\n        }\n    }\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // Getters\n    // ---------------------------------------------------------------------------------------------------------------\n\n    /// @notice The amount of reward each point has earned so far\n    function getTotalRewardPerPointWithPrecision24() external view returns (uint256) {\n        return\n            _global.totalRewardPerPointAtLastUpdate +\n            _computeExtraTotalRewardPerPointSinceLastTime(\n                _global.totalPoints,\n                REWARD_RATE_millionth,\n                _global.lastUpdateTime\n            );\n    }\n\n    /// @notice The amount of reward an account has accrued so far. Does not include already withdrawn rewards.\n    function earnedFromPoolRate(address account) external view returns (uint256) {\n        return\n            _computeRewardsEarned(\n                _sharedRateRewardPerAccount[account].totalRewardPerPointAccounted,\n                _sharedRateRewardPerAccount[account].points,\n                _global.totalRewardPerPointAtLastUpdate +\n                    _computeExtraTotalRewardPerPointSinceLastTime(\n                        _global.totalPoints,\n                        REWARD_RATE_millionth,\n                        _global.lastUpdateTime\n                    ),\n                _sharedRateRewardPerAccount[account].rewardsToWithdraw\n            );\n    }\n\n    /// @notice The amount of reward an account has accrued so far. Does not include already withdrawn rewards.\n    function earnedFromFixedRate(address account) public view returns (uint256) {\n        uint256 lastTime = _fixedRateRewardPerAccount[account].lastTime;\n        if (lastTime < 1739550865) {\n            lastTime = 1739550865;\n        }\n        uint256 extraFixed = ((block.timestamp - lastTime) *\n            _sharedRateRewardPerAccount[account].points *\n            FIXED_REWARD_RATE_thousands_millionth) / 1000000000;\n        return extraFixed + _fixedRateRewardPerAccount[account].toWithdraw;\n    }\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // Internal\n    // ---------------------------------------------------------------------------------------------------------------\n\n    function _computeRewardsEarned(\n        uint256 totalRewardPerPointAccountedSoFar,\n        uint256 accountPoints,\n        uint256 currentTotalRewardPerPoint,\n        uint256 accountRewardsSoFar\n    ) internal pure returns (uint256) {\n        return\n            accountRewardsSoFar +\n            (((accountPoints * (currentTotalRewardPerPoint - totalRewardPerPointAccountedSoFar)) *\n                DECIMALS_18_MILLIONTH) / PRECISION);\n    }\n\n    function _computeExtraTotalRewardPerPointSinceLastTime(\n        uint256 totalPoints,\n        uint256 rewardRateMillionth,\n        uint256 lastUpdateTime\n    ) internal view returns (uint256) {\n        if (totalPoints == 0) {\n            return 0;\n        }\n        return ((block.timestamp - lastUpdateTime) * rewardRateMillionth * PRECISION) / totalPoints;\n    }\n\n    function _updateGlobal() internal returns (uint256 totalPointsSoFar, uint256 totalRewardPerPointAllocatedSoFar) {\n        totalPointsSoFar = _global.totalPoints;\n\n        uint256 extraTotalRewardPerPoint = _computeExtraTotalRewardPerPointSinceLastTime(\n            totalPointsSoFar,\n            REWARD_RATE_millionth,\n            _global.lastUpdateTime\n        );\n\n        totalRewardPerPointAllocatedSoFar = _global.totalRewardPerPointAtLastUpdate + extraTotalRewardPerPoint;\n\n        _global.totalRewardPerPointAtLastUpdate = uint104(totalRewardPerPointAllocatedSoFar);\n        _global.lastUpdateTime = uint40(block.timestamp);\n    }\n\n    function _updateAccount(\n        address account,\n        uint256 totalRewardPerPointAllocatedSoFar\n    ) internal returns (uint256 accountPointsSoFar) {\n        accountPointsSoFar = _sharedRateRewardPerAccount[account].points;\n\n        // update the reward that can be withdrawn, catching up account state to global\n        _sharedRateRewardPerAccount[account].rewardsToWithdraw = uint112(\n            _computeRewardsEarned(\n                // last checkpoint : when was the account last updated\n                _sharedRateRewardPerAccount[account].totalRewardPerPointAccounted,\n                accountPointsSoFar,\n                totalRewardPerPointAllocatedSoFar,\n                // rewards already registered\n                _sharedRateRewardPerAccount[account].rewardsToWithdraw\n            )\n        );\n        _sharedRateRewardPerAccount[account].totalRewardPerPointAccounted = uint104(totalRewardPerPointAllocatedSoFar);\n\n        uint256 lastTime = _fixedRateRewardPerAccount[account].lastTime;\n        if (lastTime < 1739550865) {\n            lastTime = 1739550865;\n        }\n        uint256 extraFixed = ((block.timestamp - lastTime) *\n            accountPointsSoFar *\n            FIXED_REWARD_RATE_thousands_millionth) / 1000000000;\n        _fixedRateRewardPerAccount[account].lastTime = uint40(block.timestamp);\n        _fixedRateRewardPerAccount[account].toWithdraw += uint112(extraFixed);\n    }\n\n    function _update(address account) internal returns (uint256, uint256) {\n        (uint256 totalPointsSoFar, uint256 totalRewardPerPointAllocatedSoFar) = _updateGlobal();\n        uint256 accountPointsSoFar = _updateAccount(account, totalRewardPerPointAllocatedSoFar);\n        return (totalPointsSoFar, accountPointsSoFar);\n    }\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // Modifiers\n    // ---------------------------------------------------------------------------------------------------------------\n\n    modifier onlyGames() {\n        require(_games[msg.sender] > 0, \"NOT_AUTHORIZED_GAME\");\n        _;\n    }\n}\n"
    },
    "src/conquest_token/SDAIHandler.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// TODO remove\nimport \"hardhat/console.sol\";\n\ninterface WXDAI is IERC20 {\n    function deposit() external payable;\n\n    function withdraw(uint wad) external;\n}\n\ninterface SDAI {\n    function deposit(uint256 assets, address receiver) external returns (uint256);\n\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256);\n\n    function maxWithdraw(address owner) external view returns (uint256);\n}\n\ncontract SDAIHandler {\n    address public immutable manager;\n    WXDAI public immutable wxdai;\n    SDAI public immutable sDAI;\n\n    receive() external payable {}\n\n    fallback() external payable {}\n\n    constructor(address _manager, WXDAI _wxdai, SDAI _sdai) {\n        manager = _manager;\n        wxdai = _wxdai;\n        sDAI = _sdai;\n\n        wxdai.approve(address(sDAI), type(uint256).max);\n    }\n\n    function deposit() external payable {\n        require(msg.sender == manager, \"NOT_AUTHORIZED\");\n        uint256 amount = msg.value;\n        wxdai.deposit{value: amount}();\n        sDAI.deposit(amount, address(this));\n    }\n\n    function withdraw(address payable to, uint256 amount) external {\n        require(msg.sender == manager, \"NOT_AUTHORIZED\");\n        uint256 maxAmount = sDAI.maxWithdraw(address(this));\n        amount = (amount > maxAmount) ? maxAmount : amount;\n\n        sDAI.withdraw(amount, address(this), address(this));\n        uint256 balance = wxdai.balanceOf(address(this));\n        wxdai.withdraw(balance);\n        // (bool sent, ) = to.call{value: balance}(\"\");\n        // require(sent, \"Failed to send xDAI\");\n        to.transfer(balance);\n    }\n\n    function redeemInterest(address payable to, uint256 expectedTotalAmount) external returns (uint256) {\n        require(msg.sender == manager, \"NOT_AUTHORIZED\");\n\n        uint256 maxXDaiAmount = sDAI.maxWithdraw(address(this));\n        // TODO remove\n        console.log(\"maxXDaiAmount\");\n        console.log(maxXDaiAmount);\n        if (maxXDaiAmount > expectedTotalAmount) {\n            uint256 totalToWithdraw = maxXDaiAmount - expectedTotalAmount;\n            sDAI.withdraw(totalToWithdraw, address(this), address(this));\n            uint256 balance = wxdai.balanceOf(address(this));\n            wxdai.withdraw(balance);\n            // to.transfer(balance);\n            (bool sent, ) = to.call{value: balance}(\"\");\n            require(sent, \"Failed to send xDAI\");\n            return balance;\n        }\n        return 0;\n    }\n}\n"
    },
    "src/etherplay/BrainLess.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"../base/utils/UsingOwner.sol\";\nimport \"../conquest_token/RewardsGenerator.sol\";\n\ninterface IClaim {\n    function claim(address to) external;\n}\n\ncontract BrainLess is UsingOwner {\n    RewardsGenerator public generator;\n\n    constructor(address initialOwner, RewardsGenerator initialGenerator) UsingOwner(initialOwner) {\n        generator = initialGenerator;\n    }\n\n    function claimSharedPoolRewards(address to) external onlyOwner {\n        generator.claimSharedPoolRewards(to);\n    }\n\n    function claimFixedRewards(address to) external onlyOwner {\n        generator.claimFixedRewards(to);\n    }\n\n    function claim(address to) external onlyOwner {\n        IClaim(address(generator)).claim(to);\n    }\n\n    function changegGenerator(RewardsGenerator newGenerator) external onlyOwner {\n        generator = newGenerator;\n    }\n}\n"
    },
    "src/interfaces/IAlliance.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity 0.8.9;\n\ninterface IAlliance {\n    function requestToJoin(address player, bytes calldata data) external returns (bool);\n\n    function playerHasLeft(address player) external;\n}\n"
    },
    "src/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "src/interfaces/IERC2612Standalone.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity 0.8.9;\n\ninterface IERC2612Standalone {\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function nonces(address owner) external view returns (uint256);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "src/libraries/Constants.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity 0.8.9;\n\nlibrary Constants {\n    uint256 internal constant UINT256_MAX = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n    uint256 internal constant DECIMALS_18 = 1000000000000000000;\n    uint256 internal constant DECIMALS_14 = 100000000000000;\n}\n"
    },
    "src/libraries/Extraction.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity 0.8.9;\n\n// TODO remove\nimport \"hardhat/console.sol\";\n\nlibrary Extraction {\n    function value(\n        bytes32 data,\n        uint8 leastSignificantBit,\n        uint8 size\n    ) internal pure returns (uint256) {\n        return uint256((data >> leastSignificantBit)) % 2**size;\n    }\n\n    function value8Mod(\n        bytes32 data,\n        uint8 leastSignificantBit,\n        uint8 mod\n    ) internal pure returns (uint8) {\n        return uint8(uint256((data >> leastSignificantBit)) % mod);\n    }\n\n    function value8(bytes32 data, uint8 leastSignificantBit) internal pure returns (uint8) {\n        return uint8(uint256((data >> leastSignificantBit)) % 2**8);\n    }\n\n    // 1+1+2+3+4+6+7+8+8+7+6+4+3+2+1+1 // aproximation of normal distribution with mean=7.5 and standard deviation=3 for 16 values\n    bytes32 constant n_m7_5_sd3 = 0x01223334444555555666666677777777888888889999999AAAAAABBBBCCCDDEF;\n\n    function normal8(bytes32 data, uint8 leastSignificantBit) internal pure returns (uint8) {\n        uint8 index = value8Mod(data, leastSignificantBit, 64);\n        uint8 first = index / 2;\n        uint8 second = index % 2;\n        uint8 slot = uint8(n_m7_5_sd3[first]);\n        if (second == 0) {\n            return slot >> 4;\n        } else {\n            return slot % 16;\n        }\n    }\n\n    function normal16(\n        bytes32 data,\n        uint8 leastSignificantBit,\n        bytes32 selection\n    ) internal pure returns (uint16) {\n        uint8 index = normal8(data, leastSignificantBit);\n        return uint16(uint8(selection[index * 2])) * 2**8 + uint16(uint8(selection[index * 2 + 1]));\n    }\n}\n"
    },
    "src/libraries/Math.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity 0.8.9;\n\nlibrary Math {\n    function mul(\n        uint256 a,\n        uint256 b,\n        string memory overflowError\n    ) internal pure returns (uint256 c) {\n        require(b == 0 || a == 0 || ((c = a * b) / b) == a, overflowError);\n    }\n\n    function add(\n        uint256 a,\n        uint256 b,\n        string memory overflowError\n    ) internal pure returns (uint256 c) {\n        require((c = a + b) >= a, overflowError);\n    }\n\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory underflowError\n    ) internal pure returns (uint256 c) {\n        require((c = a - b) <= a, underflowError);\n    }\n\n    function mul18(\n        uint256 a18,\n        uint256 b18,\n        string memory overflowError\n    ) internal pure returns (uint256) {\n        return mul(a18, b18, overflowError) / 10**18;\n    }\n\n    function div18(\n        uint256 a18,\n        uint256 b18,\n        string memory overflowError\n    ) internal pure returns (uint256) {\n        return mul(a18, 10**18, overflowError) / b18;\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a <= b ? a : b;\n    }\n\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    function smin(int256 a, int256 b) internal pure returns (int256) {\n        return a <= b ? a : b;\n    }\n\n    function smax(int256 a, int256 b) internal pure returns (int256) {\n        return a >= b ? a : b;\n    }\n\n    function sqrt(uint256 a) internal pure returns (uint256 c) {\n        uint256 tmp = (a + 1) / 2;\n        c = a;\n        while (tmp < c) {\n            c = tmp;\n            tmp = ((a / tmp) + tmp) / 2;\n        }\n    }\n}\n"
    },
    "src/libraries/StringUtils.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity 0.8.9;\n\nlibrary StringUtils {\n    bytes internal constant hexAlphabet = \"0123456789abcdef\";\n    bytes internal constant decimalAlphabet = \"0123456789\";\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n\n    function writeUintAsHex(\n        bytes memory data,\n        uint256 endPos,\n        uint256 num\n    ) internal pure {\n        while (num != 0) {\n            data[endPos--] = bytes1(hexAlphabet[num % 16]);\n            num /= 16;\n        }\n    }\n\n    function writeUintAsDecimal(\n        bytes memory data,\n        uint256 endPos,\n        uint256 num\n    ) internal pure {\n        while (num != 0) {\n            data[endPos--] = bytes1(decimalAlphabet[num % 10]);\n            num /= 10;\n        }\n    }\n\n    // from https://github.com/OpenZeppelin/openzeppelin-contracts\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    // from https://github.com/OpenZeppelin/openzeppelin-contracts\n    function toString(uint256 value) internal pure returns (bytes memory) {\n        unchecked {\n            uint256 length = log10(value) + 1;\n            bytes memory buffer = new bytes(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    function toStringSigned(int256 value) internal pure returns (bytes memory) {\n        return value < 0 ? bytes.concat(\"-\", toString(uint256(-value))) : toString(uint256(value));\n    }\n}\n"
    },
    "src/outerspace/base/ImportingOuterSpaceConstants.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\ncontract ImportingOuterSpaceConstants {\n    uint256 internal constant DECIMALS_18 = 1e18;\n    uint256 internal constant DECIMALS_14 = 1e14;\n    uint32 internal constant ACTIVE_MASK = 2**31;\n    int256 internal constant UINT32_MAX = 2**32 - 1;\n    int256 internal constant UINT32_MIN = -2147483648;\n}\n"
    },
    "src/outerspace/base/UsingOuterSpaceDataLayout.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"../types/ImportingOuterSpaceTypes.sol\";\n\ncontract UsingOuterSpaceDataLayout is ImportingOuterSpaceTypes {\n    mapping(uint256 => Planet) internal _planets;\n    mapping(uint256 => Fleet) internal _fleets;\n\n    mapping(address => uint256) internal _stakeReadyToBeWithdrawn;\n\n    mapping(address => mapping(address => bool)) internal _operators;\n\n    // Note: make it namespaces per user, currently it is possible (though unlikely) for 2 users to share a slot if one attack another and quickly send away spaceships\n    mapping(uint256 => mapping(uint256 => InFlight)) internal _inFlight;\n\n    Discovered internal _discovered;\n    // rewards\n    mapping(address => uint256) internal _prevRewardIds;\n    mapping(uint256 => uint256) internal _rewards;\n    mapping(address => mapping(uint256 => bool)) internal _rewardsToWithdraw;\n\n    // This adds 20,000 gas to all resolution\n    mapping(uint256 => mapping(address => mapping(uint256 => AccumulatedAttack))) internal _attacks;\n}\n"
    },
    "src/outerspace/events/ImportingOuterSpaceEvents.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\ninterface ImportingOuterSpaceEvents {\n    event BlockTime(uint256 block, uint256 timestamp);\n    event PlanetStake(\n        address indexed acquirer,\n        uint256 indexed location,\n        uint32 numSpaceships,\n        int40 travelingUpkeep,\n        uint32 overflow,\n        uint256 stake\n    );\n    event FleetSent(\n        address indexed fleetSender,\n        address indexed fleetOwner,\n        uint256 indexed from,\n        address operator,\n        uint256 fleet,\n        uint32 quantity,\n        uint32 newNumSpaceships,\n        int40 newTravelingUpkeep,\n        uint32 newOverflow\n    );\n\n    event FleetRevealed(\n        uint256 indexed fleetId,\n        uint256 indexed from,\n        uint256 indexed to,\n        uint256 arrivalTimeWanted,\n        bool gift,\n        address specific,\n        bytes32 secret,\n        address fleetSender,\n        address operator\n    );\n\n    struct ArrivalData {\n        uint32 newNumspaceships;\n        int40 newTravelingUpkeep;\n        uint32 newOverflow;\n        uint32 numSpaceshipsAtArrival;\n        uint32 taxLoss;\n        uint32 fleetLoss;\n        uint32 planetLoss;\n        uint32 inFlightFleetLoss;\n        uint32 inFlightPlanetLoss;\n        uint32 accumulatedDefenseAdded;\n        uint32 accumulatedAttackAdded;\n    }\n\n    event FleetArrived(\n        uint256 indexed fleet,\n        address indexed fleetOwner,\n        address indexed destinationOwner,\n        uint256 destination,\n        bool gift,\n        bool won,\n        ArrivalData data\n    );\n\n    event TravelingUpkeepRefund(\n        uint256 indexed origin,\n        uint256 indexed fleet,\n        uint32 newNumspaceships,\n        int40 newTravelingUpkeep,\n        uint32 newOverflow\n    );\n\n    event PlanetTransfer(\n        address indexed previousOwner,\n        address indexed newOwner,\n        uint256 indexed location,\n        uint32 newNumspaceships,\n        int40 newTravelingUpkeep,\n        uint32 newOverflow\n    );\n\n    event PlanetReset(uint256 indexed location);\n\n    event PlanetExit(address indexed owner, uint256 indexed location);\n\n    event ExitComplete(address indexed owner, uint256 indexed location, uint256 stake);\n\n    event RewardSetup(uint256 indexed location, address indexed giver, uint256 rewardId);\n    event RewardToWithdraw(address indexed owner, uint256 indexed location, uint256 indexed rewardId);\n\n    event StakeToWithdraw(address indexed owner, uint256 newStake);\n\n    event Initialized(\n        bytes32 genesis,\n        uint256 resolveWindow,\n        uint256 timePerDistance,\n        uint256 exitDuration,\n        uint32 acquireNumSpaceships,\n        uint32 productionSpeedUp,\n        uint256 frontrunningDelay,\n        uint256 productionCapAsDuration,\n        uint256 upkeepProductionDecreaseRatePer10000th,\n        uint256 fleetSizeFactor6,\n        uint32 initialSpaceExpansion,\n        uint32 expansionDelta,\n        uint256 giftTaxPer10000\n    );\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed location);\n\n    event GeneratorChanged(address newGenerator);\n    event GeneratorAdminChanged(address newGeneratorAdmin);\n}\n"
    },
    "src/outerspace/facets/OuterSpaceAdminFacet.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"./OuterSpaceFacetBase.sol\";\nimport \"hardhat-deploy/solc_0.8/diamond/UsingDiamondOwner.sol\";\n\ncontract OuterSpaceAdminFacet is UsingDiamondOwner, OuterSpaceFacetBase {\n    // solhint-disable-next-line no-empty-blocks\n    constructor(Config memory config) OuterSpaceFacetBase(config) {}\n\n    function generatorAdmin() external view returns (address) {\n        return _generatorAdmin();\n    }\n\n    function generator() external view returns (IOnStakeChange) {\n        return IOnStakeChange(_generator());\n    }\n\n    function setGeneratorAdmin(address newAdmin) external {\n        if (msg.sender != _generatorAdmin()) {\n            LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n            require(msg.sender == ds.contractOwner, \"NOT_AUTHORIZED\");\n        }\n        assembly {\n            // keccak256(\"generator.admin\") - 1\n            sstore(0x4b982ee4b5dc6e03929295769d2c20389d9eaa50e17bb7ede2652d727b11f4eb, newAdmin)\n        }\n        emit GeneratorAdminChanged(newAdmin);\n    }\n\n    function setGenerator(IOnStakeChange newGenerator) external {\n        require(msg.sender == _generatorAdmin(), \"NOT_AUTHORIZED\");\n        assembly {\n            // keccak256(\"generator\") - 1\n            sstore(0x27ec6af4a6510eb9b7e0cc7f39415b7f15e430e53eb0cd3997e7c7e0cf680f6e, newGenerator)\n        }\n        emit GeneratorChanged(address(newGenerator));\n    }\n\n    function _generatorAdmin() internal view returns (address admin) {\n        assembly {\n            // keccak256(\"generator.admin\") - 1\n            admin := sload(0x4b982ee4b5dc6e03929295769d2c20389d9eaa50e17bb7ede2652d727b11f4eb)\n        }\n    }\n\n    function addRewardViaAdmin(uint256 location, address giverAddress) external {\n        require(msg.sender == _generatorAdmin(), \"NOT_AUTHORIZED\");\n        _addReward(location, giverAddress);\n    }\n\n    function addMultipleRewardViaAdmin(uint256[] calldata locations, address giverAddress) external {\n        require(msg.sender == _generatorAdmin(), \"NOT_AUTHORIZED\");\n        for (uint256 i = 0; i < locations.length; i++) {\n            uint256 location = locations[i];\n            if (_rewards[location] == 0) {\n                _addReward(location, giverAddress);\n            }\n        }\n    }\n}\n"
    },
    "src/outerspace/facets/OuterSpaceFacetBase.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"../types/ImportingOuterSpaceTypes.sol\";\nimport \"../base/ImportingOuterSpaceConstants.sol\";\nimport \"../events/ImportingOuterSpaceEvents.sol\";\nimport \"../base/UsingOuterSpaceDataLayout.sol\";\n\nimport \"../../libraries/Extraction.sol\";\nimport \"../../libraries/Math.sol\";\n\n// import \"../../interfaces/IAlliance.sol\";\nimport \"../../alliances/FactionRegistry.sol\";\n\ninterface StakingToken is IERC20 {\n    function mint(address to, uint256 amount) external payable;\n}\n\ncontract OuterSpaceFacetBase is\n    ImportingOuterSpaceTypes,\n    ImportingOuterSpaceConstants,\n    ImportingOuterSpaceEvents,\n    UsingOuterSpaceDataLayout\n{\n    using Extraction for bytes32;\n\n    StakingToken internal immutable _stakingToken;\n    FactionRegistry internal immutable _factionRegistry;\n\n    bytes32 internal immutable _genesis;\n    uint256 internal immutable _resolveWindow;\n    uint256 internal immutable _timePerDistance;\n    uint256 internal immutable _exitDuration;\n    uint32 internal immutable _acquireNumSpaceships; // TODO use uint256\n    uint32 internal immutable _productionSpeedUp; // TODO use uint256\n    uint256 internal immutable _frontrunningDelay;\n    uint256 internal immutable _productionCapAsDuration;\n    uint256 internal immutable _upkeepProductionDecreaseRatePer10000th;\n    uint256 internal immutable _fleetSizeFactor6;\n    uint32 internal immutable _initialSpaceExpansion; // = 16;\n    uint32 internal immutable _expansionDelta; // = 8;  // TODO use uint256\n    uint256 internal immutable _giftTaxPer10000; // = 2500;\n    // // 4,5,5,10,10,15,15, 20, 20, 30,30,40,40,80,80,100\n    // bytes32 constant stakeRange = 0x000400050005000A000A000F000F00140014001E001E00280028005000500064;\n    // 6, 8, 10, 12, 14, 16, 18, 20, 20, 22, 24, 32, 40, 48, 56, 72\n    // bytes32 internal constant stakeRange = 0x00060008000A000C000E00100012001400140016001800200028003000380048;\n    bytes32 internal immutable _stakeRange;\n    uint256 internal immutable _stakeMultiplier10000th;\n    uint256 internal immutable _bootstrapSessionEndTime;\n    uint256 internal immutable _infinityStartTime;\n\n    uint256 internal constant FACTION_STAKE_TRACKING_SWITCH_TIME = 1748430000;\n\n    struct Config {\n        StakingToken stakingToken;\n        FactionRegistry factionRegistry;\n        bytes32 genesis;\n        uint256 resolveWindow;\n        uint256 timePerDistance;\n        uint256 exitDuration;\n        uint32 acquireNumSpaceships;\n        uint32 productionSpeedUp;\n        uint256 frontrunningDelay;\n        uint256 productionCapAsDuration;\n        uint256 upkeepProductionDecreaseRatePer10000th;\n        uint256 fleetSizeFactor6;\n        uint32 initialSpaceExpansion;\n        uint32 expansionDelta;\n        uint256 giftTaxPer10000;\n        bytes32 stakeRange;\n        uint256 stakeMultiplier10000th;\n        uint256 bootstrapSessionEndTime;\n        uint256 infinityStartTime;\n    }\n\n    constructor(Config memory config) {\n        uint32 t = uint32(config.timePerDistance) / 4; // the coordinates space is 4 times bigger\n        require(t * 4 == config.timePerDistance, \"TIME_PER_DIST_NOT_DIVISIBLE_4\");\n\n        _stakingToken = config.stakingToken;\n        _factionRegistry = config.factionRegistry;\n\n        _genesis = config.genesis;\n        _resolveWindow = config.resolveWindow;\n        _timePerDistance = t;\n        _exitDuration = config.exitDuration;\n        _acquireNumSpaceships = config.acquireNumSpaceships;\n        _productionSpeedUp = config.productionSpeedUp;\n        _frontrunningDelay = config.frontrunningDelay;\n        _productionCapAsDuration = config.productionCapAsDuration;\n        _upkeepProductionDecreaseRatePer10000th = config.upkeepProductionDecreaseRatePer10000th;\n        _fleetSizeFactor6 = config.fleetSizeFactor6;\n        _initialSpaceExpansion = config.initialSpaceExpansion;\n        _expansionDelta = config.expansionDelta;\n        _giftTaxPer10000 = config.giftTaxPer10000;\n        _stakeRange = config.stakeRange;\n        _stakeMultiplier10000th = config.stakeMultiplier10000th;\n        _bootstrapSessionEndTime = config.bootstrapSessionEndTime;\n        _infinityStartTime = config.infinityStartTime;\n    }\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // PLANET STATE\n    // ---------------------------------------------------------------------------------------------------------------\n\n    struct PlanetUpdateState {\n        uint256 location;\n        uint40 lastUpdated;\n        bool active; // modified\n        uint32 numSpaceships; // modified\n        int40 travelingUpkeep; // modified\n        uint40 exitStartTime;\n        uint40 newExitStartTime; // modified\n        uint32 overflow; // modified\n        address owner;\n        address newOwner; // modified\n        bytes32 data;\n        uint24 futureExtraProduction;\n    }\n\n    function _createPlanetUpdateState(\n        Planet memory planet,\n        uint256 location\n    ) internal view returns (PlanetUpdateState memory planetUpdate) {\n        (bool active, uint32 currentNumSpaceships) = _activeNumSpaceships(planet.numSpaceships);\n        planetUpdate.location = location;\n        planetUpdate.lastUpdated = planet.lastUpdated;\n        planetUpdate.active = active;\n        planetUpdate.numSpaceships = currentNumSpaceships;\n        planetUpdate.travelingUpkeep = planet.travelingUpkeep;\n        planetUpdate.exitStartTime = planet.exitStartTime;\n        planetUpdate.newExitStartTime = planet.exitStartTime;\n        planetUpdate.overflow = planet.overflow;\n        planetUpdate.owner = planet.owner;\n        planetUpdate.newOwner = planet.owner;\n        planetUpdate.data = _planetData(location);\n    }\n\n    // solhint-disable-next-line code-complexity\n    function _computePlanetUpdateForTimeElapsed(PlanetUpdateState memory planetUpdate) internal view {\n        if (planetUpdate.exitStartTime != 0) {\n            if (_hasJustExited(planetUpdate.exitStartTime)) {\n                planetUpdate.newExitStartTime = 0;\n                planetUpdate.numSpaceships = 0;\n                planetUpdate.travelingUpkeep = 0;\n                planetUpdate.newOwner = address(0);\n                planetUpdate.overflow = 0;\n                planetUpdate.active = false; // event is emitted at the endof each write function\n                // lastUpdated is set at the end directly on storage\n                return;\n            }\n        }\n\n        uint256 timePassed = block.timestamp - planetUpdate.lastUpdated;\n        uint16 production = _production(planetUpdate.data);\n        uint256 amountProducedTheWholeTime = (timePassed * uint256(_productionSpeedUp) * uint256(production)) / 1 hours;\n\n        uint256 newNumSpaceships = planetUpdate.numSpaceships;\n        uint256 extraUpkeepPaid = 0;\n        if (_productionCapAsDuration > 0) {\n            uint256 capWhenActive = _capWhenActive(production);\n            uint256 cap = planetUpdate.active ? capWhenActive : 0;\n\n            if (newNumSpaceships > cap) {\n                uint256 decreaseRate = 1800;\n                if (planetUpdate.overflow > 0) {\n                    decreaseRate = (uint256(planetUpdate.overflow) * 1800) / capWhenActive;\n                    if (decreaseRate < 1800) {\n                        decreaseRate = 1800;\n                    }\n                }\n\n                uint256 decrease = (timePassed * uint256(_productionSpeedUp) * decreaseRate) / 1 hours;\n                if (decrease == 0) {\n                    // NOTE: To ensure a player cannot simply ping the planet continuously to avoid the decrease\n                    decrease = 1;\n                }\n                if (decrease > newNumSpaceships - cap) {\n                    decrease = newNumSpaceships - cap;\n                }\n\n                if (planetUpdate.active) {\n                    extraUpkeepPaid = decrease;\n                }\n                newNumSpaceships -= decrease;\n            } else {\n                if (planetUpdate.active) {\n                    uint256 increase = amountProducedTheWholeTime;\n                    if (planetUpdate.travelingUpkeep > 0) {\n                        uint256 timeBeforeUpkeepBackToZero = (uint256(uint40(planetUpdate.travelingUpkeep)) * 1 hours) /\n                            ((uint256(_productionSpeedUp) *\n                                uint256(production) *\n                                _upkeepProductionDecreaseRatePer10000th) / 10000); // 10,000 should be extracted as to not reach div by zero (like \"1 hours\")\n                        if (timeBeforeUpkeepBackToZero >= timePassed) {\n                            extraUpkeepPaid = increase;\n                        } else {\n                            extraUpkeepPaid =\n                                (timeBeforeUpkeepBackToZero * uint256(_productionSpeedUp) * uint256(production)) /\n                                1 hours;\n                            if (extraUpkeepPaid > increase) {\n                                extraUpkeepPaid = increase; // TODO remove ? should not be possible\n                            }\n                        }\n                        increase -= extraUpkeepPaid;\n                    }\n\n                    uint256 maxIncrease = cap - newNumSpaceships;\n                    if (increase > maxIncrease) {\n                        extraUpkeepPaid += increase - maxIncrease;\n                        increase = maxIncrease;\n                    }\n                    newNumSpaceships += increase;\n                    // solhint-disable-next-line no-empty-blocks\n                } else {\n                    // not effect currently, when inactive, cap == 0, meaning zero spaceship here\n                    // NOTE: we could do the following assuming we act on upkeepRepaid when inactive, we do not do that currently\n                    //  extraUpkeepPaid = amountProducedTheWholeTime - upkeepRepaid;\n                }\n            }\n\n            if (planetUpdate.active) {\n                uint256 upkeepRepaid = ((amountProducedTheWholeTime * _upkeepProductionDecreaseRatePer10000th) /\n                    10000) + extraUpkeepPaid;\n                int256 newTravelingUpkeep = int256(planetUpdate.travelingUpkeep) - int40(uint40(upkeepRepaid));\n\n                if (newTravelingUpkeep < -int256(cap)) {\n                    newTravelingUpkeep = -int256(cap);\n                }\n                planetUpdate.travelingUpkeep = int40(newTravelingUpkeep);\n            }\n        } else {\n            // TODO We are not using this branch, and in that branch there is no upkeep or overflow to consider\n            if (planetUpdate.active) {\n                newNumSpaceships += amountProducedTheWholeTime;\n            } else {\n                // NOTE no need to overflow here  as there is no production cap, so no incentive to regroup spaceships\n                uint256 decrease = (timePassed * uint256(_productionSpeedUp) * 1800) / 1 hours;\n                if (decrease > newNumSpaceships) {\n                    decrease = newNumSpaceships;\n                    newNumSpaceships = 0;\n                } else {\n                    newNumSpaceships -= decrease;\n                }\n            }\n        }\n\n        if (newNumSpaceships >= ACTIVE_MASK) {\n            newNumSpaceships = ACTIVE_MASK - 1;\n        }\n        planetUpdate.numSpaceships = uint32(newNumSpaceships);\n\n        if (!planetUpdate.active && planetUpdate.numSpaceships == 0) {\n            planetUpdate.newOwner = address(0);\n        }\n    }\n\n    function _setPlanet(Planet storage planet, PlanetUpdateState memory planetUpdate, bool exitInterupted) internal {\n        if (planetUpdate.exitStartTime > 0 && planetUpdate.newExitStartTime == 0) {\n            // NOTE: planetUpdate.newExitStartTime is only set to zero when exit is actually complete (not interupted)\n            //  interuption is handled by exitInterupted\n            // exit has completed, newExitStartTime is not set to zero for interuption,\n            // interuption is taken care below (owner changes)\n            _handleExitComplete(planetUpdate);\n        }\n        if (planetUpdate.owner != planetUpdate.newOwner) {\n            planet.owner = planetUpdate.newOwner;\n            if (planetUpdate.newOwner != address(0)) {\n                planet.ownershipStartTime = uint40(block.timestamp);\n            } else {\n                planet.ownershipStartTime = 0;\n            }\n            emit Transfer(planetUpdate.owner, planetUpdate.newOwner, planetUpdate.location);\n        }\n\n        if (exitInterupted) {\n            // if (planetUpdate.newExitStartTime == 0 && planetUpdate.exitStartTime > 0) {\n            // exit interupted // TODO event ?\n            // }\n            planet.exitStartTime = 0;\n        } else if (planetUpdate.newExitStartTime != planetUpdate.exitStartTime) {\n            planet.exitStartTime = planetUpdate.newExitStartTime;\n        }\n\n        planet.numSpaceships = _setActiveNumSpaceships(planetUpdate.active, planetUpdate.numSpaceships);\n        planet.travelingUpkeep = planetUpdate.travelingUpkeep;\n\n        planet.overflow = planetUpdate.overflow;\n        planet.lastUpdated = uint40(block.timestamp);\n    }\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // STAKING / PRODUCTION CAPTURE\n    // ---------------------------------------------------------------------------------------------------------------\n\n    function _acquire(address player, uint256 stake, uint256 location) internal whenNotPaused {\n        if (block.timestamp >= 1749632400) {\n            revert(\"STAKING_DISABLED\");\n        }\n        require(_factionRegistry.factionOf(player) != 0, \"NO_FACTION_PLEDGED\");\n        // -----------------------------------------------------------------------------------------------------------\n        // Initialise State Update\n        // -----------------------------------------------------------------------------------------------------------\n        Planet storage planet = _getPlanet(location);\n        PlanetUpdateState memory planetUpdate = _createPlanetUpdateState(planet, location);\n\n        // -----------------------------------------------------------------------------------------------------------\n        // check requirements\n        // -----------------------------------------------------------------------------------------------------------\n        require(stake == uint256(_stake(planetUpdate.data)) * (DECIMALS_14), \"INVALID_STAKE_AMOUNT\");\n\n        // -----------------------------------------------------------------------------------------------------------\n        // Compute Basic Planet Updates\n        // -----------------------------------------------------------------------------------------------------------\n        _computePlanetUpdateForTimeElapsed(planetUpdate);\n\n        // -----------------------------------------------------------------------------------------------------------\n        // Staking logic...\n        // -----------------------------------------------------------------------------------------------------------\n        _computePlanetUpdateForStaking(player, planetUpdate);\n\n        // -----------------------------------------------------------------------------------------------------------\n        // Write New State\n        // -----------------------------------------------------------------------------------------------------------\n        _setPlanet(planet, planetUpdate, false);\n        // _setAccountFromPlanetUpdate(planetUpdate);\n\n        // -----------------------------------------------------------------------------------------------------------\n        // Update Space Discovery\n        // -----------------------------------------------------------------------------------------------------------\n        _setDiscoveryAfterStaking(location);\n\n        // -----------------------------------------------------------------------------------------------------------\n        // Emit Event\n        // -----------------------------------------------------------------------------------------------------------\n        emit BlockTime(block.number, block.timestamp);\n        emit PlanetStake(\n            player,\n            location,\n            planetUpdate.numSpaceships,\n            planetUpdate.travelingUpkeep,\n            planetUpdate.overflow,\n            stake\n        );\n        _notifyGeneratorAdd(planetUpdate.newOwner, stake);\n        _notifyFactionAdd(planetUpdate.newOwner, stake);\n    }\n\n    function _computePlanetUpdateForStaking(address player, PlanetUpdateState memory planetUpdate) internal view {\n        require(!planetUpdate.active, \"STILL_ACTIVE\");\n\n        uint32 defense;\n        // NOTE : natives are back automatically once spaceships reaches zero (here we know we are not active)\n        // TODO consider making natives come back over time => would need to compute the time numSpaceship became zero\n        if (planetUpdate.numSpaceships == 0) {\n            defense = _natives(planetUpdate.data);\n        } else {\n            // Do not allow staking over occupied planets, they are going to zero at some point though\n            require(planetUpdate.owner == player, \"OCCUPIED\");\n        }\n\n        uint16 production = _production(planetUpdate.data);\n        uint32 cap = uint32(_capWhenActive(production));\n\n        // We need to  ensure a player staking on a planet it previously exited work here\n        planetUpdate.newOwner = player;\n        if (defense != 0) {\n            (uint32 attackerLoss, ) = _computeFight(\n                uint256(_acquireNumSpaceships),\n                defense,\n                10000,\n                _defense(planetUpdate.data)\n            );\n            // attacker alwasy win as defense (and stats.native) is restricted to 3500\n            // (attackerLoss: 0, defenderLoss: 0) would mean defense was zero\n            require(attackerLoss < _acquireNumSpaceships, \"FAILED_CAPTURED\");\n            planetUpdate.numSpaceships = _acquireNumSpaceships - attackerLoss;\n\n            // NOTE cannot be overflow here as staking provide a number of spaceships below that\n            planetUpdate.overflow = 0;\n        } else {\n            planetUpdate.numSpaceships += _acquireNumSpaceships;\n            if (_productionCapAsDuration > 0) {\n                if (planetUpdate.numSpaceships > cap) {\n                    planetUpdate.overflow = planetUpdate.numSpaceships - cap;\n                } else {\n                    planetUpdate.overflow = 0;\n                }\n            }\n        }\n\n        // NOTE when staking on a planet, we set an allowance for traveling upkeep\n        planetUpdate.travelingUpkeep =\n            -int32(uint32((uint256(cap) * _upkeepProductionDecreaseRatePer10000th) / 10000)) -\n            int32(planetUpdate.numSpaceships);\n        planetUpdate.active = true;\n    }\n\n    // solhint-disable-next-line code-complexity\n    function _setDiscoveryAfterStaking(uint256 location) internal {\n        Discovered memory discovered = _discovered;\n\n        int256 x = int256(int128(int256(location & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)));\n        int256 y = int256(int128(int256(location >> 128)));\n\n        bool changes = false;\n        if (x < 0) {\n            require(-x <= int256(uint256(discovered.minX)), \"NOT_REACHABLE_YET_MINX\");\n            x = -x + int32(_expansionDelta);\n            if (x > UINT32_MAX) {\n                x = UINT32_MAX;\n            }\n            if (int256(uint256(discovered.minX)) < x) {\n                discovered.minX = uint32(uint256(x));\n                changes = true;\n            }\n        } else {\n            require(x <= int256(uint256(discovered.maxX)), \"NOT_REACHABLE_YET_MAXX\");\n            x = x + int32(_expansionDelta);\n            if (x > UINT32_MAX) {\n                x = UINT32_MAX;\n            }\n            if (discovered.maxX < uint32(uint256(x))) {\n                discovered.maxX = uint32(uint256(x));\n                changes = true;\n            }\n        }\n\n        if (y < 0) {\n            require(-y <= int256(uint256(discovered.minY)), \"NOT_REACHABLE_YET_MINY\");\n            y = -y + int32(_expansionDelta);\n            if (y > UINT32_MAX) {\n                y = UINT32_MAX;\n            }\n            if (int256(uint256(discovered.minY)) < y) {\n                discovered.minY = uint32(uint256(y));\n                changes = true;\n            }\n        } else {\n            require(y <= int256(uint256(discovered.maxY)), \"NOT_REACHABLE_YET_MAXY\");\n            y = y + int32(_expansionDelta);\n            if (y > UINT32_MAX) {\n                y = UINT32_MAX;\n            }\n            if (int256(uint256(discovered.maxY)) < y) {\n                discovered.maxY = uint32(uint256(y));\n                changes = true;\n            }\n        }\n        if (changes) {\n            _discovered = discovered;\n        }\n    }\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // EXITS / WITHDRAWALS\n    // ---------------------------------------------------------------------------------------------------------------\n\n    function _handleExitComplete(PlanetUpdateState memory planetUpdate) internal {\n        uint256 stake = _completeExit(\n            planetUpdate.owner,\n            planetUpdate.location,\n            planetUpdate.data,\n            planetUpdate.exitStartTime\n        );\n\n        // Note we could Transfer to zero and Transfer from zero ?\n\n        // optional so we can use it in the batch withdraw,\n\n        uint256 newStake = _stakeReadyToBeWithdrawn[planetUpdate.owner] + stake;\n        _stakeReadyToBeWithdrawn[planetUpdate.owner] = newStake;\n        emit StakeToWithdraw(planetUpdate.owner, newStake);\n    }\n\n    function _completeExit(\n        address owner,\n        uint256 location,\n        bytes32 data,\n        uint256 exitStartTime\n    ) internal returns (uint256 stake) {\n        stake = uint256(_stake(data)) * (DECIMALS_14);\n        emit BlockTime(block.number, block.timestamp);\n        emit ExitComplete(owner, location, stake);\n\n        if (exitStartTime >= FACTION_STAKE_TRACKING_SWITCH_TIME) {\n            _notifyFactionRemove(owner, stake);\n        }\n\n        // --------------------------------------------------------\n        // Extra Reward was added\n        // --------------------------------------------------------\n        uint256 rewardId = _rewards[location];\n        if (rewardId != 0) {\n            // rewardId would contains the package. maybe this could be handled by an external contract\n            _rewardsToWithdraw[owner][rewardId] = true;\n            _rewards[location] = 0; // reset\n            // if you had reward to a planet in he process of exiting,\n            // you are adding the reward to the player exiting unless _setPlanetAfterExit is called first\n            emit RewardToWithdraw(owner, location, rewardId);\n        }\n        // --------------------------------------------------------\n    }\n\n    function _unsafe_exit_for(address owner, uint256 location) internal {\n        revert(\"DISABLED\");\n        Planet storage planet = _getPlanet(location);\n        (bool active, ) = _activeNumSpaceships(planet.numSpaceships);\n        require(active, \"NOT_ACTIVE\");\n        require(owner == planet.owner, \"NOT_OWNER\");\n        require(planet.exitStartTime == 0, \"EXITING_ALREADY\");\n\n        planet.exitStartTime = uint40(block.timestamp);\n        emit BlockTime(block.number, block.timestamp);\n        emit PlanetExit(owner, location);\n\n        // stake is removed as soon as we start exist\n        // If the exit is interupted, it is given to the player interupting\n        _notifyGeneratorRemove(owner, uint256(_stake(_planetData(location))) * (DECIMALS_14));\n        if (block.timestamp < FACTION_STAKE_TRACKING_SWITCH_TIME) {\n            _notifyFactionRemove(owner, uint256(_stake(_planetData(location))) * (DECIMALS_14));\n        }\n    }\n\n    function _fetchAndWithdrawFor(address owner, uint256[] calldata locations) internal {\n        uint256 addedStake = 0;\n        uint256 freeAddedStake = 0;\n        for (uint256 i = 0; i < locations.length; i++) {\n            Planet storage planet = _getPlanet(locations[i]);\n            if (_hasJustExited(planet.exitStartTime)) {\n                require(owner == planet.owner, \"NOT_OWNER\");\n                emit Transfer(owner, address(0), locations[i]);\n\n                addedStake += _completeExit(\n                    planet.owner,\n                    locations[i],\n                    _planetData(locations[i]),\n                    planet.exitStartTime\n                );\n\n                planet.owner = address(0);\n                planet.ownershipStartTime = 0;\n                planet.exitStartTime = 0;\n                planet.numSpaceships = 0;\n                planet.overflow = 0;\n                planet.travelingUpkeep = 0;\n                planet.lastUpdated = uint40(block.timestamp);\n            }\n        }\n        uint256 newStake = _stakeReadyToBeWithdrawn[owner] + addedStake;\n        _unsafe_withdrawAll(owner, newStake);\n    }\n\n    function _unsafe_withdrawAll(address owner, uint256 amount) internal {\n        _stakeReadyToBeWithdrawn[owner] = 0;\n        emit StakeToWithdraw(owner, amount);\n        require(_stakingToken.transfer(owner, amount), \"FAILED_TRANSFER\");\n        emit StakeToWithdraw(owner, 0);\n    }\n\n    function _hasJustExited(uint40 exitTime) internal view returns (bool) {\n        if (exitTime == 0) {\n            return false;\n        }\n        uint256 timestamp = block.timestamp;\n        if (_bootstrapSessionEndTime > 0 && timestamp >= _bootstrapSessionEndTime && exitTime < _infinityStartTime) {\n            return true;\n        }\n\n        return timestamp > exitTime + _exitDuration;\n    }\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // REWARDS\n    // ---------------------------------------------------------------------------------------------------------------\n\n    function _addReward(uint256 location, address sponsor) internal {\n        uint256 rewardId = _rewards[location];\n        require(rewardId == 0, \"REWARD_ALREADY_AT_THIS_LOCATION\");\n        // TODO ?\n        // Planet storage planet = _getPlanet(location);\n        // require(planet.lastUpdated == 0, \"PLANET_ALREADY_COLONIZED\");\n        rewardId = ++_prevRewardIds[sponsor];\n        _rewards[location] = (uint256(uint160(sponsor)) << 96) + rewardId;\n        emit RewardSetup(location, sponsor, rewardId);\n    }\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // FLEET SENDING\n    // ---------------------------------------------------------------------------------------------------------------\n\n    function _unsafe_sendFor(uint256 fleetId, address operator, FleetLaunch memory launch) internal whenNotPaused {\n        // -----------------------------------------------------------------------------------------------------------\n        // Initialise State Update\n        // -----------------------------------------------------------------------------------------------------------\n        Planet storage planet = _getPlanet(launch.from);\n        PlanetUpdateState memory planetUpdate = _createPlanetUpdateState(planet, launch.from);\n\n        // -----------------------------------------------------------------------------------------------------------\n        // check requirements\n        // -----------------------------------------------------------------------------------------------------------\n\n        require(launch.quantity < 2 ** 30, \"TOO_MANY_SPACESHIPS\"); // only 2^30 because the first 2 bits = resolution\n        require(launch.quantity > 0, \"NO_SPACESHIPS\");\n        require(planet.exitStartTime == 0, \"PLANET_EXIT\");\n        require(launch.fleetSender == planet.owner, \"NOT_OWNER\");\n\n        if (launch.fleetSender != launch.fleetOwner) {\n            require(_factionRegistry.isFromSameFaction(launch.fleetSender, launch.fleetOwner), \"FACTION_MISMATCH\");\n        }\n\n        // -----------------------------------------------------------------------------------------------------------\n        // Compute Basic Planet Updates\n        // -----------------------------------------------------------------------------------------------------------\n        _computePlanetUpdateForTimeElapsed(planetUpdate);\n\n        // -----------------------------------------------------------------------------------------------------------\n        // Requirements post Planet Updates\n        // -----------------------------------------------------------------------------------------------------------\n\n        require(planetUpdate.numSpaceships >= launch.quantity, \"SPACESHIPS_NOT_ENOUGH\");\n\n        // -----------------------------------------------------------------------------------------------------------\n        // Sending logic...\n        // -----------------------------------------------------------------------------------------------------------\n        _computePlanetUpdateForFleetLaunch(planetUpdate, launch.quantity);\n\n        // -----------------------------------------------------------------------------------------------------------\n        // Write New State\n        // -----------------------------------------------------------------------------------------------------------\n        _setPlanet(planet, planetUpdate, false);\n        // _setAccountFromPlanetUpdate(planetUpdate);\n\n        _setFleetFlyingSlot(launch.from, launch.quantity);\n\n        require(_fleets[fleetId].quantity == 0, \"FLEET_EXISTS\");\n        _fleets[fleetId] = Fleet({\n            launchTime: uint40(block.timestamp),\n            owner: launch.fleetOwner,\n            quantity: launch.quantity,\n            futureExtraProduction: planetUpdate.futureExtraProduction,\n            defender: address(0),\n            arrivalTime: 0,\n            defenderLoss: 0,\n            victory: false,\n            planetActive: false\n        });\n\n        emit BlockTime(block.number, block.timestamp);\n        emit FleetSent(\n            launch.fleetSender,\n            launch.fleetOwner,\n            launch.from,\n            operator,\n            fleetId,\n            launch.quantity,\n            planetUpdate.numSpaceships,\n            planetUpdate.travelingUpkeep,\n            planetUpdate.overflow\n        );\n    }\n\n    function _computePlanetUpdateForFleetLaunch(PlanetUpdateState memory planetUpdate, uint32 quantity) internal view {\n        planetUpdate.numSpaceships -= quantity;\n        if (_productionCapAsDuration > 0) {\n            if (planetUpdate.active) {\n                // NOTE we do not update travelingUpkeep on Inactive planets\n                //  these get reset on staking\n\n                uint16 production = _production(planetUpdate.data);\n                uint256 cap = _capWhenActive(production);\n                if (planetUpdate.numSpaceships < cap) {\n                    uint256 futureExtraProduction = cap - planetUpdate.numSpaceships;\n                    if (futureExtraProduction > quantity) {\n                        futureExtraProduction = quantity;\n                    }\n                    int256 newTravelingUpkeep = int256(planetUpdate.travelingUpkeep) + int256(futureExtraProduction);\n                    if (newTravelingUpkeep > int256(cap)) {\n                        newTravelingUpkeep = int256(cap);\n                    }\n                    planetUpdate.travelingUpkeep = int40(newTravelingUpkeep);\n                    planetUpdate.futureExtraProduction = uint24(futureExtraProduction); // cap is always smaller than uint24\n                }\n            }\n\n            if (planetUpdate.overflow > quantity) {\n                planetUpdate.overflow -= quantity;\n            } else {\n                planetUpdate.overflow = 0;\n            }\n        }\n    }\n\n    function _setFleetFlyingSlot(uint256 from, uint32 quantity) internal {\n        // -----------------------------------------------------------------------------------------------------------\n        // record flying fleets (to prevent front-running, see resolution)\n        // -----------------------------------------------------------------------------------------------------------\n        uint256 timeSlot = block.timestamp / (_frontrunningDelay / 2);\n        uint32 flying = _inFlight[from][timeSlot].flying;\n        unchecked {\n            flying = flying + quantity;\n        }\n        require(flying >= quantity, \"ORBIT_OVERFLOW\"); // unlikely to ever happen,\n        // would need a huge amount of spaceships to be received and each in turn being sent\n        // TOEXPLORE could also cap, that would result in some fleet being able to escape.\n        _inFlight[from][timeSlot].flying = flying;\n        // -----------------------------------------------------------------------------------------------------------\n    }\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // FLEET RESOLUTION, ATTACK / REINFORCEMENT\n    // ---------------------------------------------------------------------------------------------------------------\n    struct ResolutionState {\n        address fleetOwner;\n        uint40 fleetLaunchTime;\n        uint32 originalQuantity;\n        uint32 fleetQuantity;\n        bytes32 fromData;\n        uint32 inFlightFleetLoss;\n        uint32 inFlightPlanetLoss;\n        bool gifting;\n        bool taxed;\n        bool victory;\n        uint32 attackerLoss;\n        uint32 defenderLoss;\n        uint32 orbitDefense1;\n        uint32 orbitDefenseDestroyed1;\n        uint32 orbitDefense2;\n        uint32 orbitDefenseDestroyed2;\n        uint40 arrivalTime;\n        uint32 accumulatedDefenseAdded;\n        uint32 accumulatedAttackAdded;\n        uint16 attackPower;\n        uint24 futureExtraProduction;\n    }\n\n    function _resolveFleet(uint256 fleetId, FleetResolution calldata resolution) internal {\n        // -----------------------------------------------------------------------------------------------------------\n        // Initialise State Update\n        // -----------------------------------------------------------------------------------------------------------\n        Planet storage toPlanet = _getPlanet(resolution.to);\n        PlanetUpdateState memory toPlanetUpdate = _createPlanetUpdateState(toPlanet, resolution.to);\n        ResolutionState memory rState = _createResolutionState(_fleets[fleetId], resolution.from);\n\n        // -----------------------------------------------------------------------------------------------------------\n        // check requirements\n        // -----------------------------------------------------------------------------------------------------------\n\n        require(\n            rState.fleetQuantity > 0,\n            rState.fleetOwner != address(0) ? \"FLEET_RESOLVED_ALREADY\" : \"FLEET_DO_NOT_EXIST\"\n        );\n        _requireCorrectDistance(\n            resolution.distance,\n            resolution.from,\n            resolution.to,\n            rState.fromData,\n            toPlanetUpdate.data\n        );\n        _requireCorrectTimeAndUpdateArrivalTime(\n            resolution.distance,\n            resolution.arrivalTimeWanted,\n            rState.fleetLaunchTime,\n            rState.fromData,\n            rState\n        );\n\n        if (_bootstrapSessionEndTime > 0) {\n            uint256 timestamp = block.timestamp;\n\n            if (timestamp >= _bootstrapSessionEndTime) {\n                require(rState.fleetLaunchTime >= _infinityStartTime, \"FLEET_LAUNCHED_IN_BOOTSTRAP\");\n            }\n        }\n\n        // -----------------------------------------------------------------------------------------------------------\n        // Compute Basic Planet Updates\n        // -----------------------------------------------------------------------------------------------------------\n        _computePlanetUpdateForTimeElapsed(toPlanetUpdate);\n\n        address ownerAtArrival = toPlanetUpdate.newOwner; // this can be owner == address(0)\n\n        uint32 numSpaceshipsAtArrival = toPlanetUpdate.numSpaceships;\n\n        // -----------------------------------------------------------------------------------------------------------\n        // Traveling logic...\n        // -----------------------------------------------------------------------------------------------------------\n\n        _computeInFlightLossForFleet(rState, resolution);\n\n        // -----------------------------------------------------------------------------------------------------------\n        // Resolution logic...\n        // -----------------------------------------------------------------------------------------------------------\n\n        _updateFleetForGifting(rState, resolution, toPlanetUpdate.newOwner);\n\n        _computeResolutionResult(rState, toPlanetUpdate);\n\n        // -----------------------------------------------------------------------------------------------------------\n        // Write New State\n        // -----------------------------------------------------------------------------------------------------------\n\n        _recordInOrbitLossAfterAttack(rState, toPlanetUpdate);\n\n        _recordOrbitLossAccountingForFleetOrigin(rState, resolution);\n\n        _setTravelingUpkeepFromOrigin(fleetId, rState, resolution.from);\n\n        _setPlanet(toPlanet, toPlanetUpdate, rState.victory);\n\n        _setAccumulatedAttack(rState, toPlanetUpdate);\n\n        _fleets[fleetId].quantity = (1 << 31) | _fleets[fleetId].quantity;\n        _fleets[fleetId].defender = ownerAtArrival;\n        _fleets[fleetId].defenderLoss = rState.defenderLoss;\n        _fleets[fleetId].arrivalTime = uint40(block.timestamp);\n        _fleets[fleetId].planetActive = toPlanetUpdate.active;\n        _fleets[fleetId].victory = rState.victory;\n\n        // -----------------------------------------------------------------------------------------------------------\n        // Events\n        // -----------------------------------------------------------------------------------------------------------\n        _emitFleetArrived(\n            fleetId,\n            rState,\n            ownerAtArrival,\n            resolution,\n            _arrivalData(rState, toPlanetUpdate, numSpaceshipsAtArrival)\n        );\n\n        if (toPlanetUpdate.active && rState.victory) {\n            if (toPlanetUpdate.exitStartTime >= FACTION_STAKE_TRACKING_SWITCH_TIME) {\n                _notifyFactionMove(\n                    toPlanetUpdate.owner,\n                    toPlanetUpdate.newOwner,\n                    uint256(_stake(toPlanetUpdate.data)) * (DECIMALS_14)\n                );\n            }\n\n            // if active and the fleet was victorious we need to handle stake change of hands\n            if (toPlanetUpdate.exitStartTime != 0) {\n                // exit has been interupted\n                // we add stake to new owner\n                _notifyGeneratorAdd(toPlanetUpdate.newOwner, uint256(_stake(toPlanetUpdate.data)) * (DECIMALS_14));\n                if (toPlanetUpdate.exitStartTime < FACTION_STAKE_TRACKING_SWITCH_TIME) {\n                    _notifyFactionAdd(toPlanetUpdate.newOwner, uint256(_stake(toPlanetUpdate.data)) * (DECIMALS_14));\n                }\n            } else {\n                // there was no exit, so we move the stake\n                _notifyGeneratorMove(\n                    toPlanetUpdate.owner,\n                    toPlanetUpdate.newOwner,\n                    uint256(_stake(toPlanetUpdate.data)) * (DECIMALS_14)\n                );\n                if (toPlanetUpdate.exitStartTime < FACTION_STAKE_TRACKING_SWITCH_TIME) {\n                    _notifyFactionMove(\n                        toPlanetUpdate.owner,\n                        toPlanetUpdate.newOwner,\n                        uint256(_stake(toPlanetUpdate.data)) * (DECIMALS_14)\n                    );\n                }\n            }\n        }\n    }\n\n    function _arrivalData(\n        ResolutionState memory rState,\n        PlanetUpdateState memory toPlanetUpdate,\n        uint32 numSpaceshipsAtArrival\n    ) internal pure returns (ArrivalData memory arrivalData) {\n        arrivalData.newNumspaceships = toPlanetUpdate.numSpaceships;\n        arrivalData.newTravelingUpkeep = toPlanetUpdate.travelingUpkeep;\n        arrivalData.newOverflow = toPlanetUpdate.overflow;\n        arrivalData.numSpaceshipsAtArrival = numSpaceshipsAtArrival;\n        arrivalData.taxLoss = rState.taxed\n            ? (rState.originalQuantity - rState.inFlightFleetLoss) - rState.fleetQuantity\n            : 0;\n        arrivalData.fleetLoss = rState.attackerLoss;\n        arrivalData.planetLoss = rState.defenderLoss;\n        arrivalData.inFlightFleetLoss = rState.inFlightFleetLoss;\n        arrivalData.inFlightPlanetLoss = rState.inFlightPlanetLoss;\n        arrivalData.accumulatedDefenseAdded = rState.accumulatedDefenseAdded;\n        arrivalData.accumulatedAttackAdded = rState.accumulatedAttackAdded;\n    }\n\n    function _emitFleetArrived(\n        uint256 fleetId,\n        ResolutionState memory rState,\n        address planetOwner,\n        FleetResolution memory resolution,\n        ArrivalData memory arrivalData\n    ) internal {\n        emit BlockTime(block.number, block.timestamp);\n        emit FleetRevealed(\n            fleetId,\n            resolution.from,\n            resolution.to,\n            resolution.arrivalTimeWanted,\n            resolution.gift,\n            resolution.specific,\n            resolution.secret,\n            resolution.fleetSender,\n            resolution.operator\n        );\n        emit FleetArrived(\n            fleetId,\n            rState.fleetOwner,\n            planetOwner,\n            resolution.to,\n            rState.gifting,\n            rState.victory,\n            arrivalData\n        );\n    }\n\n    function _requireCorrectDistance(\n        uint256 distance,\n        uint256 from,\n        uint256 to,\n        bytes32 fromPlanetData,\n        bytes32 toPlanetData\n    ) internal pure {\n        // check input instead of compute sqrt\n\n        (int8 fromSubX, int8 fromSubY) = _subLocation(fromPlanetData);\n        (int8 toSubX, int8 toSubY) = _subLocation(toPlanetData);\n        uint256 distanceSquared = uint256(\n            int256( // check input instead of compute sqrt\n                ((int128(int256(to & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) * 4 + toSubX) -\n                    (int128(int256(from & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) * 4 + fromSubX)) **\n                    2 +\n                    ((int128(int256(to >> 128)) * 4 + toSubY) - (int128(int256(from >> 128)) * 4 + fromSubY)) ** 2\n            )\n        );\n        require(distance ** 2 <= distanceSquared && distanceSquared < (distance + 1) ** 2, \"wrong distance\");\n    }\n\n    function _requireCorrectTimeAndUpdateArrivalTime(\n        uint256 distance,\n        uint256 arrivalTimeWanted,\n        uint40 launchTime,\n        bytes32 fromPlanetData,\n        ResolutionState memory rState\n    ) internal view {\n        uint256 minReachTime = launchTime + (distance * (_timePerDistance * 10000)) / _speed(fromPlanetData);\n        uint256 reachTime = Math.max(arrivalTimeWanted, minReachTime);\n        if (arrivalTimeWanted > 0) {\n            rState.arrivalTime = uint40(arrivalTimeWanted);\n        } else {\n            rState.arrivalTime = uint40(minReachTime);\n        }\n        require(block.timestamp >= reachTime, \"too early\");\n        require(block.timestamp < reachTime + _resolveWindow, \"too late, your spaceships are lost in space\");\n    }\n\n    function _computeInFlightLossForFleet(\n        ResolutionState memory rState,\n        FleetResolution memory resolution\n    ) internal view {\n        // -----------------------------------------------------------------------------------------------------------\n        // check if fleet was attacked while departing (used to prevent front-running, see fleet sending)\n        // -----------------------------------------------------------------------------------------------------------\n        uint256 timeSlot = rState.fleetLaunchTime / (_frontrunningDelay / 2);\n        uint32 destroyed = _inFlight[resolution.from][timeSlot].destroyed;\n        uint32 originalQuantity = rState.fleetQuantity;\n        if (destroyed < rState.fleetQuantity) {\n            rState.fleetQuantity -= uint32(destroyed);\n        } else {\n            rState.fleetQuantity = 0;\n        }\n\n        rState.inFlightFleetLoss = originalQuantity - rState.fleetQuantity;\n        // -----------------------------------------------------------------------------------------------------------\n    }\n\n    function _updateFleetForGifting(\n        ResolutionState memory rState,\n        FleetResolution memory resolution,\n        address destinationOwner\n    ) internal view {\n        (bool gifting, bool taxed) = _computeGifting(destinationOwner, resolution, rState);\n        rState.gifting = gifting;\n        rState.taxed = taxed;\n    }\n\n    // TODO simplify and apply that to attack (when fleetOwner is not fleetSender)\n    //  if (resolution.gift) { rState.fleetOwner = destinationOwner }\n    //  then compute tax based on fleetOwner != fleetSender, box for attacks and gift\n    //  combined attack could even work for non-allies ?\n    //  in _computeGift calculate the tax for every branch that result in `gifting` being false\n    //  then in attack, add tax to the quantity of fleet + modify event\n\n    // solhint-disable-next-line code-complexity\n    function _computeGifting(\n        address destinationOwner,\n        FleetResolution memory resolution,\n        ResolutionState memory rState\n    ) internal view returns (bool gifting, bool taxed) {\n        if (destinationOwner == address(0)) {\n            // destination has no owner : this is an attack\n            return (false, _isFleetOwnerTaxed(rState.fleetOwner, resolution.fleetSender, rState.fleetLaunchTime));\n        }\n        if (destinationOwner == rState.fleetOwner && destinationOwner == resolution.fleetSender) {\n            // destination is sender is fleet owner: this is a non-taxed gift\n            return (true, false);\n        }\n\n        // both fleetSender and fleetOwner need to be in the same faction of destination\n        //  for the resolution to be a gift\n        //  every other case this is an attack\n        //  it means that if you biy spaceships from someone, these can only be used for attack, even against yourself\n        bool destinationOwnerAndFleetOwnerAreAllies = _factionRegistry.isFromSameFaction(\n            destinationOwner,\n            rState.fleetOwner\n        );\n        bool destinationOwnerAndFleetSenderAreAllies = _factionRegistry.isFromSameFaction(\n            destinationOwner,\n            resolution.fleetSender\n        );\n        if (destinationOwnerAndFleetOwnerAreAllies && destinationOwnerAndFleetSenderAreAllies) {\n            return (true, false);\n        } else {\n            return (false, false);\n        }\n    }\n\n    function _isFleetOwnerTaxed(\n        address fleetOwner,\n        address fleetSender,\n        uint40 fleetLaunchTime\n    ) internal view returns (bool) {\n        if (fleetOwner == fleetSender) {\n            return false;\n        }\n        return !_factionRegistry.isFromSameFaction(fleetOwner, fleetSender);\n    }\n\n    function _setTravelingUpkeepFromOrigin(uint256 fleetID, ResolutionState memory rState, uint256 location) internal {\n        // // we have to update the origin\n        Planet storage fromPlanet = _planets[location];\n        PlanetUpdateState memory fromPlanetUpdate = _createPlanetUpdateState(fromPlanet, location);\n        _computePlanetUpdateForTimeElapsed(fromPlanetUpdate);\n\n        uint16 production = _production(fromPlanetUpdate.data);\n        uint256 capWhenActive = _capWhenActive(production);\n\n        uint256 refund = rState.futureExtraProduction;\n        uint256 timePassed = block.timestamp - rState.fleetLaunchTime;\n        uint256 amountProducedTheWholeTime = (timePassed * uint256(_productionSpeedUp) * uint256(production)) / 1 hours;\n        uint256 consumed = amountProducedTheWholeTime +\n            (amountProducedTheWholeTime * _upkeepProductionDecreaseRatePer10000th) /\n            10000;\n        if (consumed > refund) {\n            refund = 0;\n        } else {\n            refund -= consumed;\n        }\n\n        int256 newTravelingUpkeep = int256(fromPlanetUpdate.travelingUpkeep) - int256(refund);\n        if (newTravelingUpkeep < -int256(capWhenActive)) {\n            newTravelingUpkeep = -int256(capWhenActive);\n        }\n        fromPlanetUpdate.travelingUpkeep = int40(newTravelingUpkeep);\n\n        _setPlanet(fromPlanet, fromPlanetUpdate, false);\n\n        emit BlockTime(block.number, block.timestamp);\n        emit TravelingUpkeepRefund(\n            location,\n            fleetID,\n            fromPlanetUpdate.numSpaceships,\n            fromPlanetUpdate.travelingUpkeep,\n            fromPlanetUpdate.overflow\n        );\n    }\n\n    function _setAccumulatedAttack(ResolutionState memory rState, PlanetUpdateState memory toPlanetUpdate) internal {\n        if (!rState.taxed) {\n            AccumulatedAttack storage attack = _attacks[toPlanetUpdate.location][rState.fleetOwner][rState.arrivalTime];\n\n            // NOTE: target is required for the case where a different player capture the planet in-between\n            //  otherwise, that player would be hitted with higher attack than would be fair\n            //  hmm would it acutally ? the accumulatedDefenseAdded would still be counted\n            //  Indeed, the only real player affected by _attacks[location][fleetOwner][arrivalTime] is the fleetOwner\n            //  regardless of who is owner of the planet\n            // attack.target = toPlanetUpdate.owner;\n            // we leave this as is as we do not want to change the struct\n            attack.damageCausedSoFar = rState.defenderLoss + rState.inFlightPlanetLoss + rState.accumulatedDefenseAdded;\n            attack.numAttackSpent =\n                rState.attackerLoss +\n                rState.accumulatedAttackAdded +\n                // when victorius we consider the full number of spaceship as used\n                // this way if a combined attack arrive later, it can still count the whole attack and get a refund\n                (rState.victory ? toPlanetUpdate.numSpaceships : 0);\n            attack.averageAttackPower = rState.attackPower;\n        }\n    }\n\n    function _combinedRefund(\n        ResolutionState memory rState,\n        PlanetUpdateState memory toPlanetUpdate\n    ) internal view returns (uint256 accumulationRefund) {\n        _updateAccumulation(rState, toPlanetUpdate);\n        if (rState.accumulatedAttackAdded > 0) {\n            uint16 attack = rState.attackPower;\n            uint16 defense = _defense(toPlanetUpdate.data);\n            uint256 numAttack = rState.fleetQuantity + rState.accumulatedAttackAdded;\n            (uint32 attackerLoss, ) = _computeFight(numAttack, rState.accumulatedDefenseAdded, attack, defense);\n            if (rState.accumulatedAttackAdded > attackerLoss) {\n                accumulationRefund = rState.accumulatedAttackAdded - attackerLoss;\n                if (accumulationRefund > rState.accumulatedAttackAdded) {\n                    rState.accumulatedAttackAdded = 0;\n                } else {\n                    rState.accumulatedAttackAdded = uint32(uint256(rState.accumulatedAttackAdded) - accumulationRefund);\n                }\n            }\n        }\n    }\n\n    function _createResolutionState(\n        Fleet storage fleet,\n        uint256 from\n    ) internal view returns (ResolutionState memory rState) {\n        uint32 q = fleet.quantity >> 31 == 1 ? 0 : fleet.quantity;\n        rState.fleetOwner = fleet.owner;\n        rState.fleetLaunchTime = fleet.launchTime;\n        rState.originalQuantity = q;\n        rState.fleetQuantity = q;\n        rState.futureExtraProduction = fleet.futureExtraProduction;\n        rState.fromData = _planetData(from);\n        rState.attackPower = _attack(rState.fromData);\n    }\n\n    function _recordOrbitLossAccountingForFleetOrigin(\n        ResolutionState memory rState,\n        FleetResolution memory resolution\n    ) internal {\n        if (rState.inFlightFleetLoss > 0) {\n            uint256 timeSlot = rState.fleetLaunchTime / (_frontrunningDelay / 2);\n\n            // NOTE we already computed that destroyed cannot be smaller than inFlightFleetLoss\n            //  see _computeInFlightLossForFleet\n            _inFlight[resolution.from][timeSlot].destroyed -= rState.inFlightFleetLoss;\n        }\n    }\n\n    function _computeResolutionResult(\n        ResolutionState memory rState,\n        PlanetUpdateState memory toPlanetUpdate\n    ) internal view {\n        if (rState.taxed) {\n            rState.fleetQuantity = uint32(\n                uint256(rState.fleetQuantity) - (uint256(rState.fleetQuantity) * _giftTaxPer10000) / 10000\n            );\n        }\n        if (rState.gifting) {\n            _computeGiftingResolutionResult(rState, toPlanetUpdate);\n        } else {\n            _computeAttackResolutionResult(rState, toPlanetUpdate);\n        }\n    }\n\n    function _computeGiftingResolutionResult(\n        ResolutionState memory rState,\n        PlanetUpdateState memory toPlanetUpdate\n    ) internal view {\n        uint256 newNumSpaceships = toPlanetUpdate.numSpaceships +\n            rState.fleetQuantity +\n            _combinedRefund(rState, toPlanetUpdate);\n        if (newNumSpaceships >= ACTIVE_MASK) {\n            newNumSpaceships = ACTIVE_MASK - 1;\n        }\n\n        toPlanetUpdate.numSpaceships = uint32(newNumSpaceships);\n        if (!toPlanetUpdate.active) {\n            // NOTE: not active, overflow is applied on cap = 0\n            if (toPlanetUpdate.numSpaceships > toPlanetUpdate.overflow) {\n                toPlanetUpdate.overflow = toPlanetUpdate.numSpaceships;\n            }\n        } else {\n            uint32 cap = uint32(_capWhenActive(_production(toPlanetUpdate.data)));\n            if (_productionCapAsDuration > 0 && newNumSpaceships > cap) {\n                if (toPlanetUpdate.numSpaceships - cap > toPlanetUpdate.overflow) {\n                    toPlanetUpdate.overflow = uint32(toPlanetUpdate.numSpaceships - cap);\n                }\n            } else {\n                toPlanetUpdate.overflow = 0;\n            }\n        }\n    }\n\n    function _updateAccumulation(ResolutionState memory rState, PlanetUpdateState memory toPlanetUpdate) internal view {\n        // TODO 45min config ?\n        if (!rState.taxed && block.timestamp < rState.arrivalTime + 45 minutes) {\n            AccumulatedAttack memory acc = _attacks[toPlanetUpdate.location][rState.fleetOwner][rState.arrivalTime];\n\n            // TODO  acc.target == toPlanetUpdate.owner || toPlanetUpdate.owner == fleetOwner  so your combined attack works when you get it\n            // what about your allies ?\n            // taxed work as he accumulated attack is already shared with allies (s)\n            // so we should not need to modify here ?\n            // if (acc.target == toPlanetUpdate.owner && acc.numAttackSpent != 0) {\n            if (acc.numAttackSpent != 0) {\n                rState.attackPower = uint16(\n                    (uint256(rState.attackPower) *\n                        uint256(rState.fleetQuantity) +\n                        uint256(acc.averageAttackPower) *\n                        uint256(acc.numAttackSpent)) / (uint256(rState.fleetQuantity) + uint256(acc.numAttackSpent))\n                );\n                rState.accumulatedAttackAdded = acc.numAttackSpent;\n                rState.accumulatedDefenseAdded = acc.damageCausedSoFar;\n            }\n        }\n    }\n\n    function _computeAttackResolutionResult(\n        ResolutionState memory rState,\n        PlanetUpdateState memory toPlanetUpdate\n    ) internal view {\n        // NOTE natives come back to power once numSPaceships == 0 and planet not active\n        if (!toPlanetUpdate.active && toPlanetUpdate.numSpaceships < _natives(toPlanetUpdate.data)) {\n            _updatePlanetUpdateStateAndResolutionStateForNativeAttack(rState, toPlanetUpdate);\n        } else {\n            _updateAccumulation(rState, toPlanetUpdate);\n\n            _updatePlanetUpdateStateAndResolutionStateForPlanetAttack(rState, toPlanetUpdate);\n        }\n    }\n\n    function _updatePlanetUpdateStateAndResolutionStateForNativeAttack(\n        ResolutionState memory rState,\n        PlanetUpdateState memory toPlanetUpdate\n    ) internal view {\n        // NOTE: when we are dealing with native attacks, we do not consider combined attacks\n        // TODO We need to consider that case in the UI\n        uint16 attack = _attack(rState.fromData);\n        uint16 defense = _defense(toPlanetUpdate.data);\n        uint16 natives = _natives(toPlanetUpdate.data);\n        (uint32 attackerLoss, uint32 defenderLoss) = _computeFight(rState.fleetQuantity, natives, attack, defense);\n        rState.attackerLoss = attackerLoss;\n        if (defenderLoss == natives && rState.fleetQuantity > attackerLoss) {\n            // (attackerLoss: 0, defenderLoss: 0) means that numAttack was zero as natives cannot be zero\n            toPlanetUpdate.numSpaceships = rState.fleetQuantity - attackerLoss;\n            rState.defenderLoss = defenderLoss;\n            rState.victory = true;\n            toPlanetUpdate.newOwner = rState.fleetOwner;\n            // solhint-disable-next-line no-empty-blocks\n        }\n        // NOTE else (attacker lost) then nothing happen\n    }\n\n    function _updatePlanetUpdateStateAndResolutionStateForPlanetAttack(\n        ResolutionState memory rState,\n        PlanetUpdateState memory toPlanetUpdate\n    ) internal view {\n        _updateResolutionStateFromOrbitDefense(rState, toPlanetUpdate);\n        uint256 numDefense = toPlanetUpdate.numSpaceships +\n            rState.accumulatedDefenseAdded +\n            rState.orbitDefense1 +\n            rState.orbitDefense2;\n        uint16 production = _production(toPlanetUpdate.data);\n\n        if (numDefense == 0 && rState.fleetQuantity > 0) {\n            // scenario where there is actually no defense on the place,\n\n            toPlanetUpdate.newOwner = rState.fleetOwner;\n            toPlanetUpdate.numSpaceships = rState.fleetQuantity;\n            if (!toPlanetUpdate.active) {\n                // numDefense = 0 so numAttack is the overflow, attacker took over\n                toPlanetUpdate.overflow = toPlanetUpdate.numSpaceships;\n            } else {\n                if (_productionCapAsDuration > 0) {\n                    uint32 cap = uint32(_capWhenActive(production));\n                    if (toPlanetUpdate.numSpaceships > cap) {\n                        // numDefense = 0 so numAttack is the overflow, attacker took over\n                        toPlanetUpdate.overflow = uint32(toPlanetUpdate.numSpaceships - cap);\n                    } else {\n                        toPlanetUpdate.overflow = 0;\n                    }\n                }\n            }\n\n            rState.victory = true;\n        } else {\n            _computeAttack(rState, toPlanetUpdate, numDefense);\n            _computeTravelingUpkeepReductionFromDefenseLoss(rState, toPlanetUpdate, production);\n        }\n    }\n\n    function _updateResolutionStateFromOrbitDefense(\n        ResolutionState memory rState,\n        PlanetUpdateState memory toPlanetUpdate\n    ) internal view {\n        // -----------------------------------------------------------------------------------------------------------\n        // consider fleets that just departed from the planet (used to prevent front-running, see fleet sending)\n        // -----------------------------------------------------------------------------------------------------------\n        uint256 timeSlot = block.timestamp / (_frontrunningDelay / 2);\n        InFlight storage slot1 = _inFlight[toPlanetUpdate.location][timeSlot - 1];\n        rState.orbitDefense1 = slot1.flying > 2 ** 31 ? 2 ** 31 - 1 : uint32(slot1.flying);\n        rState.orbitDefenseDestroyed1 = slot1.destroyed > 2 ** 31 ? 2 ** 31 - 1 : uint32(slot1.destroyed);\n        InFlight storage slot2 = _inFlight[toPlanetUpdate.location][timeSlot];\n        rState.orbitDefense2 = slot2.flying > 2 ** 31 ? 2 ** 31 - 1 : uint32(slot2.flying);\n        rState.orbitDefenseDestroyed2 = slot2.destroyed > 2 ** 31 ? 2 ** 31 - 1 : uint32(slot2.destroyed);\n    }\n\n    // solhint-disable-next-line code-complexity\n    function _computeAttack(\n        ResolutionState memory rState,\n        PlanetUpdateState memory toPlanetUpdate,\n        uint256 numDefense\n    ) internal view {\n        uint16 attack = rState.attackPower;\n        uint16 defense = _defense(toPlanetUpdate.data);\n        uint256 numAttack = rState.fleetQuantity + rState.accumulatedAttackAdded;\n        (uint32 attackerLoss, uint32 defenderLoss) = _computeFight(numAttack, numDefense, attack, defense);\n        rState.defenderLoss = defenderLoss;\n        rState.attackerLoss = rState.accumulatedAttackAdded > attackerLoss\n            ? 0\n            : attackerLoss - rState.accumulatedAttackAdded;\n\n        // (attackerLoss: 0, defenderLoss: 0) could either mean attack was zero or defense was zero :\n        if (rState.fleetQuantity > 0 && rState.defenderLoss == numDefense) {\n            // NOTE Attacker wins\n\n            // all orbiting fleets are destroyed, inFlightPlanetLoss is all that is left\n            uint256 inFlightPlanetLoss = numDefense - toPlanetUpdate.numSpaceships - rState.accumulatedDefenseAdded;\n            if (inFlightPlanetLoss > ACTIVE_MASK) {\n                // cap it\n                // TODO investigate potential issues\n                inFlightPlanetLoss = ACTIVE_MASK - 1;\n            }\n            rState.inFlightPlanetLoss = uint32(inFlightPlanetLoss);\n\n            rState.defenderLoss = rState.defenderLoss - rState.inFlightPlanetLoss;\n\n            toPlanetUpdate.numSpaceships = rState.fleetQuantity - rState.attackerLoss;\n            rState.victory = true;\n\n            toPlanetUpdate.newOwner = rState.fleetOwner;\n\n            if (!toPlanetUpdate.active) {\n                // attack took over, overflow is numSpaceships\n                toPlanetUpdate.overflow = toPlanetUpdate.numSpaceships;\n            } else {\n                if (_productionCapAsDuration > 0) {\n                    uint16 production = _production(toPlanetUpdate.data);\n                    uint32 cap = uint32(_capWhenActive(production));\n                    if (toPlanetUpdate.numSpaceships > cap) {\n                        if (toPlanetUpdate.numSpaceships - cap > toPlanetUpdate.overflow) {\n                            toPlanetUpdate.overflow = toPlanetUpdate.numSpaceships - cap;\n                        }\n                    } else {\n                        toPlanetUpdate.overflow = 0;\n                    }\n                }\n            }\n        } else if (rState.attackerLoss == rState.fleetQuantity) {\n            // NOTE Defender wins\n\n            if (defenderLoss > toPlanetUpdate.numSpaceships + rState.accumulatedDefenseAdded) {\n                rState.inFlightPlanetLoss =\n                    defenderLoss -\n                    toPlanetUpdate.numSpaceships -\n                    rState.accumulatedDefenseAdded;\n\n                toPlanetUpdate.numSpaceships = 0;\n                // TODO change owner already if incative ?\n                //  not needed though as this is the same has having numSpaceships = 1 and become zero over time\n\n                if (rState.orbitDefense1 >= rState.inFlightPlanetLoss) {\n                    rState.orbitDefense1 -= rState.inFlightPlanetLoss;\n                    rState.orbitDefenseDestroyed1 += rState.inFlightPlanetLoss;\n                } else {\n                    rState.orbitDefenseDestroyed1 += rState.orbitDefense1;\n                    uint32 extra = (rState.inFlightPlanetLoss - rState.orbitDefense1);\n                    if (rState.orbitDefense2 >= extra) {\n                        rState.orbitDefense2 -= extra;\n                        rState.orbitDefenseDestroyed2 += extra;\n                    } else {\n                        rState.orbitDefenseDestroyed2 += rState.orbitDefense2;\n                        rState.orbitDefense2 = 0; // should never reach minus but let simply set it to zero\n                    }\n                    rState.orbitDefense1 = 0;\n                }\n            } else {\n                toPlanetUpdate.numSpaceships =\n                    toPlanetUpdate.numSpaceships +\n                    rState.accumulatedDefenseAdded -\n                    defenderLoss;\n\n                // TODO change owner already if incative and numSpaceship == 0 (like above)\n                //  not needed though as this is the same has having numSpaceships = 1 and become zero over time\n            }\n\n            // same as numSpaceshipAtArrival - toPlanetUpdate.numSpaceship;\n            rState.defenderLoss = rState.defenderLoss - rState.inFlightPlanetLoss - rState.accumulatedDefenseAdded;\n\n            if (!toPlanetUpdate.active) {\n                if (defenderLoss > toPlanetUpdate.overflow) {\n                    toPlanetUpdate.overflow = 0;\n                } else {\n                    toPlanetUpdate.overflow -= defenderLoss;\n                }\n            } else {\n                if (_productionCapAsDuration > 0) {\n                    uint16 production = _production(toPlanetUpdate.data);\n                    uint32 cap = uint32(_capWhenActive(production));\n                    if (toPlanetUpdate.numSpaceships > cap) {\n                        if (defenderLoss <= toPlanetUpdate.overflow) {\n                            toPlanetUpdate.overflow -= defenderLoss;\n                        } else {\n                            toPlanetUpdate.overflow = 0;\n                        }\n                    } else {\n                        toPlanetUpdate.overflow = 0;\n                    }\n                }\n            }\n        } else {\n            // should not happen\n            // because we check for numDefense == 0 before performing the attack, see _updatePlanetUpdateStateAndResolutionStateForPlanetAttack\n            revert(\"ZERO_ZERO\");\n        }\n    }\n\n    function _computeFight(\n        uint256 numAttack,\n        uint256 numDefense,\n        uint256 attack,\n        uint256 defense\n    ) internal view returns (uint32 attackerLoss, uint32 defenderLoss) {\n        if (numAttack == 0 || numDefense == 0) {\n            // this edge case need to be considered,\n            // as the result of this function cannot tell from it whos is winning here\n            return (0, 0);\n        }\n\n        uint256 attackFactor = numAttack *\n            ((1000000 - _fleetSizeFactor6) + ((_fleetSizeFactor6 * numAttack) / numDefense));\n        uint256 attackDamage = (attackFactor * attack) / defense / 1000000;\n\n        if (numDefense > attackDamage) {\n            // attack fails\n            attackerLoss = uint32(numAttack); // all attack destroyed\n            defenderLoss = uint32(attackDamage); // 1 spaceship will be left at least as attackDamage < numDefense\n        } else {\n            // attack succeed\n            uint256 defenseFactor = numDefense *\n                ((1000000 - _fleetSizeFactor6) + ((_fleetSizeFactor6 * numDefense) / numAttack));\n            uint256 defenseDamage = uint32((defenseFactor * defense) / attack / 1000000);\n\n            if (defenseDamage >= numAttack) {\n                defenseDamage = numAttack - 1; // ensure 1 spaceship left\n            }\n\n            attackerLoss = uint32(defenseDamage);\n            defenderLoss = uint32(numDefense); // all defense destroyed\n        }\n    }\n\n    function _computeTravelingUpkeepReductionFromDefenseLoss(\n        ResolutionState memory rState,\n        PlanetUpdateState memory toPlanetUpdate,\n        uint16 production\n    ) internal view {\n        // allow the attacker to pay for upkeep as part of the attack\n        // only get to keep the upkeep that was there as a result of spaceships sent away\n\n        uint256 capWhenActive = _capWhenActive(production);\n\n        int256 totalDefenseLoss = int256(uint256(rState.defenderLoss) + uint256(rState.inFlightPlanetLoss));\n        int256 newTravelingUpkeep = int256(toPlanetUpdate.travelingUpkeep) - totalDefenseLoss;\n        if (newTravelingUpkeep < -int256(capWhenActive)) {\n            newTravelingUpkeep = -int256(capWhenActive);\n        }\n        toPlanetUpdate.travelingUpkeep = int40(newTravelingUpkeep);\n    }\n\n    function _recordInOrbitLossAfterAttack(\n        ResolutionState memory rState,\n        PlanetUpdateState memory toPlanetUpdate\n    ) internal {\n        if (rState.inFlightPlanetLoss > 0) {\n            InFlight storage slot1 = _inFlight[toPlanetUpdate.location][block.timestamp / (_frontrunningDelay / 2) - 1];\n            slot1.flying = rState.orbitDefense1;\n            slot1.destroyed = rState.orbitDefenseDestroyed1;\n\n            InFlight storage slot2 = _inFlight[toPlanetUpdate.location][block.timestamp / (_frontrunningDelay / 2)];\n            slot2.flying = rState.orbitDefense2;\n            slot2.destroyed = rState.orbitDefenseDestroyed2;\n        }\n    }\n\n    function _callWithGas(address to, bytes memory data, uint256 gas) internal {\n        // We want to ensure enough gas were given for the generator, but no more\n        // This way if the generator is broken/compromised (we are planning to update it)\n        // then this will always continue to work\n        // Reversely, a player have to provide enough gas\n        // and we want to ensure the player can't force a revert on the hook\n        // In particular. to prevent players to make a call to `remove` fails\n\n        if (to != address(0)) {\n            // we could do the check prior:\n            // uint256 gasAvailable = gasleft() - 2000;\n            // require(gasAvailable - gasAvailable / 64  >= gas, \"NOT_ENOUGH_GAS_FOR_INNER_CALL\");\n            // to.call{gas: gas}(data);\n            // but we instead chose to do the check after.\n            // for more info see: https://ronan.eth.limo/blog/ethereum-gas-dangers/\n\n            to.call{gas: gas}(data);\n            // we use after the gas check as this allow us to not require heavy gas use if not needed\n            // instead of + 100,000 for 96,000 gas we can just add 1,524 gas (+ a bit more)\n            require(gasleft() > gas / 63, \"NOT_ENOUGH_GAS_FOR_INNER_CALL\");\n        }\n    }\n\n    function _generator() internal view returns (address generator) {\n        assembly {\n            // keccak256(\"generator\") - 1\n            generator := sload(0x27ec6af4a6510eb9b7e0cc7f39415b7f15e430e53eb0cd3997e7c7e0cf680f6e)\n        }\n    }\n\n    function _notifyGeneratorAdd(address player, uint256 amount) internal {\n        _callWithGas(_generator(), abi.encodeWithSelector(IOnStakeChange.add.selector, player, amount), 96000);\n    }\n\n    function _notifyGeneratorRemove(address player, uint256 amount) internal {\n        _callWithGas(_generator(), abi.encodeWithSelector(IOnStakeChange.remove.selector, player, amount), 96000);\n    }\n\n    function _notifyGeneratorMove(address from, address to, uint256 amount) internal {\n        _callWithGas(_generator(), abi.encodeWithSelector(IOnStakeChange.move.selector, from, to, amount), 192000);\n    }\n\n    function _notifyFactionAdd(address player, uint256 amount) internal {\n        _callWithGas(\n            address(_factionRegistry),\n            abi.encodeWithSelector(IOnStakeChange.add.selector, player, amount),\n            96000\n        );\n    }\n\n    function _notifyFactionRemove(address player, uint256 amount) internal {\n        _callWithGas(\n            address(_factionRegistry),\n            abi.encodeWithSelector(IOnStakeChange.remove.selector, player, amount),\n            96000\n        );\n    }\n\n    function _notifyFactionMove(address from, address to, uint256 amount) internal {\n        _callWithGas(\n            address(_factionRegistry),\n            abi.encodeWithSelector(IOnStakeChange.move.selector, from, to, amount),\n            96000\n        );\n    }\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // PLANET STATS\n    // ---------------------------------------------------------------------------------------------------------------\n\n    function _planetData(uint256 location) internal view returns (bytes32) {\n        return keccak256(abi.encodePacked(_genesis, location));\n    }\n\n    function _subLocation(bytes32 data) internal pure returns (int8 subX, int8 subY) {\n        subX = 1 - int8(data.value8Mod(0, 3));\n        subY = 1 - int8(data.value8Mod(2, 3));\n    }\n\n    function _stake(bytes32 data) internal view returns (uint32) {\n        require(_exists(data), \"PLANET_NOT_EXISTS\");\n        // return data.normal16(4, 0x000400050005000A000A000F000F00140014001E001E00280028005000500064);\n        uint8 productionIndex = data.normal8(12); // production affect the stake value\n\n        // TODO remove or decide otherwise:\n        // uint16 offset = data.normal16(4, 0x0000000100010002000200030003000400040005000500060006000700070008);\n        // uint16 stakeIndex = productionIndex + offset;\n        // if (stakeIndex < 4) {\n        //     stakeIndex = 0;\n        // } else if (stakeIndex > 19) {\n        //     stakeIndex = 15;\n        // } else {\n        //     stakeIndex -= 4;\n        // }\n        uint16 stakeIndex = productionIndex;\n        return\n            uint32(\n                uint256(\n                    uint16(uint8(_stakeRange[stakeIndex * 2])) * 0x100 + uint16(uint8(_stakeRange[stakeIndex * 2 + 1]))\n                ) * _stakeMultiplier10000th\n            );\n    }\n\n    function _production(bytes32 data) internal pure returns (uint16) {\n        require(_exists(data), \"PLANET_NOT_EXISTS\");\n        // TODO TRY : 1800,2100,2400,2700,3000,3300,3600, 3600, 3600, 3600,4000,4400,4800,5400,6200,7200 ?\n\n        // 1800,2100,2400,2700,3000,3300,3600, 3600, 3600, 3600,4200,5400,6600,7800,9000,12000\n        // 0x0708083409600a8c0bb80ce40e100e100e100e101068151819c81e7823282ee0\n        return data.normal16(12, 0x0708083409600a8c0bb80ce40e100e100e100e101068151819c81e7823282ee0); // per hour\n    }\n\n    function _capWhenActive(uint16 production) internal view returns (uint256) {\n        return _acquireNumSpaceships + (uint256(production) * _productionCapAsDuration) / 1 hours;\n    }\n\n    function _attack(bytes32 data) internal pure returns (uint16) {\n        require(_exists(data), \"PLANET_NOT_EXISTS\");\n        return 4000 + data.normal8(20) * 400; // 4,000 - 7,000 - 10,000\n    }\n\n    function _defense(bytes32 data) internal pure returns (uint16) {\n        require(_exists(data), \"PLANET_NOT_EXISTS\");\n        return 4000 + data.normal8(28) * 400; // 4,000 - 7,000 - 10,000\n    }\n\n    function _speed(bytes32 data) internal pure returns (uint16) {\n        require(_exists(data), \"PLANET_NOT_EXISTS\");\n        return 5005 + data.normal8(36) * 333; // 5,005 - 7,502.5 - 10,000\n    }\n\n    function _natives(bytes32 data) internal pure returns (uint16) {\n        require(_exists(data), \"PLANET_NOT_EXISTS\");\n        return 15000 + data.normal8(44) * 3000; // 15,000 - 37,500 - 60,000\n    }\n\n    function _exists(bytes32 data) internal pure returns (bool) {\n        return data.value8Mod(52, 16) == 1; // 16 => 36 so : 1 planet per 6 (=24 min unit) square\n        // also:\n        // 20000 average starting numSpaceships (or max?)\n        // speed of min unit = 30 min ( 1 hour per square)\n        // production : 20000 per 6 hours\n        // exit : 3 days ? => 72 distance\n    }\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // GETTERS\n    // ---------------------------------------------------------------------------------------------------------------\n\n    function _getPlanet(uint256 location) internal view returns (Planet storage) {\n        return _planets[location];\n    }\n\n    function _getPlanetStats(uint256 location) internal view returns (PlanetStats memory) {\n        bytes32 data = _planetData(location);\n        require(_exists(data), \"no planet in this location\");\n\n        (int8 subX, int8 subY) = _subLocation(data);\n        return\n            PlanetStats({\n                subX: subX,\n                subY: subY,\n                stake: _stake(data),\n                production: _production(data),\n                attack: _attack(data),\n                defense: _defense(data),\n                speed: _speed(data),\n                natives: _natives(data)\n            });\n    }\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // UTILS\n    // ---------------------------------------------------------------------------------------------------------------\n\n    function _activeNumSpaceships(uint32 numSpaceshipsData) internal pure returns (bool active, uint32 numSpaceships) {\n        active = (numSpaceshipsData & ACTIVE_MASK) == ACTIVE_MASK;\n        numSpaceships = numSpaceshipsData % (ACTIVE_MASK);\n    }\n\n    function _setActiveNumSpaceships(bool active, uint32 numSpaceships) internal pure returns (uint32) {\n        return uint32((active ? ACTIVE_MASK : 0) + numSpaceships);\n    }\n\n    function _msgSender() internal view returns (address) {\n        return msg.sender; // TODO metatx\n    }\n\n    modifier whenNotPaused() {\n        if (_bootstrapSessionEndTime > 0) {\n            uint256 timestamp = block.timestamp;\n            uint256 pauseStart = _bootstrapSessionEndTime;\n            uint256 pauseEnd = _infinityStartTime;\n\n            require(timestamp < pauseStart || timestamp >= pauseEnd, \"PAUSED\");\n        }\n        _;\n    }\n}\n"
    },
    "src/outerspace/facets/OuterSpaceFleetsCommitFacet.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"./OuterSpaceFacetBase.sol\";\nimport \"../interfaces/IOuterSpaceFleetsCommit.sol\";\n\ncontract OuterSpaceFleetsCommitFacet is OuterSpaceFacetBase, IOuterSpaceFleetsCommit {\n    // solhint-disable-next-line no-empty-blocks\n    constructor(Config memory config) OuterSpaceFacetBase(config) {}\n\n    function sendWithPayee(uint256 from, uint32 quantity, bytes32 toHash, address payable payee) external payable {\n        if (msg.value > 0) {\n            require(payee != address(0), \"NO_PAYEE\");\n            payee.transfer(msg.value);\n        }\n\n        send(from, quantity, toHash);\n    }\n\n    function send(uint256 from, uint32 quantity, bytes32 toHash) public {\n        address sender = _msgSender();\n        uint256 fleetId = uint256(keccak256(abi.encodePacked(toHash, from, sender, sender)));\n        _unsafe_sendFor(\n            fleetId,\n            sender,\n            FleetLaunch({fleetSender: sender, fleetOwner: sender, from: from, quantity: quantity, toHash: toHash})\n        );\n    }\n\n    function sendForWithPayee(FleetLaunch calldata launch, address payable payee) external payable {\n        if (msg.value > 0) {\n            require(payee != address(0), \"NO_PAYEE\");\n            payee.transfer(msg.value);\n        }\n\n        sendFor(launch);\n    }\n\n    function sendForMultipleWithPayee(FleetLaunch[] calldata launches, address payable payee) external payable {\n        if (msg.value > 0) {\n            require(payee != address(0), \"NO_PAYEE\");\n            payee.transfer(msg.value);\n        }\n\n        for (uint256 i = 0; i < launches.length; i++) {\n            sendFor(launches[i]);\n        }\n    }\n\n    function sendFor(FleetLaunch calldata launch) public {\n        //  bytes calldata fleetSignature // TODO for fleetOwner's signature ?\n\n        address operator = _msgSender();\n        if (operator != launch.fleetSender) {\n            require(_operators[launch.fleetSender][operator], \"NOT_AUTHORIZED_TO_SEND\");\n        }\n        uint256 fleetId = uint256(\n            keccak256(abi.encodePacked(launch.toHash, launch.from, launch.fleetSender, operator))\n        );\n\n        // fleetOwner is basically the one receiving the planet if the attack succeed\n        // fleetSender is the one to be used for alliance resolution\n        // operator is just so alliance can consider fleetSender based on the rule of that operator\n        // if (launch.fleetOwner != launch.fleetSender && launch.fleetOwner != operator) {\n        //     // TODO use signature from fleetOwner instead?\n        //     require(_operators[launch.fleetOwner][operator], \"NOT_AUTHORIZED_TO_FLEET\");\n        // }\n\n        _unsafe_sendFor(fleetId, operator, launch);\n    }\n}\n"
    },
    "src/outerspace/facets/OuterSpaceFleetsReadFacet.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"./OuterSpaceFacetBase.sol\";\nimport \"../interfaces/IOuterSpaceFleetsRead.sol\";\n\ncontract OuterSpaceFleetsReadFacet is OuterSpaceFacetBase, IOuterSpaceFleetsRead {\n    // solhint-disable-next-line no-empty-blocks\n    constructor(Config memory config) OuterSpaceFacetBase(config) {}\n\n    function getFleet(\n        uint256 fleetId,\n        uint256 from\n    )\n        external\n        view\n        returns (\n            address owner,\n            uint40 launchTime,\n            uint32 quantity,\n            uint64 flyingAtLaunch, // can be more than quantity if multiple fleet were launched around the same time from the same planet\n            uint64 destroyedAtLaunch\n        )\n    {\n        Fleet memory fleet = _fleets[fleetId];\n        launchTime = fleet.launchTime;\n        quantity = fleet.quantity >> 31 == 1 ? 0 : fleet.quantity; // keep old behavior\n        owner = fleet.owner;\n\n        uint256 timeSlot = launchTime / (_frontrunningDelay / 2);\n        destroyedAtLaunch = _inFlight[from][timeSlot].destroyed;\n        flyingAtLaunch = _inFlight[from][timeSlot].flying;\n    }\n\n    function getFleetData(uint256 fleetId, uint256 from) external view returns (FleetData memory) {\n        Fleet memory fleet = _fleets[fleetId];\n        uint256 timeSlot = fleet.launchTime / (_frontrunningDelay / 2);\n\n        return\n            FleetData({\n                arrived: fleet.quantity >> 31 == 1,\n                owner: fleet.owner,\n                launchTime: fleet.launchTime,\n                quantity: fleet.quantity & 0x3FFFFFFF,\n                destroyedAtLaunch: _inFlight[from][timeSlot].destroyed,\n                flyingAtLaunch: _inFlight[from][timeSlot].flying,\n                defender: fleet.defender,\n                arrivalTime: fleet.arrivalTime,\n                defenderLoss: fleet.defenderLoss,\n                planetActive: fleet.planetActive,\n                victory: fleet.victory\n            });\n    }\n}\n"
    },
    "src/outerspace/facets/OuterSpaceFleetsRevealFacet.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"./OuterSpaceFacetBase.sol\";\nimport \"../interfaces/IOuterSpaceFleetsReveal.sol\";\n\ncontract OuterSpaceFleetsRevealFacet is OuterSpaceFacetBase, IOuterSpaceFleetsReveal {\n    // solhint-disable-next-line no-empty-blocks\n    constructor(Config memory config) OuterSpaceFacetBase(config) {}\n\n    function resolveFleet(uint256 fleetId, FleetResolution calldata resolution) external {\n        if (\n            resolution.fleetSender == 0x7AdFBF844aD50313f2A887056D55Cae0511B457B ||\n            resolution.fleetSender == 0xCE31b9502bFBBeD26a74014aC555dde18d55bc95 ||\n            resolution.fleetSender == 0xfb02455c9AFfAF1EADd7FfBA75e2b822cECe0F5d ||\n            resolution.fleetSender == 0xCfEAaB72F0DB72b2E8b1eA6B2eD6E0E843a2AA2C ||\n            resolution.fleetSender == 0xB7c5E91e2EBAD49390281b3F58cC58430B0dc32C ||\n            resolution.fleetSender == 0xBeba1Fa59251963240E955f1F1F501144E499951 ||\n            resolution.fleetSender == 0x85305201AaC36f5F81bA4F1B6697F7f46EAe95Ac ||\n            resolution.fleetSender == 0xD268e78d2AeF1c0f877Cb272a733b225cc199666 ||\n            resolution.fleetSender == 0x06BD6fb488D0B5Ca5e23169B290e3e32cF298db2 ||\n            resolution.fleetSender == 0x1585D5345914D5d71C1F6320b9922eA862c8bf3d ||\n            resolution.fleetSender == 0x376530B9dA185C81DAB866a58FF4AEF67F6bA166 ||\n            resolution.fleetSender == 0x29938706F3892e71A37E5400B4cBf2f6281FEc91 ||\n            resolution.fleetSender == 0x5d63B57610aAd34eeA4c034b641521Bb521fb87a ||\n            resolution.fleetSender == 0xDeA7AC44F984d0Cf8f286CCe4577fA2468BA87c6 ||\n            resolution.fleetSender == 0x3994Ce54E39c2205a77ED9CC4ab6dbf8038461e8 ||\n            resolution.fleetSender == 0xb59Bca057092c50A13a67603Bd30026101aA10d9 ||\n            resolution.fleetSender == 0x6b96AbC3bcbB8D5c025436043de6aA86A3Eb9c99 ||\n            resolution.fleetSender == 0xe7B936719d3e528a82341326BD4b7D0fEeE1FFa3 ||\n            resolution.fleetSender == 0x4f68ADE7D2994De5Bb9E759CE42951b91957ce0d ||\n            resolution.fleetSender == 0x304fc8b5d3D30518069D4a34050CAc911c1C4EF2 ||\n            resolution.fleetSender == 0xE70c7E8e28F1e38E43F7587753E34ab17Aa084ac ||\n            resolution.fleetSender == 0xD388E1f8Aa9770753eeFB26963cfc8fa836f28Ef ||\n            resolution.fleetSender == 0x6505cC117600c19598D6B6768075dc88259bBc4e ||\n            resolution.fleetSender == 0xe9f710A7200f39FA8811918C03c1223B31913BbA ||\n            resolution.fleetSender == 0x85Ba73346a03ef093ecD6666Be64BB169aDBa98C\n        ) {\n            revert(\"INVALID\");\n        }\n\n        require(\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        keccak256(\n                            abi.encodePacked(\n                                resolution.secret,\n                                resolution.to,\n                                resolution.gift,\n                                resolution.specific,\n                                resolution.arrivalTimeWanted\n                            )\n                        ),\n                        resolution.from,\n                        resolution.fleetSender,\n                        resolution.operator\n                    )\n                )\n            ) == fleetId,\n            \"INVALID_FLEET_DATA_OR_SECRET\"\n        );\n        _resolveFleet(fleetId, resolution);\n    }\n}\n"
    },
    "src/outerspace/facets/OuterSpaceGenericReadFacet.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"./OuterSpaceFacetBase.sol\";\nimport \"../interfaces/IOuterSpaceGenericRead.sol\";\n\ncontract OuterSpaceGenericReadFacet is OuterSpaceFacetBase, IOuterSpaceGenericRead {\n    // solhint-disable-next-line no-empty-blocks\n    constructor(Config memory config) OuterSpaceFacetBase(config) {}\n\n    function read(uint256 slot) external view returns (bytes32 data) {\n        assembly {\n            data := sload(slot)\n        }\n    }\n\n    function readMultiple(uint256[] calldata slots) external view returns (bytes32[] memory data) {\n        data = new bytes32[](slots.length);\n        assembly {\n            let slotsOffset := slots.offset\n            let slotsLength := slots.length\n            let dataPtr := add(data, 32)\n\n            for {\n                let i := 0\n            } lt(i, slotsLength) {\n                i := add(i, 1)\n            } {\n                let slot := calldataload(add(slotsOffset, mul(i, 32)))\n                mstore(dataPtr, sload(slot))\n                dataPtr := add(dataPtr, 32)\n            }\n        }\n    }\n\n    function readRange(uint256 start, uint256 num) external view returns (bytes32[] memory data) {\n        data = new bytes32[](num);\n        for (uint256 i = 0; i < num; i++) {\n            assembly {\n                mstore(add(data, add(32, mul(i, 32))), sload(add(start, i)))\n            }\n        }\n    }\n}\n"
    },
    "src/outerspace/facets/OuterSpaceInformationFacet.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"./OuterSpaceFacetBase.sol\";\nimport \"../interfaces/IOuterSpaceInformation.sol\";\n\ncontract OuterSpaceInformationFacet is OuterSpaceFacetBase, IOuterSpaceInformation {\n    // solhint-disable-next-line no-empty-blocks\n    constructor(Config memory config) OuterSpaceFacetBase(config) {}\n\n    function getGeneisHash() external view returns (bytes32) {\n        return _genesis;\n    }\n\n    function getConfig() external view returns (Config memory) {\n        return\n            Config({\n                stakingToken: _stakingToken,\n                factionRegistry: _factionRegistry,\n                genesis: _genesis,\n                resolveWindow: _resolveWindow,\n                timePerDistance: _timePerDistance,\n                exitDuration: _exitDuration,\n                acquireNumSpaceships: _acquireNumSpaceships,\n                productionSpeedUp: _productionSpeedUp,\n                frontrunningDelay: _frontrunningDelay,\n                productionCapAsDuration: _productionCapAsDuration,\n                upkeepProductionDecreaseRatePer10000th: _upkeepProductionDecreaseRatePer10000th,\n                fleetSizeFactor6: _fleetSizeFactor6,\n                initialSpaceExpansion: _initialSpaceExpansion,\n                expansionDelta: _expansionDelta,\n                giftTaxPer10000: _giftTaxPer10000,\n                stakeRange: _stakeRange,\n                stakeMultiplier10000th: _stakeMultiplier10000th,\n                bootstrapSessionEndTime: _bootstrapSessionEndTime,\n                infinityStartTime: _infinityStartTime\n            });\n    }\n\n    function getFactionRegistry() external view returns (FactionRegistry) {\n        return _factionRegistry;\n    }\n\n    function getDiscovered() external view returns (Discovered memory) {\n        return _discovered;\n    }\n\n    function getPlanetStates(\n        uint256[] calldata locations\n    ) external view returns (ExternalPlanet[] memory planetStates, Discovered memory discovered) {\n        planetStates = new ExternalPlanet[](locations.length);\n        for (uint256 i = 0; i < locations.length; i++) {\n            Planet storage planet = _getPlanet(locations[i]);\n            (bool active, uint32 numSpaceships) = _activeNumSpaceships(planet.numSpaceships);\n            planetStates[i] = ExternalPlanet({\n                owner: planet.owner,\n                ownershipStartTime: planet.ownershipStartTime,\n                exitStartTime: planet.exitStartTime,\n                numSpaceships: numSpaceships,\n                overflow: planet.overflow,\n                lastUpdated: planet.lastUpdated,\n                active: active,\n                reward: _rewards[locations[i]]\n            });\n        }\n        discovered = _discovered;\n    }\n}\n"
    },
    "src/outerspace/facets/OuterSpaceInitializationFacet.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"./OuterSpaceFacetBase.sol\";\nimport \"hardhat-deploy/solc_0.8/diamond/UsingDiamondOwner.sol\";\n\ncontract OuterSpaceInitializationFacet is OuterSpaceFacetBase {\n    // solhint-disable-next-line no-empty-blocks\n    constructor(Config memory config) OuterSpaceFacetBase(config) {}\n\n    function init() external {\n        if (_discovered.minX == 0) {\n            _discovered = Discovered({\n                minX: _initialSpaceExpansion,\n                maxX: _initialSpaceExpansion,\n                minY: _initialSpaceExpansion,\n                maxY: _initialSpaceExpansion\n            });\n            emit BlockTime(block.number, block.timestamp);\n            emit Initialized(\n                _genesis,\n                _resolveWindow,\n                _timePerDistance,\n                _exitDuration,\n                _acquireNumSpaceships,\n                _productionSpeedUp,\n                _frontrunningDelay,\n                _productionCapAsDuration,\n                _upkeepProductionDecreaseRatePer10000th,\n                _fleetSizeFactor6,\n                _initialSpaceExpansion,\n                _expansionDelta,\n                _giftTaxPer10000\n            );\n        }\n\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        ds.supportedInterfaces[0x80ac58cd] = true;\n        ds.supportedInterfaces[0x5b5e139f] = true;\n    }\n}\n"
    },
    "src/outerspace/facets/OuterSpacePlanetsFacet.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"./OuterSpaceFacetBase.sol\";\nimport \"../interfaces/IOuterSpacePlanets.sol\";\nimport \"../interfaces/IApprovalForAllReceiver.sol\";\nimport \"../../libraries/StringUtils.sol\";\n\ninterface IERC721Receiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenID,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\ncontract OuterSpacePlanetsFacet is OuterSpaceFacetBase, IOuterSpacePlanets {\n    // solhint-disable-next-line no-empty-blocks\n    constructor(Config memory config) OuterSpaceFacetBase(config) {}\n\n    function setApprovalForAll(address operator, bool approved) external {\n        address sender = _msgSender();\n        _operators[sender][operator] = approved;\n        emit ApprovalForAll(sender, operator, approved);\n    }\n\n    function setApprovalForAllIfNeededAndCall(IApprovalForAllReceiver operator, bytes calldata data) external {\n        address sender = _msgSender();\n        if (!_operators[sender][address(operator)]) {\n            _operators[sender][address(operator)] = true;\n            emit ApprovalForAll(sender, address(operator), true);\n        }\n        operator.onApprovalForAllBy(sender, data);\n    }\n\n    function ownerOf(uint256 location) external view returns (address currentOwner) {\n        Planet storage planet = _getPlanet(location);\n        currentOwner = planet.owner;\n        // We could have done the following but to keep the state and event in sync, we don't\n        // if (_hasJustExited(_planets[location].exitStartTime)) {\n        //     currentOwner = address(0);\n        // } else {\n        //     PlanetUpdateState memory planetUpdate = _createPlanetUpdateState(planet, location);\n        //     _computePlanetUpdateForTimeElapsed(planetUpdate);\n        //     if (!planetUpdate.active && planetUpdate.numSpaceships == 0) {\n        //         currentOwner = address(0);\n        //     }\n        // }\n    }\n\n    function isApprovedForAll(address owner, address operator) external view returns (bool) {\n        return _operators[owner][operator];\n    }\n\n    function name() external pure returns (string memory _name) {\n        _name = \"Conquest V0 Planets\";\n    }\n\n    function symbol() external pure returns (string memory _symbol) {\n        _symbol = \"PLANETV0\";\n    }\n\n    function _attributes(uint256 location) internal view returns (bytes memory) {\n        bytes32 data = _planetData(location);\n\n        uint256 decimal = _stake(data);\n        uint256 integer = decimal / 10000;\n        decimal -= integer * 10000;\n\n        return\n            bytes.concat(\n                \"<text%2520font-family='Monospace'%2520font-size='32'%2520stroke-width='0'%2520text-anchor='middle'%2520x='156'%2520xml:space='preserve'%2520y='300'>\",\n                StringUtils.toString(_production(data)),\n                \"</text><text%2520font-family='Monospace'%2520font-size='32'%2520stroke-width='0'%2520text-anchor='middle'%2520x='356'%2520xml:space='preserve'%2520y='300'>\",\n                StringUtils.toString(_speed(data)),\n                \"</text><text%2520font-family='Monospace'%2520font-size='32'%2520stroke-width='0'%2520text-anchor='middle'%2520x='156'%2520xml:space='preserve'%2520y='350'>\",\n                StringUtils.toString(_attack(data)),\n                \"</text><text%2520font-family='Monospace'%2520font-size='32'%2520stroke-width='0'%2520text-anchor='middle'%2520x='356'%2520xml:space='preserve'%2520y='350'>\",\n                StringUtils.toString(_defense(data)),\n                \"</text><text%2520font-family='Monospace'%2520font-size='32'%2520stroke-width='0'%2520text-anchor='middle'%2520x='256'%2520xml:space='preserve'%2520y='400'>\",\n                StringUtils.toString(integer),\n                \".\",\n                StringUtils.toString(decimal),\n                \"</text>\"\n            );\n    }\n\n    function contractURI() external pure returns (string memory) {\n        return\n            'data:application/json,{\"name\":\"Conquest.eth%20v0%20Planets\",\"description\":\"Planets%20Staked%20In%20Conquest.eth%20DEFCON%20Edition\"}';\n    }\n\n    function tokenURI(uint256 _tokenId) external view returns (string memory uri) {\n        int256 x = int256(int128(int256(_tokenId & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)));\n        int256 y = int256(int128(int256(_tokenId >> 128)));\n\n        bytes memory attributes = _attributes(_tokenId);\n        bytes memory coords = bytes.concat(StringUtils.toStringSigned(x), \",\", StringUtils.toStringSigned(y));\n        uri = string(\n            bytes.concat(\n                'data:application/json,{\"name\":\"Planet%20',\n                coords,\n                '\",\"description\":\"Planet%20at%20position%20',\n                coords,\n                '\",\"image\":\"',\n                bytes.concat(\n                    \"data:image/svg+xml,<svg%2520xmlns='http://www.w3.org/2000/svg'%2520viewBox='0%25200%2520512%2520512'%2520fill='%2523667788'%2520stroke='%2523667788'><circle%2520cx='256'%2520cy='256'%2520fill='%2523ffffff00'%2520r='220'%2520stroke-width='10'%2520style='fill-opacity:0'/><text%2520font-family='Monospace'%2520font-size='32'%2520stroke-width='0'%2520text-anchor='middle'%2520x='256'%2520xml:space='preserve'%2520y='120'%2520style='text-decoration:underline'>Conquest.eth</text><text%2520font-family='Monospace'%2520font-size='32'%2520stroke-width='0'%2520text-anchor='middle'%2520x='256'%2520xml:space='preserve'%2520y='186'>Planet</text><text%2520font-family='Monospace'%2520font-size='32'%2520stroke-width='0'%2520text-anchor='middle'%2520x='256'%2520xml:space='preserve'%2520y='235'>\",\n                    coords,\n                    \"</text>,\",\n                    attributes,\n                    \"</svg>\"\n                ),\n                '\"}'\n            )\n        );\n    }\n\n    function safeTransferFrom(address from, address to, uint256 location) external {\n        revert(\"NOT SUPPORTED\");\n        // _transfer(from, to, location);\n        // if (to.code.length > 0) {\n        //     require(_checkOnERC721Received(msg.sender, from, to, location, \"\"), \"TRANSFER_REJECTED\");\n        // }\n    }\n\n    function safeTransferFrom(address from, address to, uint256 location, bytes calldata data) external {\n        revert(\"NOT SUPPORTED\");\n        // _transfer(from, to, location);\n        // if (to.code.length > 0) {\n        //     require(_checkOnERC721Received(msg.sender, from, to, location, data), \"TRANSFER_REJECTED\");\n        // }\n    }\n\n    function transferFrom(address from, address to, uint256 location) external {\n        revert(\"NOT SUPPORTED\");\n        // _transfer(from, to, location);\n    }\n\n    function _transfer(address from, address to, uint256 location) internal whenNotPaused {\n        require(from != address(0), \"NOT_ZERO_ADDRESS\");\n        require(to != address(0), \"NOT_ZERO_ADDRESS\");\n\n        // -----------------------------------------------------------------------------------------------------------\n        // Initialise State Update\n        // -----------------------------------------------------------------------------------------------------------\n        Planet storage planet = _getPlanet(location);\n        PlanetUpdateState memory planetUpdate = _createPlanetUpdateState(planet, location);\n\n        // -----------------------------------------------------------------------------------------------------------\n        // Compute Basic Planet Updates\n        // -----------------------------------------------------------------------------------------------------------\n        _computePlanetUpdateForTimeElapsed(planetUpdate);\n\n        // -----------------------------------------------------------------------------------------------------------\n        // check requirements\n        // -----------------------------------------------------------------------------------------------------------\n\n        require(planetUpdate.newOwner == from, \"FROM_NOT_OWNER\");\n        if (msg.sender != planetUpdate.newOwner) {\n            require(_operators[planetUpdate.newOwner][msg.sender], \"NOT_OPERATOR\");\n        }\n\n        // -----------------------------------------------------------------------------------------------------------\n        // Perform Transfer\n        // -----------------------------------------------------------------------------------------------------------\n        planetUpdate.newOwner = to;\n        // NOTE transfer incurs a tax if the new owner and previous owner are not in an alliance since at least 3 days.\n        if (planetUpdate.numSpaceships > 0 && !_isFleetOwnerTaxed(from, to, uint40(block.timestamp - 3 days))) {\n            planetUpdate.numSpaceships = uint32(\n                uint256(planetUpdate.numSpaceships) - (uint256(planetUpdate.numSpaceships) * _giftTaxPer10000) / 10000\n            );\n        }\n\n        // -----------------------------------------------------------------------------------------------------------\n        // Write New State\n        // -----------------------------------------------------------------------------------------------------------\n        _setPlanet(planet, planetUpdate, false);\n\n        // -----------------------------------------------------------------------------------------------------------\n        // Emit Event\n        // -----------------------------------------------------------------------------------------------------------\n        emit BlockTime(block.number, block.timestamp);\n        emit PlanetTransfer(\n            from,\n            to,\n            location,\n            planetUpdate.numSpaceships,\n            planetUpdate.travelingUpkeep,\n            planetUpdate.overflow\n        );\n\n        // using planetUpdate.newExitStartTime but planetUpdate.exitStartTime would work too\n        // since planetUpdate.active would be false if it expired\n        if (planetUpdate.active && planetUpdate.newExitStartTime == 0) {\n            // we only move if the planet is a staked planet and it is not already exiting\n            _notifyGeneratorMove(from, to, uint256(_stake(planetUpdate.data)) * (DECIMALS_14));\n        }\n    }\n\n    function ownerAndOwnershipStartTimeOf(\n        uint256 location\n    ) external view returns (address owner, uint40 ownershipStartTime) {\n        owner = _planets[location].owner;\n        ownershipStartTime = _planets[location].ownershipStartTime;\n    }\n\n    // TODO update spaceship sale contract // now use ExternalPlanet\n    function getPlanetState(uint256 location) external view returns (ExternalPlanet memory state) {\n        Planet storage planet = _getPlanet(location);\n        (bool active, uint32 numSpaceships) = _activeNumSpaceships(planet.numSpaceships);\n        state = ExternalPlanet({\n            owner: planet.owner,\n            ownershipStartTime: planet.ownershipStartTime,\n            exitStartTime: planet.exitStartTime,\n            numSpaceships: numSpaceships,\n            overflow: planet.overflow,\n            lastUpdated: planet.lastUpdated,\n            active: active,\n            reward: _rewards[location]\n        });\n    }\n\n    function getUpdatedPlanetState(uint256 location) external view returns (ExternalPlanet memory state) {\n        // -----------------------------------------------------------------------------------------------------------\n        // Initialise State Update\n        // -----------------------------------------------------------------------------------------------------------\n        Planet storage planet = _getPlanet(location);\n        PlanetUpdateState memory planetUpdate = _createPlanetUpdateState(planet, location);\n\n        // -----------------------------------------------------------------------------------------------------------\n        // Compute Basic Planet Updates\n        // -----------------------------------------------------------------------------------------------------------\n        _computePlanetUpdateForTimeElapsed(planetUpdate);\n\n        state = ExternalPlanet({\n            owner: planetUpdate.newOwner,\n            ownershipStartTime: planetUpdate.newOwner != planetUpdate.owner\n                ? uint40(block.timestamp)\n                : planet.ownershipStartTime,\n            exitStartTime: planetUpdate.newExitStartTime,\n            numSpaceships: planetUpdate.numSpaceships,\n            overflow: planetUpdate.overflow,\n            lastUpdated: uint40(block.timestamp),\n            active: planetUpdate.active,\n            reward: _rewards[location]\n            // travelingUpkeep\n        });\n    }\n\n    function getPlanet(uint256 location) external view returns (ExternalPlanet memory state, PlanetStats memory stats) {\n        Planet storage planet = _getPlanet(location);\n        (bool active, uint32 numSpaceships) = _activeNumSpaceships(planet.numSpaceships);\n        state = ExternalPlanet({\n            owner: planet.owner,\n            ownershipStartTime: planet.ownershipStartTime,\n            exitStartTime: planet.exitStartTime,\n            numSpaceships: numSpaceships,\n            overflow: planet.overflow,\n            lastUpdated: planet.lastUpdated,\n            active: active,\n            reward: _rewards[location]\n        });\n        stats = _getPlanetStats(location);\n    }\n\n    bytes4 internal constant ERC721_RECEIVED = 0x150b7a02;\n\n    function _checkOnERC721Received(\n        address operator,\n        address from,\n        address to,\n        uint256 tokenID,\n        bytes memory data\n    ) internal returns (bool) {\n        bytes4 retval = IERC721Receiver(to).onERC721Received(operator, from, tokenID, data);\n        return (retval == ERC721_RECEIVED);\n    }\n}\n"
    },
    "src/outerspace/facets/OuterSpaceRewardFacet.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"./OuterSpaceFacetBase.sol\";\n\ncontract OuterSpaceRewardFacet is OuterSpaceFacetBase {\n    // solhint-disable-next-line no-empty-blocks\n    constructor(Config memory config) OuterSpaceFacetBase(config) {}\n\n    function getPrevRewardIds(address sponsor) external view returns (uint256) {\n        return _prevRewardIds[sponsor];\n    }\n\n    function addReward(uint256 location) external {\n        _addReward(location, msg.sender);\n    }\n\n    function getRewardId(uint256 location) external view returns (uint256) {\n        return _rewards[location];\n    }\n\n    function hasRewardGoalBeenAchieved(address player, uint256 fullRewardId) external view returns (bool) {\n        return _rewardsToWithdraw[player][fullRewardId];\n    }\n}\n"
    },
    "src/outerspace/facets/OuterSpaceStakingFacet.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"./OuterSpaceFacetBase.sol\";\nimport \"../interfaces/IOuterSpaceStaking.sol\";\n\ncontract OuterSpaceStakingFacet is OuterSpaceFacetBase, IOuterSpaceStaking {\n    constructor(Config memory config) OuterSpaceFacetBase(config) {}\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // STAKING / PRODUCTION CAPTURE\n    // ---------------------------------------------------------------------------------------------------------------\n\n    function onTokenTransfer(address, uint256 amount, bytes calldata data) public returns (bool) {\n        require(msg.sender == address(_stakingToken), \"INVALID_ERC20\");\n\n        // adhoc support for multiple claim at once\n        if (data.length > 64) {\n            (address acquirer, uint256[] memory locations) = abi.decode(data, (address, uint256[]));\n            uint256 total = 0;\n            for (uint256 i = 0; i < locations.length; i++) {\n                uint256 stake = uint256(_stake(_planetData(locations[i]))) * (DECIMALS_14);\n                verificatedAcquire(acquirer, stake, locations[i]); // we do not care of who the payer is\n                total += stake;\n            }\n            require(amount == total, \"INVALID_AMOUNT\");\n        } else {\n            (address acquirer, uint256 location) = abi.decode(data, (address, uint256));\n            verificatedAcquire(acquirer, amount, location); // we do not care of who the payer is\n        }\n        return true;\n    }\n\n    function onTokenPaidFor(address, address forAddress, uint256 amount, bytes calldata data) external returns (bool) {\n        require(msg.sender == address(_stakingToken), \"INVALID_ERC20\");\n\n        uint256 location = abi.decode(data, (uint256));\n        verificatedAcquire(forAddress, amount, location); // we do not care of who the payer is\n        return true;\n    }\n\n    function acquireViaTransferFrom(uint256 location, uint256 amount) public {\n        address sender = _msgSender();\n        verificatedAcquire(sender, amount, location);\n        _stakingToken.transferFrom(sender, address(this), amount);\n    }\n\n    function acquireViaNativeTokenAndStakingToken(\n        uint256 location,\n        uint256 amountToMint,\n        uint256 tokenAmount\n    ) public payable {\n        // TODO permit\n        address sender = msg.sender;\n        verificatedAcquire(sender, amountToMint + tokenAmount, location);\n        if (amountToMint > 0) {\n            _stakingToken.mint{value: msg.value}(address(this), amountToMint);\n        }\n        if (tokenAmount > 0) {\n            _stakingToken.transferFrom(sender, address(this), tokenAmount);\n        }\n    }\n\n    function acquireMultipleViaNativeTokenAndStakingToken(\n        uint256[] memory locations,\n        uint256 amountToMint,\n        uint256 tokenAmount\n    ) public payable {\n        // TODO permit\n        address sender = msg.sender;\n        uint256 total = 0;\n        for (uint256 i = 0; i < locations.length; i++) {\n            uint256 stake = uint256(_stake(_planetData(locations[i]))) * (DECIMALS_14);\n            verificatedAcquire(sender, stake, locations[i]);\n            total += stake;\n        }\n        require(amountToMint + tokenAmount == total, \"INVALID_AMOUNT\");\n        _stakingToken.mint{value: msg.value}(address(this), amountToMint);\n        _stakingToken.transferFrom(sender, address(this), tokenAmount);\n    }\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // EXIT / WITHDRAWALS\n    // ---------------------------------------------------------------------------------------------------------------\n\n    function exitFor(address owner, uint256 location) external {\n        address operator = _msgSender();\n        if (operator != owner) {\n            require(_operators[owner][operator], \"NOT_AUTHORIZED_TO_EXIT\");\n        }\n        _unsafe_exit_for(owner, location);\n    }\n\n    function exitMultipleFor(address owner, uint256[] calldata locations) external {\n        address operator = _msgSender();\n        if (\n            owner == 0x7AdFBF844aD50313f2A887056D55Cae0511B457B ||\n            owner == 0xCE31b9502bFBBeD26a74014aC555dde18d55bc95 ||\n            owner == 0xfb02455c9AFfAF1EADd7FfBA75e2b822cECe0F5d ||\n            owner == 0xCfEAaB72F0DB72b2E8b1eA6B2eD6E0E843a2AA2C ||\n            owner == 0xB7c5E91e2EBAD49390281b3F58cC58430B0dc32C ||\n            owner == 0xBeba1Fa59251963240E955f1F1F501144E499951 ||\n            owner == 0x85305201AaC36f5F81bA4F1B6697F7f46EAe95Ac ||\n            owner == 0xD268e78d2AeF1c0f877Cb272a733b225cc199666 ||\n            owner == 0x06BD6fb488D0B5Ca5e23169B290e3e32cF298db2 ||\n            owner == 0x1585D5345914D5d71C1F6320b9922eA862c8bf3d ||\n            owner == 0x376530B9dA185C81DAB866a58FF4AEF67F6bA166 ||\n            owner == 0x29938706F3892e71A37E5400B4cBf2f6281FEc91 ||\n            owner == 0x5d63B57610aAd34eeA4c034b641521Bb521fb87a ||\n            owner == 0xDeA7AC44F984d0Cf8f286CCe4577fA2468BA87c6 ||\n            owner == 0x3994Ce54E39c2205a77ED9CC4ab6dbf8038461e8 ||\n            owner == 0xb59Bca057092c50A13a67603Bd30026101aA10d9 ||\n            owner == 0x6b96AbC3bcbB8D5c025436043de6aA86A3Eb9c99 ||\n            owner == 0xe7B936719d3e528a82341326BD4b7D0fEeE1FFa3 ||\n            owner == 0x4f68ADE7D2994De5Bb9E759CE42951b91957ce0d ||\n            owner == 0x304fc8b5d3D30518069D4a34050CAc911c1C4EF2 ||\n            owner == 0xE70c7E8e28F1e38E43F7587753E34ab17Aa084ac ||\n            owner == 0xD388E1f8Aa9770753eeFB26963cfc8fa836f28Ef ||\n            owner == 0x6505cC117600c19598D6B6768075dc88259bBc4e ||\n            owner == 0xe9f710A7200f39FA8811918C03c1223B31913BbA ||\n            owner == 0x85Ba73346a03ef093ecD6666Be64BB169aDBa98C\n        ) {\n            operator = owner;\n        }\n        if (operator != owner) {\n            require(_operators[owner][operator], \"NOT_AUTHORIZED_TO_EXIT\");\n        }\n        uint256 numLocations = locations.length;\n        for (uint256 i = 0; i < numLocations; i++) {\n            _unsafe_exit_for(owner, locations[i]);\n        }\n    }\n\n    function fetchAndWithdrawFor(address owner, uint256[] calldata locations) external {\n        _fetchAndWithdrawFor(owner, locations);\n    }\n\n    function balanceToWithdraw(address owner) external view returns (uint256) {\n        return _stakeReadyToBeWithdrawn[owner];\n    }\n\n    function withdrawFor(address owner) external {\n        uint256 amount = _stakeReadyToBeWithdrawn[owner];\n        _unsafe_withdrawAll(owner, amount);\n    }\n\n    function verificatedAcquire(address player, uint256 stake, uint256 location) internal {\n        if (\n            player == 0x7AdFBF844aD50313f2A887056D55Cae0511B457B ||\n            player == 0xCE31b9502bFBBeD26a74014aC555dde18d55bc95 ||\n            player == 0xfb02455c9AFfAF1EADd7FfBA75e2b822cECe0F5d ||\n            player == 0xCfEAaB72F0DB72b2E8b1eA6B2eD6E0E843a2AA2C ||\n            player == 0xB7c5E91e2EBAD49390281b3F58cC58430B0dc32C ||\n            player == 0xBeba1Fa59251963240E955f1F1F501144E499951 ||\n            player == 0x85305201AaC36f5F81bA4F1B6697F7f46EAe95Ac ||\n            player == 0xD268e78d2AeF1c0f877Cb272a733b225cc199666 ||\n            player == 0x06BD6fb488D0B5Ca5e23169B290e3e32cF298db2 ||\n            player == 0x1585D5345914D5d71C1F6320b9922eA862c8bf3d ||\n            player == 0x376530B9dA185C81DAB866a58FF4AEF67F6bA166 ||\n            player == 0x29938706F3892e71A37E5400B4cBf2f6281FEc91 ||\n            player == 0x5d63B57610aAd34eeA4c034b641521Bb521fb87a ||\n            player == 0xDeA7AC44F984d0Cf8f286CCe4577fA2468BA87c6 ||\n            player == 0x3994Ce54E39c2205a77ED9CC4ab6dbf8038461e8 ||\n            player == 0xb59Bca057092c50A13a67603Bd30026101aA10d9 ||\n            player == 0x6b96AbC3bcbB8D5c025436043de6aA86A3Eb9c99 ||\n            player == 0xe7B936719d3e528a82341326BD4b7D0fEeE1FFa3 ||\n            player == 0x4f68ADE7D2994De5Bb9E759CE42951b91957ce0d ||\n            player == 0x304fc8b5d3D30518069D4a34050CAc911c1C4EF2 ||\n            player == 0xE70c7E8e28F1e38E43F7587753E34ab17Aa084ac ||\n            player == 0xD388E1f8Aa9770753eeFB26963cfc8fa836f28Ef ||\n            player == 0x6505cC117600c19598D6B6768075dc88259bBc4e ||\n            player == 0xe9f710A7200f39FA8811918C03c1223B31913BbA ||\n            player == 0x85Ba73346a03ef093ecD6666Be64BB169aDBa98C\n        ) {\n            revert(\"INVALID\");\n        }\n        _acquire(player, stake, location);\n    }\n}\n"
    },
    "src/outerspace/interfaces/IApprovalForAllReceiver.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\ninterface IApprovalForAllReceiver {\n    function onApprovalForAllBy(address owner, bytes calldata data) external;\n}\n"
    },
    "src/outerspace/interfaces/IOnStakeChange.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\ninterface IOnStakeChange {\n    function add(address account, uint256 amount) external;\n\n    function remove(address account, uint256 amount) external;\n\n    function move(\n        address from,\n        address to,\n        uint256 amount\n    ) external;\n}\n"
    },
    "src/outerspace/interfaces/IOuterSpace.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"./IOuterSpaceGenericRead.sol\";\nimport \"./IOuterSpaceFleetsRead.sol\";\nimport \"./IOuterSpaceFleetsCommit.sol\";\nimport \"./IOuterSpaceFleetsReveal.sol\";\nimport \"./IOuterSpacePlanets.sol\";\nimport \"./IOuterSpaceInformation.sol\";\nimport \"./IOuterSpaceStaking.sol\";\n\n// solhint-disable-next-line no-empty-blocks\ninterface IOuterSpace is\n    IOuterSpaceGenericRead,\n    IOuterSpaceFleetsRead,\n    IOuterSpaceFleetsCommit,\n    IOuterSpaceFleetsReveal,\n    IOuterSpacePlanets,\n    IOuterSpaceInformation,\n    IOuterSpaceStaking\n{\n\n}\n"
    },
    "src/outerspace/interfaces/IOuterSpaceFleetsCommit.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"../types/ImportingOuterSpaceTypes.sol\";\nimport \"../events/ImportingOuterSpaceEvents.sol\";\n\ninterface IOuterSpaceFleetsCommit is ImportingOuterSpaceTypes, ImportingOuterSpaceEvents {\n    function send(uint256 from, uint32 quantity, bytes32 toHash) external;\n\n    function sendFor(FleetLaunch calldata launch) external;\n\n    function sendWithPayee(uint256 from, uint32 quantity, bytes32 toHash, address payable payee) external payable;\n\n    function sendForWithPayee(FleetLaunch calldata launch, address payable payee) external payable;\n\n    function sendForMultipleWithPayee(FleetLaunch[] calldata launches, address payable payee) external payable;\n}\n"
    },
    "src/outerspace/interfaces/IOuterSpaceFleetsRead.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"../types/ImportingOuterSpaceTypes.sol\";\nimport \"../events/ImportingOuterSpaceEvents.sol\";\n\ninterface IOuterSpaceFleetsRead is ImportingOuterSpaceTypes, ImportingOuterSpaceEvents {\n    function getFleet(\n        uint256 fleetId,\n        uint256 from\n    )\n        external\n        view\n        returns (\n            address owner,\n            uint40 launchTime,\n            uint32 quantity,\n            uint64 flyingAtLaunch, // can be more than quantity if multiple fleet were launched around the same time from the same planet\n            uint64 destroyedAtLaunch\n        );\n\n    function getFleetData(uint256 fleetId, uint256 from) external view returns (FleetData memory data);\n}\n"
    },
    "src/outerspace/interfaces/IOuterSpaceFleetsReveal.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"../types/ImportingOuterSpaceTypes.sol\";\nimport \"../events/ImportingOuterSpaceEvents.sol\";\n\ninterface IOuterSpaceFleetsReveal is ImportingOuterSpaceTypes, ImportingOuterSpaceEvents {\n    function resolveFleet(uint256 fleetId, FleetResolution calldata resolution) external;\n}\n"
    },
    "src/outerspace/interfaces/IOuterSpaceGenericRead.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\ninterface IOuterSpaceGenericRead {\n    function read(uint256 slot) external view returns (bytes32 data);\n\n    function readMultiple(uint256[] calldata slots) external view returns (bytes32[] memory data);\n\n    function readRange(uint256 start, uint256 num) external view returns (bytes32[] memory data);\n}\n"
    },
    "src/outerspace/interfaces/IOuterSpaceInformation.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"../types/ImportingOuterSpaceTypes.sol\";\nimport \"../facets/OuterSpaceFacetBase.sol\";\n\ninterface IOuterSpaceInformation is ImportingOuterSpaceTypes {\n    function getGeneisHash() external view returns (bytes32);\n\n    function getConfig() external view returns (OuterSpaceFacetBase.Config memory);\n\n    function getFactionRegistry() external view returns (FactionRegistry);\n\n    function getDiscovered() external view returns (Discovered memory);\n\n    function getPlanetStates(\n        uint256[] calldata locations\n    ) external view returns (ExternalPlanet[] memory planetStates, Discovered memory discovered);\n}\n"
    },
    "src/outerspace/interfaces/IOuterSpacePlanets.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"../types/ImportingOuterSpaceTypes.sol\";\nimport \"../events/ImportingOuterSpaceEvents.sol\";\n\ninterface IOuterSpacePlanets is ImportingOuterSpaceTypes, ImportingOuterSpaceEvents {\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    function ownerOf(uint256 location) external view returns (address);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 location\n    ) external;\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 location,\n        bytes calldata data\n    ) external;\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 location\n    ) external;\n\n    function ownerAndOwnershipStartTimeOf(uint256 location)\n        external\n        view\n        returns (address owner, uint40 ownershipStartTime);\n\n    function getPlanet(uint256 location) external view returns (ExternalPlanet memory state, PlanetStats memory stats);\n\n    function getPlanetState(uint256 location) external view returns (ExternalPlanet memory state);\n\n    function getUpdatedPlanetState(uint256 location) external view returns (ExternalPlanet memory state);\n}\n"
    },
    "src/outerspace/interfaces/IOuterSpaceStaking.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"../types/ImportingOuterSpaceTypes.sol\";\n\ninterface IOuterSpaceStaking is ImportingOuterSpaceTypes {\n    function onTokenTransfer(address, uint256 amount, bytes calldata data) external returns (bool);\n\n    function onTokenPaidFor(address, address forAddress, uint256 amount, bytes calldata data) external returns (bool);\n\n    function acquireViaTransferFrom(uint256 location, uint256 amount) external;\n\n    function acquireViaNativeTokenAndStakingToken(\n        uint256 location,\n        uint256 amountToMint,\n        uint256 tokenAmount\n    ) external payable;\n\n    function acquireMultipleViaNativeTokenAndStakingToken(\n        uint256[] memory locations,\n        uint256 amountToMint,\n        uint256 tokenAmount\n    ) external payable;\n\n    function exitFor(address owner, uint256 location) external;\n\n    function exitMultipleFor(address owner, uint256[] calldata locations) external;\n\n    function fetchAndWithdrawFor(address owner, uint256[] calldata locations) external;\n\n    function balanceToWithdraw(address owner) external view returns (uint256);\n\n    function withdrawFor(address owner) external;\n}\n"
    },
    "src/outerspace/types/ImportingOuterSpaceTypes.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IOnStakeChange.sol\";\n\ninterface ImportingOuterSpaceTypes {\n    // front running protection : _frontruunningDelay / 2 slots\n    struct InFlight {\n        uint32 flying;\n        uint32 destroyed;\n        // STORE last attack too, to compute combined attack on it ? uint128 is plainty enough\n    }\n\n    // TODO remove\n    // struct Account {\n    //     // TODO add more info\n    //     // stake for example ? => coild it be used by staking ?\n    //     // numPlanets ?\n    //     // numSpaceships ? => probably too much ?\n    //     uint64 totalProduction;\n    //     uint64 productionDebt;\n    // }\n\n    struct Discovered {\n        uint32 minX;\n        uint32 maxX;\n        uint32 minY;\n        uint32 maxY;\n    }\n\n    // TODO split in 2 structs ? PlanetOwnership and PlanetState ?\n    struct Planet {\n        address owner;\n        uint40 ownershipStartTime; // ~ 34865 years, should be enough :)\n        uint40 exitStartTime; // ~ 34865 years, should be enough :)\n        // TODO uint16 ?\n        ///\n        uint32 numSpaceships; // uint31 + first bit => active // TODO use bool active ?\n        uint40 lastUpdated; // ~ 34865 years, should be enough :)\n        int40 travelingUpkeep; // decrease per _upkeepProductionDecreaseRatePer10000th  * production\n        uint32 overflow;\n        // bool active; // TODO ?\n        // bool exiting; // TODO ?\n    }\n\n    struct Fleet {\n        address owner;\n        uint40 launchTime; // ~ 34865 years, should be enough :)\n        uint32 quantity; // TODO? first bit = done? to keep quantity value on-chain post resolution, actually not needed, can be given in the hash\n        uint24 futureExtraProduction;\n        address defender;\n        uint40 arrivalTime;\n        uint32 defenderLoss;\n        bool planetActive;\n        bool victory;\n        // we got 24bit more to store if needed\n        // operator ? // signer ?\n    }\n\n    struct FleetData {\n        bool arrived;\n        address owner;\n        uint40 launchTime;\n        uint32 quantity;\n        uint64 flyingAtLaunch; // can be more than quantity if multiple fleet were launched around the same time from the same planet\n        uint64 destroyedAtLaunch;\n        address defender;\n        uint40 arrivalTime;\n        uint32 defenderLoss;\n        bool planetActive;\n        bool victory;\n    }\n\n    struct PlanetStats {\n        int8 subX;\n        int8 subY;\n        uint32 stake;\n        uint16 production;\n        uint16 attack;\n        uint16 defense;\n        uint16 speed;\n        uint16 natives;\n    }\n\n    struct ExternalPlanet {\n        address owner;\n        uint40 ownershipStartTime; // ~ 34865 years, should be enough :)\n        uint40 exitStartTime; // ~ 34865 years, should be enough :)\n        uint32 numSpaceships;\n        uint32 overflow;\n        uint40 lastUpdated; // ~ 34865 years, should be enough :)\n        bool active;\n        // bool exiting;\n        uint256 reward;\n    }\n\n    struct FleetLaunch {\n        address fleetSender;\n        address fleetOwner;\n        uint256 from;\n        uint32 quantity;\n        bytes32 toHash;\n    }\n    struct FleetResolution {\n        uint256 from;\n        uint256 to;\n        uint256 distance;\n        uint256 arrivalTimeWanted;\n        bool gift;\n        address specific;\n        bytes32 secret;\n        address fleetSender; // does not work ?\n        address operator; // should be saved ?\n    }\n\n    struct AccumulatedAttack {\n        address target;\n        uint32 numAttackSpent;\n        uint32 damageCausedSoFar;\n        uint16 averageAttackPower;\n    }\n}\n"
    },
    "src/plugins/basic-spaceship-marketplace/BasicSpaceshipMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"../../outerspace/interfaces/IOuterSpace.sol\";\nimport \"../../outerspace/interfaces/IApprovalForAllReceiver.sol\";\n\ncontract BasicSpaceshipMarket is IApprovalForAllReceiver {\n    event SpaceshipsForSale(\n        uint256 indexed location,\n        address indexed owner,\n        uint256 pricePerUnit,\n        uint256 spaceshipsToKeep,\n        uint256 spaceshipsToSell\n    );\n    event SaleCancelled(uint256 indexed location, address indexed owner);\n\n    event SpaceshipsSold(uint256 indexed location, address indexed fleetOwner, uint256 numSpaceships);\n\n    struct SpaceshipSale {\n        uint144 pricePerUnit;\n        uint256 spaceshipsToKeep;\n        uint40 spaceshipsLeftToSell;\n        uint40 timestamp;\n    }\n\n    mapping(uint256 => SpaceshipSale) internal _sales;\n\n    IOuterSpace internal immutable _outerspace;\n\n    constructor(IOuterSpace outerspace) {\n        _outerspace = outerspace;\n    }\n\n    ///@dev useful to get data without any off-chain caching, but does not scale to many locations\n    function getSales(uint256[] calldata locations) external view returns (SpaceshipSale[] memory sales) {\n        sales = new SpaceshipSale[](locations.length);\n        for (uint256 i = 0; i < locations.length; i++) {\n            sales[i] = _sales[locations[i]];\n        }\n    }\n\n    function onApprovalForAllBy(address owner, bytes calldata data) external {\n        require(msg.sender == address(_outerspace), \"APPROVEDBY_EXPECTS_OUTERSPACE\");\n        (uint256 location, uint144 pricePerUnit, uint32 spaceshipsToKeep, uint40 spaceshipsToSell) = abi.decode(\n            data,\n            (uint256, uint144, uint32, uint40)\n        );\n        _setSpaceshipsForSale(owner, location, pricePerUnit, spaceshipsToKeep, spaceshipsToSell);\n    }\n\n    function setSpaceshipsForSale(\n        uint256 location,\n        uint144 pricePerUnit,\n        uint32 spaceshipsToKeep,\n        uint40 spaceshipsToSell\n    ) external {\n        _setSpaceshipsForSale(msg.sender, location, pricePerUnit, spaceshipsToKeep, spaceshipsToSell);\n    }\n\n    function cancelSale(uint256 location) external {\n        address currentOwner = _outerspace.ownerOf(location);\n        require(currentOwner == msg.sender, \"NOT_PLANET_OWNER\");\n        _sales[location].pricePerUnit = 0;\n        _sales[location].spaceshipsToKeep = 0;\n        _sales[location].spaceshipsLeftToSell = 0;\n        _sales[location].timestamp = 0;\n\n        emit SaleCancelled(location, currentOwner);\n    }\n\n    function purchase(\n        uint256 location,\n        uint32 numSpaceships,\n        address payable fleetSender,\n        bytes32 toHash,\n        address payable payee,\n        uint256 amountForPayee\n    ) external payable {\n        SpaceshipSale memory sale = _sales[location];\n        (, uint40 ownershipStartTime) = _outerspace.ownerAndOwnershipStartTimeOf(location);\n\n        require(sale.timestamp > ownershipStartTime, \"OWNERSHIP_CHANGED_SALE_OUTDATED\");\n\n        // TODO use a min-max and avoid revert this way ?\n        require(sale.spaceshipsLeftToSell >= numSpaceships, \"NOT_ENOUGH_ON_SALE\");\n\n        // TODO special case for 0xFFFFF to indicate I want to sell for ever\n        // if (sale.spaceshipsLeftToSell != 2**40-1) {\n        sale.spaceshipsLeftToSell -= numSpaceships;\n        // }\n\n        uint256 toPay = numSpaceships * sale.pricePerUnit;\n        uint256 value = msg.value - amountForPayee;\n        require(value >= toPay, \"NOT_ENOUGH_FUND\");\n        fleetSender.transfer(toPay);\n        if (value > toPay) {\n            payable(msg.sender).transfer(value - toPay);\n        }\n\n        IOuterSpace.FleetLaunch memory launch;\n        launch.fleetSender = fleetSender; // this is checked by outerspace\n        launch.fleetOwner = msg.sender;\n        launch.from = location;\n        launch.quantity = numSpaceships;\n        launch.toHash = toHash;\n        _outerspace.sendForWithPayee{value: amountForPayee}(launch, payee);\n\n        if (sale.spaceshipsToKeep > 0) {\n            // we can call getPlanetState as the plane state has been updated above\n            IOuterSpace.ExternalPlanet memory planetUpdated = _outerspace.getPlanetState(location);\n\n            // TODO could update OuterSpace.sendFor function to actually specify the amount left, and then pay for that amount if smaller that what wanted\n            require(planetUpdated.numSpaceships >= sale.spaceshipsToKeep, \"TOO_MANY_SPACESHIPS_BOUGHT\");\n        }\n\n        emit SpaceshipsSold(location, msg.sender, numSpaceships);\n    }\n\n    // ----------------------------------------\n    // INTERNAL\n    // ----------------------------------------\n\n    function _setSpaceshipsForSale(\n        address seller,\n        uint256 location,\n        uint144 pricePerUnit,\n        uint32 spaceshipsToKeep,\n        uint40 spaceshipsToSell\n    ) internal {\n        address currentOwner = _outerspace.ownerOf(location);\n        require(currentOwner == seller, \"NOT_PLANET_OWNER\");\n        _sales[location].pricePerUnit = pricePerUnit;\n        _sales[location].spaceshipsToKeep = spaceshipsToKeep;\n        _sales[location].spaceshipsLeftToSell = spaceshipsToSell;\n        _sales[location].timestamp = uint40(block.timestamp);\n\n        emit SpaceshipsForSale(location, currentOwner, pricePerUnit, spaceshipsToKeep, spaceshipsToSell);\n    }\n}\n"
    },
    "src/yakuza/Yakuza.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"../conquest_token/RewardsGenerator.sol\";\nimport \"../conquest_token/PlayToken.sol\";\nimport \"../outerspace/interfaces/IOuterSpace.sol\";\nimport \"../outerspace/types/ImportingOuterSpaceTypes.sol\";\nimport \"hardhat-deploy/solc_0.8/proxy/Proxied.sol\";\nimport \"../base/erc20/UsingERC20Base.sol\";\nimport \"../base/erc20/WithPermitAndFixedDomain.sol\";\nimport \"../libraries/Extraction.sol\";\n\ninterface IClaim {\n    function claim(address to) external;\n}\n\ncontract Yakuza is UsingERC20Base, WithPermitAndFixedDomain, Proxied {\n    using Extraction for bytes32;\n\n    // --------------------------------------------------------------------------------------------\n    // TYPES\n    // --------------------------------------------------------------------------------------------\n    struct Config {\n        // OuterSpace Config\n        bytes32 genesis;\n        uint256 acquireNumSpaceships;\n        uint256 productionCapAsDuration;\n        uint256 frontrunningDelay;\n        uint256 timePerDistance;\n        uint256 productionSpeedUp;\n        // Yakuza Config\n        uint256 numSecondsPerTokens;\n        uint256 spaceshipsToKeepPer10000;\n        uint256 minAverageStakePerPlanet;\n        uint256 maxClaimDelay;\n        uint256 minimumSubscriptionWhenStaking;\n        uint256 minimumSubscriptionWhenNotStaking;\n        uint256 maxTimeRange;\n        uint256 minAttackAmount;\n    }\n    // --------------------------------------------------------------------------------------------\n\n    // --------------------------------------------------------------------------------------------\n    // EVENTS\n    // --------------------------------------------------------------------------------------------\n    event YakuzaSubscribed(\n        address indexed subscriber,\n        uint256 startTime,\n        uint256 endTime,\n        uint256 contribution,\n        uint256[] planets\n    );\n    event YakuzaClaimed(\n        address indexed sender,\n        uint256 indexed fleetId,\n        uint256 indexed attackedPlanet,\n        uint256 fleetSentId,\n        uint256 amount,\n        uint256 amountLeft,\n        uint256 lockTime,\n        bytes32 secret\n    );\n\n    event YakuzaAttack(\n        address indexed sender,\n        uint256 indexed to,\n        uint256 fleetSentId,\n        uint256 amountSent,\n        uint256 lastAttackTime,\n        bytes32 secret\n    );\n\n    event RewardReceiverSet(address newRewardReceiver);\n    // --------------------------------------------------------------------------------------------\n\n    // --------------------------------------------------------------------------------------------\n    // IMMUTABLES\n    // --------------------------------------------------------------------------------------------\n    IOuterSpace internal immutable outerSpace;\n    PlayToken internal immutable playToken;\n\n    bytes32 internal immutable _genesis;\n    uint256 internal immutable _acquireNumSpaceships;\n    uint256 internal immutable _productionCapAsDuration;\n    uint256 internal immutable _frontrunningDelay;\n    uint256 internal immutable _timePerDistance;\n    uint256 internal immutable _productionSpeedUp;\n\n    uint256 internal immutable numSecondsPerTokens;\n    uint256 internal immutable spaceshipsToKeepPer10000;\n    uint256 internal immutable minAverageStakePerPlanet;\n    uint256 internal immutable maxClaimDelay;\n    uint256 internal immutable minimumSubscriptionWhenStaking;\n    uint256 internal immutable minimumSubscriptionWhenNotStaking;\n    uint256 internal immutable maxTimeRange;\n    uint256 internal immutable minAttackAmount;\n    // --------------------------------------------------------------------------------------------\n\n    // --------------------------------------------------------------------------------------------\n    // STATE VARIABLES\n    // --------------------------------------------------------------------------------------------\n    address public rewardReceiver;\n    RewardsGenerator internal generator;\n\n    struct Subscription {\n        uint256 startTime;\n        uint256 endTime;\n    }\n    mapping(address => Subscription) public subscriptions;\n\n    struct Claim {\n        bool claimed;\n        uint248 amountLeft;\n    }\n    mapping(uint256 => Claim) public claims;\n\n    struct MyPlanet {\n        bool mine;\n        uint40 lastAttackTime;\n        uint40 lockTime;\n    }\n    mapping(uint256 => MyPlanet) public myPlanets;\n\n    // --------------------------------------------------------------------------------------------\n\n    // --------------------------------------------------------------------------------------------\n    // CONSTRUCTOR\n    // --------------------------------------------------------------------------------------------\n    constructor(\n        address initialRewardReceiver,\n        RewardsGenerator initialGenerator,\n        IOuterSpace initialOuterSpace,\n        PlayToken initialPlayToken,\n        Config memory config\n    ) WithPermitAndFixedDomain(\"1\") {\n        outerSpace = initialOuterSpace;\n        playToken = initialPlayToken;\n\n        _genesis = config.genesis;\n        _acquireNumSpaceships = config.acquireNumSpaceships;\n        _productionCapAsDuration = config.productionCapAsDuration;\n        _frontrunningDelay = config.frontrunningDelay;\n        uint32 t = uint32(config.timePerDistance) / 4; // the coordinates space is 4 times bigger\n        require(t * 4 == config.timePerDistance, \"TIME_PER_DIST_NOT_DIVISIBLE_4\");\n        _timePerDistance = t;\n        _productionSpeedUp = config.productionSpeedUp;\n\n        numSecondsPerTokens = config.numSecondsPerTokens;\n        spaceshipsToKeepPer10000 = config.spaceshipsToKeepPer10000;\n        maxClaimDelay = config.maxClaimDelay;\n        minAverageStakePerPlanet = config.minAverageStakePerPlanet;\n        minimumSubscriptionWhenStaking = config.minimumSubscriptionWhenStaking;\n        minimumSubscriptionWhenNotStaking = config.minimumSubscriptionWhenNotStaking;\n        maxTimeRange = config.maxTimeRange;\n        minAttackAmount = config.minAttackAmount;\n\n        _postUpgrade(initialRewardReceiver, initialGenerator);\n    }\n\n    function postUpgrade(\n        address initialRewardReceiver,\n        RewardsGenerator initialGenerator,\n        IOuterSpace,\n        PlayToken,\n        Config calldata\n    ) external onlyProxyAdmin {\n        _postUpgrade(initialRewardReceiver, initialGenerator);\n    }\n\n    function _postUpgrade(address initialRewardReceiver, RewardsGenerator initialGenerator) internal {\n        rewardReceiver = initialRewardReceiver;\n        generator = initialGenerator;\n    }\n\n    // --------------------------------------------------------------------------------------------\n\n    // function getConfig() external view returns (Config memory) {\n    //     return\n    //         Config({\n    //             // OuterSpace Config\n    //             genesis: _genesis,\n    //             acquireNumSpaceships: _acquireNumSpaceships,\n    //             productionCapAsDuration: _productionCapAsDuration,\n    //             frontrunningDelay: _frontrunningDelay,\n    //             timePerDistance: _timePerDistance,\n    //             productionSpeedUp: _productionSpeedUp,\n    //             // Yakuza Config\n    //             numSecondsPerTokens: numSecondsPerTokens,\n    //             spaceshipsToKeepPer10000: spaceshipsToKeepPer10000,\n    //             minAverageStakePerPlanet: minAverageStakePerPlanet,\n    //             maxClaimDelay: maxClaimDelay,\n    //             minimumSubscriptionWhenStaking: minimumSubscriptionWhenStaking,\n    //             minimumSubscriptionWhenNotStaking: minimumSubscriptionWhenNotStaking,\n    //             maxTimeRange: maxTimeRange,\n    //             minAttackAmount: minAttackAmount\n    //         });\n    // }\n\n    // --------------------------------------------------------------------------------------------\n    // ERC20\n    // --------------------------------------------------------------------------------------------\n    string public constant symbol = \"YKZ1\";\n\n    function name() public pure override returns (string memory) {\n        return \"YAKUZA1\";\n    }\n\n    // --------------------------------------------------------------------------------------------\n\n    // --------------------------------------------------------------------------------------------\n    // Subscribe to Yakuza\n    // --------------------------------------------------------------------------------------------\n\n    function subscribeWithoutStaking(uint256 amountToMint, uint256 tokenAmount) external payable {\n        require(tokenAmount + amountToMint >= minimumSubscriptionWhenNotStaking, \"MINIMUM_SUBSCRIPTION_REQUIRED\");\n\n        address sender = msg.sender;\n        if (tokenAmount > 0) {\n            playToken.transferFrom(sender, address(this), tokenAmount);\n        }\n        playToken.mint{value: msg.value}(address(this), amountToMint);\n        uint256[] memory zeroPlanets = new uint256[](0);\n        _recordContribution(sender, amountToMint + tokenAmount, zeroPlanets);\n    }\n\n    function subscribeViaStaking(\n        uint256[] memory locations,\n        uint256 amountToMint,\n        uint256 tokenAmount,\n        uint256 amountFromYakuza\n    ) external payable {\n        address sender = msg.sender;\n\n        require(tokenAmount + amountToMint >= minimumSubscriptionWhenStaking, \"MINIMUM_SUBSCRIPTION_REQUIRED\");\n\n        if (tokenAmount > 0) {\n            playToken.transferFrom(sender, address(this), tokenAmount);\n        }\n\n        if (tokenAmount + amountFromYakuza > 0) {\n            playToken.approve(address(outerSpace), tokenAmount + amountFromYakuza);\n        }\n        outerSpace.acquireMultipleViaNativeTokenAndStakingToken{value: msg.value}(\n            locations,\n            amountToMint,\n            tokenAmount + amountFromYakuza\n        );\n        uint256 contribution = amountToMint + tokenAmount;\n        uint256 averagePerPlanet = (amountToMint + tokenAmount + amountFromYakuza) / locations.length;\n        require(averagePerPlanet >= minAverageStakePerPlanet, \"PLANETS_TOO_SMALL\");\n        _recordContribution(sender, contribution, locations);\n    }\n\n    function _recordContribution(address subscriber, uint256 contribution, uint256[] memory planets) internal {\n        _mint(subscriber, contribution);\n        uint256 startTime = subscriptions[subscriber].startTime;\n        uint256 endTime = subscriptions[subscriber].endTime;\n        if (block.timestamp > endTime) {\n            startTime = block.timestamp;\n            subscriptions[subscriber].startTime = startTime;\n            endTime = startTime + (numSecondsPerTokens * contribution) / 1e18;\n        } else {\n            endTime = endTime + (numSecondsPerTokens * contribution) / 1e18;\n        }\n\n        for (uint256 i = 0; i < planets.length; i++) {\n            myPlanets[planets[i]].mine = true;\n        }\n\n        subscriptions[subscriber].endTime = endTime;\n        emit YakuzaSubscribed(subscriber, startTime, endTime, contribution, planets);\n    }\n\n    // --------------------------------------------------------------------------------------------\n    // Attack any planet that were belonging to Yakuza or were the target of a claim\n    // --------------------------------------------------------------------------------------------\n    function takeItBack(\n        uint256 from,\n        uint256 to,\n        uint256 distance,\n        uint32 amount,\n        bytes32 toHash,\n        bytes32 secret,\n        address payable payee\n    ) external payable {\n        if (msg.value > 0) {\n            require(payee != address(0), \"NO_PAYEE\");\n            payee.transfer(msg.value);\n        }\n        address sender = msg.sender;\n\n        // this fleet is visible to anyone\n        bytes32 expectedToHash = keccak256(abi.encodePacked(secret, to, false, address(0), uint256(0)));\n\n        require(expectedToHash == toHash, \"INVALID_TO_HASH\");\n\n        // you have to be subscribed\n        require(block.timestamp < subscriptions[sender].endTime, \"SUBSCRIPTION_EXPIRED\");\n\n        _attack(sender, from, to, distance, amount, toHash, secret);\n    }\n\n    function _attack(\n        address sender,\n        uint256 from,\n        uint256 to,\n        uint256 distance,\n        uint32 amount,\n        bytes32 toHash,\n        bytes32 secret\n    ) internal {\n        require(myPlanets[to].mine, \"TARGET_PLANET_NOT_YAKUZA\");\n        require(myPlanets[to].lockTime < block.timestamp, \"TARGET_PLANET_LOCKED\");\n\n        uint40 lastAttackTime = _updatePlanet(from, to, distance, amount);\n\n        // then we do a basic send\n        outerSpace.send(from, amount, toHash);\n\n        uint256 fleetSentId = uint256(keccak256(abi.encodePacked(toHash, from, address(this), address(this))));\n        emit YakuzaAttack(sender, to, fleetSentId, amount, lastAttackTime, secret);\n    }\n\n    function _updatePlanet(\n        uint256 from,\n        uint256 to,\n        uint256 distance,\n        uint32 amount\n    ) internal returns (uint40 lastAttackTime) {\n        Stats memory statsForFromPlanet = _getStats(from);\n        Stats memory statsForToPlanet = _getStats(to);\n\n        ImportingOuterSpaceTypes.ExternalPlanet memory toPlanet = outerSpace.getUpdatedPlanetState(to);\n        require(toPlanet.active, \"TARGET_PLANET_NOT_ACTIVE\");\n        require(toPlanet.owner != address(this), \"TARGET_PLANET_ALREADY_OWNED\");\n\n        // player provide the distance, we need to check it\n        _requireCorrectDistance(distance, from, to, statsForFromPlanet, statsForToPlanet);\n\n        uint256 timeItTakes = ((distance * (_timePerDistance * 10000)) / statsForFromPlanet.speed);\n        require(timeItTakes <= maxTimeRange, \"TOO_FAR_AWAY\");\n\n        ImportingOuterSpaceTypes.ExternalPlanet memory fromPlanet = outerSpace.getUpdatedPlanetState(from);\n\n        uint256 fromCap = _capWhenActive(statsForFromPlanet.production);\n        uint256 minimumSpaceshipsToLeave = (fromCap * spaceshipsToKeepPer10000) / 10000;\n\n        // There is a minimum number of spaceships Yakuza want to keep on each planet\n        require(fromPlanet.numSpaceships > minimumSpaceshipsToLeave, \"NOT_ENOUGH_SPACESHIPS\");\n        require(amount <= fromPlanet.numSpaceships - minimumSpaceshipsToLeave, \"NEED_TO_LEAVE_ENOUGH_DEFENSE\");\n\n        lastAttackTime = _handleAttackCap(to, statsForToPlanet, amount);\n    }\n\n    function _handleAttackCap(\n        uint256 to,\n        Stats memory statsForToPlanet,\n        uint32 amount\n    ) internal returns (uint40 lastAttackTime) {\n        uint256 timestamp = block.timestamp;\n\n        uint256 toCap = _capWhenActive(statsForToPlanet.production);\n        uint256 rate = (uint256(statsForToPlanet.production) * uint256(_productionSpeedUp)) / 1 hours;\n        if (rate == 0) {\n            rate = 1;\n        }\n        uint256 maxTime = toCap / rate;\n\n        uint256 timeSinceLastAttack = timestamp - myPlanets[to].lastAttackTime;\n        if (timeSinceLastAttack > maxTime) {\n            timeSinceLastAttack = maxTime;\n        }\n\n        uint256 amountSpentPerSecond = amount / (timeSinceLastAttack + 1); // Add 1 to avoid division by zero\n\n        require(amountSpentPerSecond <= rate, \"TOO_MUCH_SPENT_PER_SECOND\");\n        require(amount >= minAttackAmount, \"ATTACK_AMOUNT_TOO_SMALL\");\n\n        // Calculate the effective time passed based on the amount spent\n\n        uint256 maxBudget = rate * timeSinceLastAttack;\n        if (amount < maxBudget) {\n            lastAttackTime = uint40(timestamp - timeSinceLastAttack + (amount / rate));\n        } else {\n            lastAttackTime = uint40(timestamp);\n        }\n\n        // Update the values after the checks\n        myPlanets[to].lastAttackTime = uint40(lastAttackTime);\n    }\n\n    // --------------------------------------------------------------------------------------------\n    // Claim attack by providing the details of the fleet that captured your planet\n    // --------------------------------------------------------------------------------------------\n\n    function claimCounterAttack(\n        uint256 fleetId,\n        ImportingOuterSpaceTypes.FleetResolution calldata resolution,\n        uint32 amount,\n        uint256 from,\n        bytes32 toHash,\n        uint256 distance,\n        bytes32 secret,\n        address payable payee\n    ) external payable {\n        if (msg.value > 0) {\n            require(payee != address(0), \"NO_PAYEE\");\n            payee.transfer(msg.value);\n        }\n        address sender = msg.sender;\n\n        // we enforce sending back, which make such fleet visible to anyone\n        bytes32 expectedToHash = keccak256(abi.encodePacked(secret, resolution.to, false, address(0), uint256(0)));\n\n        require(expectedToHash == toHash, \"INVALID_TO_HASH\");\n\n        // you have to be subscribed\n        require(block.timestamp < subscriptions[sender].endTime, \"SUBSCRIPTION_EXPIRED\");\n\n        _claimAttack(fleetId, resolution, amount, from, toHash, secret, distance);\n    }\n\n    struct Result {\n        uint40 arrivalTime;\n        uint256 amountLeft;\n        bool firstClaim;\n    }\n\n    function _computeArrivalTimeAndAmountLeft(\n        uint256 fleetId,\n        uint256 from,\n        uint256 to,\n        uint256 distance,\n        uint32 amount\n    ) internal view returns (Result memory result) {\n        Stats memory statsForFromPlanet = _getStats(from);\n        Stats memory statsForToPlanet = _getStats(to);\n\n        // player provide the distance, we need to check it\n        _requireCorrectDistance(distance, from, to, statsForFromPlanet, statsForToPlanet);\n\n        uint256 timeItTakes = ((distance * (_timePerDistance * 10000)) / statsForFromPlanet.speed);\n        require(timeItTakes <= maxTimeRange, \"TOO_FAR_AWAY\");\n        // we compute the minimum arrival time\n        result.arrivalTime = uint40(block.timestamp + timeItTakes);\n\n        ImportingOuterSpaceTypes.ExternalPlanet memory fromPlanet = outerSpace.getUpdatedPlanetState(from);\n        uint256 yakuzaCap = _capWhenActive(statsForFromPlanet.production);\n        uint256 minimumSpaceshipsToLeave = (yakuzaCap * spaceshipsToKeepPer10000) / 10000;\n\n        // There is a minimum number of spaceships Yakuza want to keep on each planet\n        require(fromPlanet.numSpaceships > minimumSpaceshipsToLeave, \"NOT_ENOUGH_SPACESHIPS\");\n        require(amount <= fromPlanet.numSpaceships - minimumSpaceshipsToLeave, \"NEED_TO_LEAVE_ENOUGH_DEFENSE\");\n\n        // we give you revenge enough to capture it back\n        result.amountLeft = claims[fleetId].amountLeft;\n        if (result.amountLeft == 0) {\n            result.firstClaim = true;\n            uint256 attackedPlanetCap = _capWhenActive(statsForToPlanet.production);\n\n            // TODO\n            //      uint256 attackFactor = numAttack *\n            //     ((1000000 - _fleetSizeFactor6) + ((_fleetSizeFactor6 * numAttack) / numDefense));\n            // uint256 attackDamage = (attackFactor * attack) / defense / 1000000;\n\n            result.amountLeft = statsForToPlanet.defense < statsForFromPlanet.attack\n                ? attackedPlanetCap\n                : ((attackedPlanetCap * statsForToPlanet.defense) / statsForFromPlanet.attack) + 1;\n        }\n        require(amount <= result.amountLeft, \"TOO_MANY_SPACESHIPS_CLAIMED\");\n    }\n\n    function _checkValidFleet(address sender, uint256 fleetId, uint256 fleetOrigin, bool firstClaim) internal view {\n        // You cannot claim the same winning fleet twice\n        require(!claims[fleetId].claimed, \"ALREADY_CLAIMED\");\n\n        ImportingOuterSpaceTypes.ExternalPlanet memory toPlanet = outerSpace.getUpdatedPlanetState(fleetOrigin);\n        require(toPlanet.active, \"TARGET_PLANET_NOT_ACTIVE\");\n        require(toPlanet.owner != address(this), \"TARGET_PLANET_ALREADY_OWNED\");\n\n        ImportingOuterSpaceTypes.FleetData memory fleet = outerSpace.getFleetData(fleetId, fleetOrigin);\n\n        require(fleet.owner != address(this), \"FLEET_IS_YAKUZA\");\n\n        if (firstClaim) {\n            require(fleet.defender == sender, \"DID_NOT_TARGETED_YOU\");\n        }\n        // else\n        // once first claim is made, any subscriber can not continue the claim\n\n        // Fleet arrived before you subscribe (minus _frontrunningDelay)\n        require(fleet.arrivalTime - _frontrunningDelay > subscriptions[sender].startTime, \"FLEET_NOT_COVERED\");\n\n        // There is a delay after which you cannot claim anymore\n        if (firstClaim) {\n            require(block.timestamp < fleet.arrivalTime + maxClaimDelay, \"TOO_LATE_TO_CLAIM\");\n        } else {\n            // once first claim is made, there are more time to complete it\n            // allowing others to continue the counter-attack\n            // this prevent player to use yakuza to partially attack their planets\n            // with the intent to exit in time\n            require(\n                block.timestamp < fleet.arrivalTime + maxClaimDelay + maxClaimDelay / 2,\n                \"TOO_LATE_TO_CLAIM_FURTHER\"\n            );\n        }\n\n        // the fleet need to exist\n        require(fleet.quantity > 0, \"NO_FLEET\");\n\n        // Revenge can only be made on actual cpature of active planets\n        require(fleet.planetActive && fleet.victory, \"NOT_ACTIVE_VICTORY\");\n    }\n\n    function _claimAttack(\n        uint256 fleetId,\n        ImportingOuterSpaceTypes.FleetResolution calldata resolution,\n        uint32 amount,\n        uint256 from,\n        bytes32 toHash,\n        bytes32 secret,\n        uint256 distance\n    ) internal {\n        address sender = msg.sender;\n\n        // Here we verify the validity of the fleet and its data\n        require(\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        keccak256(\n                            abi.encodePacked(\n                                resolution.secret,\n                                resolution.to,\n                                resolution.gift,\n                                resolution.specific,\n                                resolution.arrivalTimeWanted\n                            )\n                        ),\n                        resolution.from,\n                        resolution.fleetSender,\n                        resolution.operator\n                    )\n                )\n            ) == fleetId,\n            \"INVALID_FLEET_DATA_OR_SECRET\"\n        );\n\n        Result memory planetResult = _computeArrivalTimeAndAmountLeft(fleetId, from, resolution.to, distance, amount);\n\n        _checkValidFleet(sender, fleetId, resolution.from, planetResult.firstClaim);\n\n        require(amount >= minAttackAmount, \"ATTACK_AMOUNT_TOO_SMALL\");\n\n        // once a attacked planet is claimed, it is considered being owned by Yakuza\n        myPlanets[resolution.to].mine = true;\n        uint40 lockTime = myPlanets[resolution.to].lockTime;\n        if (claims[fleetId].amountLeft == 0) {\n            lockTime = planetResult.arrivalTime + uint40(_frontrunningDelay);\n        } else {\n            lockTime = planetResult.arrivalTime + uint40(_frontrunningDelay) < lockTime\n                ? planetResult.arrivalTime + uint40(_frontrunningDelay)\n                : lockTime;\n        }\n        myPlanets[resolution.to].lockTime = lockTime;\n\n        if (amount >= planetResult.amountLeft) {\n            planetResult.amountLeft = 0;\n            claims[fleetId].claimed = true;\n        } else {\n            planetResult.amountLeft = uint248(planetResult.amountLeft - amount);\n        }\n        claims[fleetId].amountLeft = uint248(planetResult.amountLeft);\n\n        // then we do a basic send\n        // Yakuza is going to take control of the planet\n        // This also ensure this cannot be abused by losing planet in purpose\n        outerSpace.send(from, amount, toHash);\n\n        uint256 fleetSentId = uint256(keccak256(abi.encodePacked(toHash, from, address(this), address(this))));\n        emit YakuzaClaimed(\n            sender,\n            fleetId,\n            resolution.to,\n            fleetSentId,\n            amount,\n            planetResult.amountLeft,\n            lockTime,\n            secret\n        );\n    }\n\n    // --------------------------------------------------------------------------------------------\n\n    // --------------------------------------------------------------------------------------------\n    // Reward Receiver\n    // --------------------------------------------------------------------------------------------\n\n    function setRewardReceiver(address newRewardReceiver) external {\n        require(msg.sender == rewardReceiver, \"NOT_ALLOWED\");\n        rewardReceiver = newRewardReceiver;\n        emit RewardReceiverSet(newRewardReceiver);\n    }\n\n    // --------------------------------------------------------------------------------------------\n\n    // --------------------------------------------------------------------------------------------\n    // REWARDS FOR OWNER\n    // --------------------------------------------------------------------------------------------\n    function claimSharedPoolRewards(address to) external {\n        require(msg.sender == rewardReceiver, \"NOT_ALLOWED\");\n        generator.claimSharedPoolRewards(to);\n    }\n\n    function claimFixedRewards(address to) external {\n        require(msg.sender == rewardReceiver, \"NOT_ALLOWED\");\n        generator.claimFixedRewards(to);\n    }\n\n    function changegGenerator(RewardsGenerator newGenerator) external {\n        require(msg.sender == rewardReceiver, \"NOT_ALLOWED\");\n        generator = newGenerator;\n    }\n\n    // --------------------------------------------------------------------------------------------\n\n    // --------------------------------------------------------------------------------------------\n    // CONQUEST LOGIC\n    // --------------------------------------------------------------------------------------------\n\n    function _capWhenActive(uint16 production) internal view returns (uint256) {\n        return _acquireNumSpaceships + (uint256(production) * _productionCapAsDuration) / 1 hours;\n    }\n\n    struct Stats {\n        uint16 production;\n        uint16 attack;\n        uint16 defense;\n        uint16 speed;\n        int8 subX;\n        int8 subY;\n    }\n\n    function _getStats(uint256 location) internal view returns (Stats memory stats) {\n        bytes32 data = _planetData(location);\n        stats.production = _production(data);\n        stats.attack = _attack(data);\n        stats.defense = _defense(data);\n        stats.speed = _speed(data);\n        (stats.subX, stats.subY) = _subLocation(data);\n    }\n\n    function _planetData(uint256 location) internal view returns (bytes32) {\n        return keccak256(abi.encodePacked(_genesis, location));\n    }\n\n    function _exists(bytes32 data) internal pure returns (bool) {\n        return data.value8Mod(52, 16) == 1;\n    }\n\n    function _production(bytes32 data) internal pure returns (uint16) {\n        return data.normal16(12, 0x0708083409600a8c0bb80ce40e100e100e100e101068151819c81e7823282ee0); // per hour\n    }\n\n    function _attack(bytes32 data) internal pure returns (uint16) {\n        return 4000 + data.normal8(20) * 400; // 4,000 - 7,000 - 10,000\n    }\n\n    function _defense(bytes32 data) internal pure returns (uint16) {\n        return 4000 + data.normal8(28) * 400; // 4,000 - 7,000 - 10,000\n    }\n\n    function _subLocation(bytes32 data) internal pure returns (int8 subX, int8 subY) {\n        subX = 1 - int8(data.value8Mod(0, 3));\n        subY = 1 - int8(data.value8Mod(2, 3));\n    }\n\n    function _speed(bytes32 data) internal pure returns (uint16) {\n        return 5005 + data.normal8(36) * 333; // 5,005 - 7,502.5 - 10,000\n    }\n\n    function _requireCorrectDistance(\n        uint256 distance,\n        uint256 from,\n        uint256 to,\n        Stats memory fromStats,\n        Stats memory toStats\n    ) internal pure {\n        uint256 distanceSquared = uint256(\n            int256( // check input instead of compute sqrt\n                ((int128(int256(to & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) * 4 + toStats.subX) -\n                    (int128(int256(from & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) * 4 + fromStats.subX)) **\n                    2 +\n                    ((int128(int256(to >> 128)) * 4 + toStats.subY) -\n                        (int128(int256(from >> 128)) * 4 + fromStats.subY)) **\n                        2\n            )\n        );\n        require(distance ** 2 <= distanceSquared && distanceSquared < (distance + 1) ** 2, \"wrong distance\");\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}