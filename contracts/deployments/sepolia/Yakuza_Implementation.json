{
  "address": "0x303c54b56ea9aa4318c4A27730aE13F972490Bf6",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "initialRewardReceiver",
          "type": "address"
        },
        {
          "internalType": "contract RewardsGenerator",
          "name": "initialGenerator",
          "type": "address"
        },
        {
          "internalType": "contract IOuterSpace",
          "name": "initialOuterSpace",
          "type": "address"
        },
        {
          "internalType": "contract PlayToken",
          "name": "initialPlayToken",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "numSecondsPerTokens",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "spaceshipsToKeepPer10000",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "acquireNumSpaceships",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "productionCapAsDuration",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "frontrunningDelay",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "minAverageStakePerPlanet",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxClaimDelay",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "minimumSubscriptionWhenStaking",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "minimumSubscriptionWhenNotStaking",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "genesis",
              "type": "bytes32"
            }
          ],
          "internalType": "struct Yakuza.Config",
          "name": "config",
          "type": "tuple"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "spender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "Approval",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "newRewardReceiver",
          "type": "address"
        }
      ],
      "name": "RewardReceiverSet",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "Transfer",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "fleetId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "attackedPlanet",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "fleetSentId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountLeft",
          "type": "uint256"
        }
      ],
      "name": "YakuzaClaimed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "subscriber",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "startTime",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "endTime",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "contribution",
          "type": "uint256"
        }
      ],
      "name": "YakuzaSubscribed",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "DOMAIN_SEPARATOR",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "spender",
          "type": "address"
        }
      ],
      "name": "allowance",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "spender",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "approve",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "spender",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "approveAndCall",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "balanceOf",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract RewardsGenerator",
          "name": "newGenerator",
          "type": "address"
        }
      ],
      "name": "changegGenerator",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        }
      ],
      "name": "claim",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "fleetId",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "from",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "to",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "distance",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "arrivalTimeWanted",
              "type": "uint256"
            },
            {
              "internalType": "bool",
              "name": "gift",
              "type": "bool"
            },
            {
              "internalType": "address",
              "name": "specific",
              "type": "address"
            },
            {
              "internalType": "bytes32",
              "name": "secret",
              "type": "bytes32"
            },
            {
              "internalType": "address",
              "name": "fleetSender",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "operator",
              "type": "address"
            }
          ],
          "internalType": "struct ImportingOuterSpaceTypes.FleetResolution",
          "name": "resolution",
          "type": "tuple"
        },
        {
          "internalType": "uint32",
          "name": "amount",
          "type": "uint32"
        },
        {
          "internalType": "uint256",
          "name": "from",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "toHash",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "arrivalTimeWanted",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "secret",
          "type": "bytes32"
        },
        {
          "internalType": "address payable",
          "name": "payee",
          "type": "address"
        }
      ],
      "name": "claimCounterAttack",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        }
      ],
      "name": "claimFixedRewards",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        }
      ],
      "name": "claimSharedPoolRewards",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "claims",
      "outputs": [
        {
          "internalType": "bool",
          "name": "claimed",
          "type": "bool"
        },
        {
          "internalType": "uint248",
          "name": "amountLeft",
          "type": "uint248"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "decimals",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address payable[]",
          "name": "tos",
          "type": "address[]"
        },
        {
          "internalType": "uint256",
          "name": "totalAmount",
          "type": "uint256"
        }
      ],
      "name": "distributeAlongWithETH",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address payable[]",
          "name": "tos",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "amounts",
          "type": "uint256[]"
        }
      ],
      "name": "distributeVariousAmountsAlongWithETH",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address payable[]",
          "name": "tos",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "tokenAmounts",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256[]",
          "name": "etherAmounts",
          "type": "uint256[]"
        }
      ],
      "name": "distributeVariousAmountsOfTokenAndETH",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "generator",
      "outputs": [
        {
          "internalType": "contract RewardsGenerator",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "maxClaimDelay",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "minAverageStakePerPlanet",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "minimumSubscriptionWhenNotStaking",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "minimumSubscriptionWhenStaking",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "name",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "nonces",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "numSecondsPerTokens",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "outerSpace",
      "outputs": [
        {
          "internalType": "contract IOuterSpace",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "forAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "payForAndCall",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "spender",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "deadline",
          "type": "uint256"
        },
        {
          "internalType": "uint8",
          "name": "v",
          "type": "uint8"
        },
        {
          "internalType": "bytes32",
          "name": "r",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "s",
          "type": "bytes32"
        }
      ],
      "name": "permit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "playToken",
      "outputs": [
        {
          "internalType": "contract PlayToken",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "initialRewardReceiver",
          "type": "address"
        },
        {
          "internalType": "contract RewardsGenerator",
          "name": "initialGenerator",
          "type": "address"
        },
        {
          "internalType": "contract IOuterSpace",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "contract PlayToken",
          "name": "",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "numSecondsPerTokens",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "spaceshipsToKeepPer10000",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "acquireNumSpaceships",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "productionCapAsDuration",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "frontrunningDelay",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "minAverageStakePerPlanet",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxClaimDelay",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "minimumSubscriptionWhenStaking",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "minimumSubscriptionWhenNotStaking",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "genesis",
              "type": "bytes32"
            }
          ],
          "internalType": "struct Yakuza.Config",
          "name": "",
          "type": "tuple"
        }
      ],
      "name": "postUpgrade",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "rewardReceiver",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newRewardReceiver",
          "type": "address"
        }
      ],
      "name": "setRewardReceiver",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "spaceshipsToKeepPer10000",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[]",
          "name": "locations",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256",
          "name": "amountToMint",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "tokenAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amountFromYakuza",
          "type": "uint256"
        }
      ],
      "name": "subscribeViaStaking",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amountToMint",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "tokenAmount",
          "type": "uint256"
        }
      ],
      "name": "subscribeWithoutStaking",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "subscriptions",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "startTime",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "endTime",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "symbol",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalSupply",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "transfer",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address payable",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "transferAlongWithETH",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "transferAndCall",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "transferFrom",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "transferFromAndCall",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xc5815686a5f5bac5170cc669888ae87e9a31cf9859f2df99ae82b53491607c48",
  "receipt": {
    "to": null,
    "from": "0x61c461EcC993aaDEB7e4b47E96d1B8cC37314B20",
    "contractAddress": "0x303c54b56ea9aa4318c4A27730aE13F972490Bf6",
    "transactionIndex": 94,
    "gasUsed": "3975027",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xde3e607e3b090bf1bf98ca2e33b188260b5e7e09d34d4d8e1907aacbeca8dff6",
    "transactionHash": "0xc5815686a5f5bac5170cc669888ae87e9a31cf9859f2df99ae82b53491607c48",
    "logs": [],
    "blockNumber": 7623404,
    "cumulativeGasUsed": "21018373",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x61c461EcC993aaDEB7e4b47E96d1B8cC37314B20",
    "0x6e35f7FEFb98fD3E8b5F2f3Cd40E7d073241664d",
    "0x3Ab8D9b483Ae392C1bbf85905B2998af30714361",
    "0x81C151895C59b081CBeFFcA070684f786ce306D9",
    {
      "genesis": "0x21B25FA48DFAF94F6FC5D7C14C206CC0F716AAE46A5EA817445EA411E3299541",
      "acquireNumSpaceships": 100000,
      "productionCapAsDuration": 259200,
      "frontrunningDelay": 18,
      "numSecondsPerTokens": 302400,
      "spaceshipsToKeepPer10000": 2000,
      "minAverageStakePerPlanet": "5000000000000000000",
      "maxClaimDelay": 86400,
      "minimumSubscriptionWhenNotStaking": "1000000000000000000",
      "minimumSubscriptionWhenStaking": "1000000000000000000"
    }
  ],
  "numDeployments": 2,
  "linkedData": {
    "genesis": "0x21B25FA48DFAF94F6FC5D7C14C206CC0F716AAE46A5EA817445EA411E3299541",
    "acquireNumSpaceships": 100000,
    "productionCapAsDuration": 259200,
    "frontrunningDelay": 18,
    "numSecondsPerTokens": 302400,
    "spaceshipsToKeepPer10000": 2000,
    "minAverageStakePerPlanet": "5000000000000000000",
    "maxClaimDelay": 86400,
    "minimumSubscriptionWhenNotStaking": {
      "type": "BigNumber",
      "hex": "0x0de0b6b3a7640000"
    },
    "minimumSubscriptionWhenStaking": {
      "type": "BigNumber",
      "hex": "0x0de0b6b3a7640000"
    }
  },
  "solcInputHash": "d3182fc12262e080b0f18e830973baa0",
  "metadata": "{\"compiler\":{\"version\":\"0.8.9+commit.e5eed63a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initialRewardReceiver\",\"type\":\"address\"},{\"internalType\":\"contract RewardsGenerator\",\"name\":\"initialGenerator\",\"type\":\"address\"},{\"internalType\":\"contract IOuterSpace\",\"name\":\"initialOuterSpace\",\"type\":\"address\"},{\"internalType\":\"contract PlayToken\",\"name\":\"initialPlayToken\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"numSecondsPerTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spaceshipsToKeepPer10000\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"acquireNumSpaceships\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"productionCapAsDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"frontrunningDelay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAverageStakePerPlanet\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxClaimDelay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumSubscriptionWhenStaking\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumSubscriptionWhenNotStaking\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"genesis\",\"type\":\"bytes32\"}],\"internalType\":\"struct Yakuza.Config\",\"name\":\"config\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newRewardReceiver\",\"type\":\"address\"}],\"name\":\"RewardReceiverSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fleetId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"attackedPlanet\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fleetSentId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountLeft\",\"type\":\"uint256\"}],\"name\":\"YakuzaClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"subscriber\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"contribution\",\"type\":\"uint256\"}],\"name\":\"YakuzaSubscribed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract RewardsGenerator\",\"name\":\"newGenerator\",\"type\":\"address\"}],\"name\":\"changegGenerator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fleetId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"distance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"arrivalTimeWanted\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"gift\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"specific\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"secret\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"fleetSender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"internalType\":\"struct ImportingOuterSpaceTypes.FleetResolution\",\"name\":\"resolution\",\"type\":\"tuple\"},{\"internalType\":\"uint32\",\"name\":\"amount\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"toHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"arrivalTimeWanted\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"secret\",\"type\":\"bytes32\"},{\"internalType\":\"address payable\",\"name\":\"payee\",\"type\":\"address\"}],\"name\":\"claimCounterAttack\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"claimFixedRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"claimSharedPoolRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"claims\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"claimed\",\"type\":\"bool\"},{\"internalType\":\"uint248\",\"name\":\"amountLeft\",\"type\":\"uint248\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable[]\",\"name\":\"tos\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"name\":\"distributeAlongWithETH\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable[]\",\"name\":\"tos\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"distributeVariousAmountsAlongWithETH\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable[]\",\"name\":\"tos\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"etherAmounts\",\"type\":\"uint256[]\"}],\"name\":\"distributeVariousAmountsOfTokenAndETH\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"generator\",\"outputs\":[{\"internalType\":\"contract RewardsGenerator\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxClaimDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minAverageStakePerPlanet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumSubscriptionWhenNotStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumSubscriptionWhenStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numSecondsPerTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"outerSpace\",\"outputs\":[{\"internalType\":\"contract IOuterSpace\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"forAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"payForAndCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"playToken\",\"outputs\":[{\"internalType\":\"contract PlayToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initialRewardReceiver\",\"type\":\"address\"},{\"internalType\":\"contract RewardsGenerator\",\"name\":\"initialGenerator\",\"type\":\"address\"},{\"internalType\":\"contract IOuterSpace\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"contract PlayToken\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"numSecondsPerTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spaceshipsToKeepPer10000\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"acquireNumSpaceships\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"productionCapAsDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"frontrunningDelay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAverageStakePerPlanet\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxClaimDelay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumSubscriptionWhenStaking\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumSubscriptionWhenNotStaking\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"genesis\",\"type\":\"bytes32\"}],\"internalType\":\"struct Yakuza.Config\",\"name\":\"\",\"type\":\"tuple\"}],\"name\":\"postUpgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRewardReceiver\",\"type\":\"address\"}],\"name\":\"setRewardReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"spaceshipsToKeepPer10000\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"locations\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"amountToMint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountFromYakuza\",\"type\":\"uint256\"}],\"name\":\"subscribeViaStaking\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToMint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"subscribeWithoutStaking\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"subscriptions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferAlongWithETH\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferAndCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferFromAndCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"allowance(address,address)\":{\"details\":\"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called.\"},\"approve(address,uint256)\":{\"details\":\"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event.\"},\"totalSupply()\":{\"details\":\"Returns the amount of tokens in existence.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/yakuza/Yakuza.sol\":\"Yakuza\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":999999},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x027b891937d20ccf213fdb9c31531574256de774bda99d3a70ecef6e1913ed2a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x02348b2e4b9f3200c7e3907c5c2661643a6d8520e9f79939fbb9b4005a54894d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3336baae5cf23e94274d75336e2d412193be508504aee185e61dc7d58cd05c8a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s;\\n        uint8 v;\\n        assembly {\\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            v := add(shr(255, vs), 27)\\n        }\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\",\"keccak256\":\"0xbc991a1cf357ce19480831a40792c814238a3b5458134703682abd8aa39719fb\",\"license\":\"MIT\"},\"hardhat-deploy/solc_0.8/proxy/Proxied.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract Proxied {\\n    /// @notice to be used by initialisation / postUpgrade function so that only the proxy's admin can execute them\\n    /// It also allows these functions to be called inside a contructor\\n    /// even if the contract is meant to be used without proxy\\n    modifier proxied() {\\n        address proxyAdminAddress = _proxyAdmin();\\n        // With hardhat-deploy proxies\\n        // the proxyAdminAddress is zero only for the implementation contract\\n        // if the implementation contract want to be used as a standalone/immutable contract\\n        // it simply has to execute the `proxied` function\\n        // This ensure the proxyAdminAddress is never zero post deployment\\n        // And allow you to keep the same code for both proxied contract and immutable contract\\n        if (proxyAdminAddress == address(0)) {\\n            // ensure can not be called twice when used outside of proxy : no admin\\n            // solhint-disable-next-line security/no-inline-assembly\\n            assembly {\\n                sstore(\\n                    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103,\\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n                )\\n            }\\n        } else {\\n            require(msg.sender == proxyAdminAddress);\\n        }\\n        _;\\n    }\\n\\n    modifier onlyProxyAdmin() {\\n        require(msg.sender == _proxyAdmin(), \\\"NOT_AUTHORIZED\\\");\\n        _;\\n    }\\n\\n    function _proxyAdmin() internal view returns (address ownerAddress) {\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            ownerAddress := sload(0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xaaceeafeeaf0d200ca3942d8bf14c1c4f787a77f79cc87c08bb668e65acdee29\",\"license\":\"MIT\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nlibrary console {\\n    address constant CONSOLE_ADDRESS =\\n        0x000000000000000000636F6e736F6c652e6c6f67;\\n\\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            pop(\\n                staticcall(\\n                    gas(),\\n                    consoleAddress,\\n                    add(payload, 32),\\n                    mload(payload),\\n                    0,\\n                    0\\n                )\\n            )\\n        }\\n    }\\n\\n    function _castToPure(\\n      function(bytes memory) internal view fnIn\\n    ) internal pure returns (function(bytes memory) pure fnOut) {\\n        assembly {\\n            fnOut := fnIn\\n        }\\n    }\\n\\n    function _sendLogPayload(bytes memory payload) internal pure {\\n        _castToPure(_sendLogPayloadImplementation)(payload);\\n    }\\n\\n    function log() internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n\\n    function logInt(int256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n    }\\n\\n    function logUint(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint256 p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n}\\n\",\"keccak256\":\"0xf2560b5386574153057104d19a9e68a32ee912cf23c0c8df1fe9a0607f42d543\",\"license\":\"MIT\"},\"src/alliances/AllianceRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity 0.8.9;\\n\\nimport \\\"hardhat-deploy/solc_0.8/proxy/Proxied.sol\\\";\\nimport \\\"../interfaces/IAlliance.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\n// import \\\"hardhat/console.sol\\\";\\n\\ncontract AllianceRegistry is Proxied {\\n    using ECDSA for bytes32;\\n\\n    uint8 internal constant MAX_NUM_ALLIANCES = 4;\\n\\n    mapping(address => mapping(IAlliance => uint256)) internal _allianceNonces;\\n    struct AllianceRow {\\n        IAlliance alliance;\\n        uint96 joinTime;\\n    }\\n    struct Alliances {\\n        AllianceRow alliance0;\\n        AllianceRow alliance1;\\n        AllianceRow alliance2;\\n        AllianceRow alliance3;\\n    }\\n    mapping(address => Alliances) internal _alliances;\\n\\n    event AllianceLink(IAlliance indexed alliance, address indexed player, bool joining);\\n\\n    function getAllianceDataAtSlot(address player, uint8 slot)\\n        external\\n        view\\n        returns (\\n            IAlliance alliance,\\n            uint96 joinTime,\\n            uint256 nonce\\n        )\\n    {\\n        Alliances storage alliances = _alliances[player];\\n        if (slot == 0) {\\n            alliance = alliances.alliance0.alliance;\\n            joinTime = alliances.alliance0.joinTime;\\n        } else if (slot == 1) {\\n            alliance = alliances.alliance1.alliance;\\n            joinTime = alliances.alliance1.joinTime;\\n        } else if (slot == 2) {\\n            alliance = alliances.alliance2.alliance;\\n            joinTime = alliances.alliance2.joinTime;\\n        } else if (slot == 3) {\\n            alliance = alliances.alliance3.alliance;\\n            joinTime = alliances.alliance3.joinTime;\\n        }\\n\\n        nonce = _allianceNonces[player][alliance];\\n    }\\n\\n    function getAllianceData(address player, IAlliance alliance) public view returns (uint96 joinTime, uint256 nonce) {\\n        nonce = _allianceNonces[player][alliance];\\n\\n        Alliances storage alliances = _alliances[player];\\n        if (alliances.alliance0.alliance == alliance) {\\n            joinTime = alliances.alliance0.joinTime;\\n        } else if (alliances.alliance1.alliance == alliance) {\\n            joinTime = alliances.alliance1.joinTime;\\n        } else if (alliances.alliance2.alliance == alliance) {\\n            joinTime = alliances.alliance2.joinTime;\\n        } else if (alliances.alliance3.alliance == alliance) {\\n            joinTime = alliances.alliance3.joinTime;\\n        }\\n    }\\n\\n    function havePlayersAnAllianceInCommon(\\n        address player1,\\n        address player2,\\n        uint256 timestamp\\n    ) external view returns (IAlliance alliance, uint96 joinTime) {\\n        Alliances storage p1Alliances = _alliances[player1];\\n        Alliances storage p2Alliances = _alliances[player2];\\n\\n        AllianceRow[4] memory player1Alliances;\\n        AllianceRow[4] memory player2Alliances;\\n        uint256 num1 = 0;\\n        uint256 num2 = 0;\\n\\n        for (uint256 i = 0; i < 4; i++) {\\n            if (i == num1) {\\n                AllianceRow memory allianceRow;\\n                if (i == 0) {\\n                    allianceRow = p1Alliances.alliance0;\\n                } else if (i == 1) {\\n                    allianceRow = p1Alliances.alliance1;\\n                } else if (i == 2) {\\n                    allianceRow = p1Alliances.alliance2;\\n                } else if (i == 3) {\\n                    allianceRow = p1Alliances.alliance3;\\n                }\\n                if (address(allianceRow.alliance) == address(0)) {\\n                    // console.log(\\\"p1 exhausted\\\");\\n                    return (alliance, joinTime); // the alliance leave ensure that there is no gap // TODO\\n                }\\n                player1Alliances[num1++] = allianceRow;\\n            }\\n            for (uint256 j = 0; j < 4; j++) {\\n                if (j == num2) {\\n                    AllianceRow memory allianceRow;\\n                    if (j == 0) {\\n                        allianceRow = p2Alliances.alliance0;\\n                    } else if (j == 1) {\\n                        allianceRow = p2Alliances.alliance1;\\n                    } else if (j == 2) {\\n                        allianceRow = p2Alliances.alliance2;\\n                    } else if (j == 3) {\\n                        allianceRow = p2Alliances.alliance3;\\n                    }\\n                    if (address(allianceRow.alliance) == address(0)) {\\n                        // console.log(\\\"p2 exhausted\\\");\\n                        // return (alliance, joinTime); // the alliance leave ensure that there is no gap // TODO\\n                        break;\\n                    }\\n                    player2Alliances[num2++] = allianceRow;\\n                }\\n\\n                if (player1Alliances[i].alliance == player2Alliances[j].alliance) {\\n                    if (player1Alliances[i].joinTime >= player2Alliances[j].joinTime) {\\n                        if (player1Alliances[i].joinTime < timestamp) {\\n                            return (player1Alliances[i].alliance, player1Alliances[i].joinTime);\\n                        } else {\\n                            // TODO check greater ?\\n                            alliance = player1Alliances[i].alliance;\\n                            joinTime = player1Alliances[i].joinTime;\\n                        }\\n                    } else {\\n                        if (player2Alliances[j].joinTime < timestamp) {\\n                            return (player2Alliances[j].alliance, player2Alliances[j].joinTime);\\n                        } else {\\n                            // TODO check greater ?\\n                            alliance = player2Alliances[j].alliance;\\n                            joinTime = player2Alliances[j].joinTime;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        // console.log(address(alliance));\\n        // console.log(joinTime);\\n    }\\n\\n    // -----------------------------------------------------------------------------------------------------\\n    // FROM PLAYER\\n    // -----------------------------------------------------------------------------------------------------\\n\\n    function joinAlliance(IAlliance alliance, bytes calldata data) external returns (bool joined) {\\n        Alliances storage alliances = _alliances[msg.sender];\\n        uint256 slot = 0;\\n        if (address(alliances.alliance0.alliance) != address(0)) {\\n            slot++;\\n        }\\n        if (address(alliances.alliance1.alliance) != address(0)) {\\n            slot++;\\n        }\\n        if (address(alliances.alliance2.alliance) != address(0)) {\\n            slot++;\\n        }\\n        require(address(alliances.alliance3.alliance) == address(0), \\\"MAX_NUM_ALLIANCES_REACHED\\\");\\n\\n        joined = alliance.requestToJoin(msg.sender, data);\\n        if (joined) {\\n            if (slot == 0) {\\n                alliances.alliance0.alliance = alliance;\\n                alliances.alliance0.joinTime = uint96(block.timestamp);\\n            } else if (slot == 1) {\\n                alliances.alliance1.alliance = alliance;\\n                alliances.alliance1.joinTime = uint96(block.timestamp);\\n            } else if (slot == 2) {\\n                alliances.alliance2.alliance = alliance;\\n                alliances.alliance2.joinTime = uint96(block.timestamp);\\n            } else if (slot == 3) {\\n                alliances.alliance3.alliance = alliance;\\n                alliances.alliance3.joinTime = uint96(block.timestamp);\\n            }\\n\\n            emit AllianceLink(alliance, msg.sender, true);\\n        }\\n    }\\n\\n    function leaveAlliance(IAlliance alliance) external {\\n        _leaveAlliance(msg.sender, alliance);\\n        try alliance.playerHasLeft(msg.sender) {} catch {}\\n        // TODO ensure callback not failed due to low gas (1/64 rule)\\n    }\\n\\n    // -----------------------------------------------------------------------------------------------------\\n    // FROM ALLIANCE\\n    // -----------------------------------------------------------------------------------------------------\\n\\n    function addPlayerToAlliance(\\n        address player,\\n        uint32 nonce,\\n        bytes calldata signature\\n    ) external {\\n        _addPlayerToAlliance(player, nonce, signature);\\n    }\\n\\n    struct PlayerSubmission {\\n        address addr;\\n        uint32 nonce;\\n        bytes signature;\\n    }\\n\\n    function addMultiplePlayersToAlliance(PlayerSubmission[] calldata playerSubmissions) external {\\n        for (uint256 i = 0; i < playerSubmissions.length; i++) {\\n            _addPlayerToAlliance(playerSubmissions[i].addr, playerSubmissions[i].nonce, playerSubmissions[i].signature);\\n        }\\n    }\\n\\n    function ejectPlayerFromAlliance(address player) external {\\n        _leaveAlliance(player, IAlliance(msg.sender));\\n    }\\n\\n    // -----------------------------------------------------------------------------------------------------\\n    // INTERNAL\\n    // -----------------------------------------------------------------------------------------------------\\n\\n    function _addPlayerToAlliance(\\n        address player,\\n        uint32 nonce,\\n        bytes calldata signature\\n    ) internal {\\n        IAlliance alliance = IAlliance(msg.sender);\\n\\n        Alliances storage alliances = _alliances[player];\\n        uint256 slot = 0;\\n        if (address(alliances.alliance0.alliance) != address(0)) {\\n            require(alliances.alliance0.alliance != alliance, \\\"ALREADY_JOINED\\\");\\n            slot++;\\n        }\\n        if (address(alliances.alliance1.alliance) != address(0)) {\\n            require(alliances.alliance1.alliance != alliance, \\\"ALREADY_JOINED\\\");\\n            slot++;\\n        }\\n        if (address(alliances.alliance2.alliance) != address(0)) {\\n            require(alliances.alliance2.alliance != alliance, \\\"ALREADY_JOINED\\\");\\n            slot++;\\n        }\\n        require(alliances.alliance3.alliance != alliance, \\\"ALREADY_JOINED\\\");\\n        require(address(alliances.alliance3.alliance) == address(0), \\\"MAX_NUM_ALLIANCES_REACHED\\\");\\n\\n        uint256 currentNonce = _allianceNonces[player][alliance];\\n        require(currentNonce == nonce, \\\"INVALID_NONCE\\\");\\n\\n        bytes memory message;\\n        if (nonce == 0) {\\n            message = abi.encodePacked(\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n56\\\",\\n                \\\"Join Alliance 0x0000000000000000000000000000000000000000\\\"\\n            );\\n            _writeUintAsHex(message, 28 + 55, uint160(msg.sender));\\n        } else {\\n            message = abi.encodePacked(\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n76\\\",\\n                \\\"Join Alliance 0x0000000000000000000000000000000000000000 (nonce:          0)\\\"\\n            );\\n            _writeUintAsHex(message, 28 + 55, uint160(msg.sender));\\n            _writeUintAsDecimal(message, 28 + 74, nonce);\\n        }\\n\\n        // console.log(string(message));\\n\\n        bytes32 digest = keccak256(message);\\n\\n        address signer = digest.recover(signature);\\n        require(player == signer, \\\"INVALID_SIGNATURE\\\");\\n\\n        if (slot == 0) {\\n            alliances.alliance0.alliance = alliance;\\n            alliances.alliance0.joinTime = uint96(block.timestamp);\\n        } else if (slot == 1) {\\n            alliances.alliance1.alliance = alliance;\\n            alliances.alliance1.joinTime = uint96(block.timestamp);\\n        } else if (slot == 2) {\\n            alliances.alliance2.alliance = alliance;\\n            alliances.alliance2.joinTime = uint96(block.timestamp);\\n        } else if (slot == 3) {\\n            alliances.alliance3.alliance = alliance;\\n            alliances.alliance3.joinTime = uint96(block.timestamp);\\n        }\\n        _allianceNonces[player][alliance] = nonce + 1;\\n\\n        emit AllianceLink(alliance, player, true);\\n\\n        _checkERC1155AndCallSafeTransfer(msg.sender, address(0), player, uint256(uint160(address(alliance))), 1);\\n        emit TransferSingle(msg.sender, address(0), player, uint256(uint160(address(alliance))), 1);\\n    }\\n\\n    bytes internal constant hexAlphabet = \\\"0123456789abcdef\\\";\\n    bytes internal constant decimalAlphabet = \\\"0123456789\\\";\\n\\n    function _writeUintAsHex(\\n        bytes memory data,\\n        uint256 endPos,\\n        uint256 num\\n    ) internal pure {\\n        while (num != 0) {\\n            data[endPos--] = bytes1(hexAlphabet[num % 16]);\\n            num /= 16;\\n        }\\n    }\\n\\n    function _writeUintAsDecimal(\\n        bytes memory data,\\n        uint256 endPos,\\n        uint256 num\\n    ) internal pure {\\n        while (num != 0) {\\n            data[endPos--] = bytes1(decimalAlphabet[num % 10]);\\n            num /= 10;\\n        }\\n    }\\n\\n    function _leaveAlliance(address player, IAlliance alliance) internal {\\n        Alliances storage alliances = _alliances[player];\\n\\n        IAlliance lastSlotAlliance;\\n        uint96 lastSlotJoinTime;\\n\\n        require(address(alliances.alliance0.alliance) != address(0), \\\"NOT_PART_OF_ANY_ALLIANCE\\\");\\n\\n        if (address(alliances.alliance1.alliance) == address(0)) {\\n            lastSlotAlliance = alliances.alliance0.alliance;\\n            lastSlotJoinTime = alliances.alliance0.joinTime;\\n            alliances.alliance0.alliance = IAlliance(address(0));\\n            alliances.alliance0.joinTime = 0;\\n        } else {\\n            if (address(alliances.alliance2.alliance) == address(0)) {\\n                lastSlotAlliance = alliances.alliance1.alliance;\\n                lastSlotJoinTime = alliances.alliance1.joinTime;\\n                alliances.alliance1.alliance = IAlliance(address(0));\\n                alliances.alliance1.joinTime = 0;\\n            } else {\\n                if (address(alliances.alliance3.alliance) == address(0)) {\\n                    lastSlotAlliance = alliances.alliance2.alliance;\\n                    lastSlotJoinTime = alliances.alliance2.joinTime;\\n                    alliances.alliance2.alliance = IAlliance(address(0));\\n                    alliances.alliance2.joinTime = 0;\\n                } else {\\n                    lastSlotAlliance = alliances.alliance3.alliance;\\n                    lastSlotJoinTime = alliances.alliance3.joinTime;\\n                    alliances.alliance3.alliance = IAlliance(address(0));\\n                    alliances.alliance3.joinTime = 0;\\n                }\\n            }\\n        }\\n\\n        if (alliance != lastSlotAlliance) {\\n            if (alliances.alliance0.alliance == alliance) {\\n                alliances.alliance0.alliance = lastSlotAlliance;\\n                alliances.alliance0.joinTime = lastSlotJoinTime;\\n            } else if (alliances.alliance1.alliance == alliance) {\\n                alliances.alliance1.alliance = lastSlotAlliance;\\n                alliances.alliance1.joinTime = lastSlotJoinTime;\\n            } else if (alliances.alliance2.alliance == alliance) {\\n                alliances.alliance2.alliance = lastSlotAlliance;\\n                alliances.alliance2.joinTime = lastSlotJoinTime;\\n            } else {\\n                revert(\\\"NOT_PART_OF_THE_ALLIANCE\\\");\\n            }\\n        }\\n\\n        emit AllianceLink(alliance, player, false);\\n        emit TransferSingle(msg.sender, player, address(0), uint256(uint160(address(alliance))), 1);\\n    }\\n\\n    function _msgSender() internal view returns (address) {\\n        return msg.sender; // TODO metatx\\n    }\\n\\n    // ---------------------------------------------------------------------\\n    // Support For ERC-1155\\n    // ---------------------------------------------------------------------\\n\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    function balanceOf(address owner, uint256 id) external view returns (uint256 balance) {\\n        require(id == uint160(id), \\\"INVALID_ID\\\");\\n        (uint96 joinTime, ) = getAllianceData(owner, IAlliance(address(uint160(id))));\\n        if (joinTime > 0) {\\n            return 1;\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory balances)\\n    {\\n        balances = new uint256[](owners.length);\\n        for (uint256 i = 0; i < owners.length; i++) {\\n            require(ids[i] == uint160(ids[i]), \\\"INVALID_ID\\\");\\n            (uint96 joinTime, ) = getAllianceData(owners[i], IAlliance(address(uint160(ids[i]))));\\n            if (joinTime > 0) {\\n                balances[i] = 1;\\n            } else {\\n                balances[i] = 0;\\n            }\\n        }\\n    }\\n\\n    function isApprovedForAll(address, address) external pure returns (bool) {\\n        return false;\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool) {\\n        return interfaceID == 0xd9b67a26 || interfaceID == 0x01ffc9a7;\\n    }\\n\\n    function _checkERC1155AndCallSafeTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 value\\n    ) internal returns (bool) {\\n        if (!Address.isContract(to)) {\\n            return true;\\n        }\\n\\n        return ERC1155TokenReceiver(to).onERC1155Received(operator, from, id, value, \\\"\\\") == 0xf23a6e61;\\n    }\\n}\\n\\ninterface ERC1155TokenReceiver {\\n    function onERC1155Received(\\n        address _operator,\\n        address _from,\\n        uint256 _id,\\n        uint256 _value,\\n        bytes calldata _data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0x15b20d9532d077a0ebb513370a71601a569f277bce663e93c090565882c9e1bb\",\"license\":\"AGPL-3.0\"},\"src/base/erc20/ERC20BaseInternal.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.9;\\n\\nabstract contract ERC20BaseInternal {\\n    function _approveFor(\\n        address owner,\\n        address target,\\n        uint256 amount\\n    ) internal virtual;\\n\\n    function name() public virtual returns (string memory);\\n\\n    function _mint(address to, uint256 amount) internal virtual;\\n\\n    function _burnFrom(address from, uint256 amount) internal virtual;\\n\\n    function _internal_totalSupply() internal view virtual returns (uint256);\\n}\\n\",\"keccak256\":\"0xe99f2bd62fca5ffa2a50281621dc512e62277aa6cfc3f739dd6ef76c60e23e8c\",\"license\":\"AGPL-3.0\"},\"src/base/erc20/UsingERC20Base.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"./ERC20BaseInternal.sol\\\";\\nimport \\\"../../libraries/Constants.sol\\\";\\n\\ninterface IBurnReceiver {\\n    function onTokenBurn(\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external returns (bool);\\n}\\n\\ninterface ITransferReceiver {\\n    function onTokenTransfer(\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external returns (bool);\\n}\\n\\ninterface IPaidForReceiver {\\n    function onTokenPaidFor(\\n        address payer,\\n        address forAddress,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bool);\\n}\\n\\ninterface IApprovalReceiver {\\n    function onTokenApproval(\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external returns (bool);\\n}\\n\\nabstract contract UsingERC20Base is IERC20, ERC20BaseInternal {\\n    using Address for address;\\n\\n    uint256 internal _totalSupply;\\n    mapping(address => uint256) internal _balances;\\n    mapping(address => mapping(address => uint256)) internal _allowances;\\n\\n    function _internal_totalSupply() internal view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function totalSupply() external view override returns (uint256) {\\n        return _internal_totalSupply();\\n    }\\n\\n    function balanceOf(address owner) external view override returns (uint256) {\\n        return _balances[owner];\\n    }\\n\\n    function allowance(address owner, address spender) external view override returns (uint256) {\\n        if (owner == address(this)) {\\n            // see transferFrom: address(this) allows anyone\\n            return Constants.UINT256_MAX;\\n        }\\n        return _allowances[owner][spender];\\n    }\\n\\n    function decimals() external pure virtual returns (uint8) {\\n        return uint8(18);\\n    }\\n\\n    function transfer(address to, uint256 amount) external override returns (bool) {\\n        _transfer(msg.sender, to, amount);\\n        return true;\\n    }\\n\\n    function transferAlongWithETH(address payable to, uint256 amount) external payable returns (bool) {\\n        _transfer(msg.sender, to, amount);\\n        to.transfer(msg.value);\\n        return true;\\n    }\\n\\n    function distributeAlongWithETH(address payable[] calldata tos, uint256 totalAmount)\\n        external\\n        payable\\n        returns (bool)\\n    {\\n        uint256 val = msg.value / tos.length;\\n        require(msg.value == val * tos.length, \\\"INVALID_MSG_VALUE\\\");\\n        uint256 amount = totalAmount / tos.length;\\n        require(totalAmount == amount * tos.length, \\\"INVALID_TOTAL_AMOUNT\\\");\\n        for (uint256 i = 0; i < tos.length; i++) {\\n            _transfer(msg.sender, tos[i], amount);\\n            tos[i].transfer(val);\\n        }\\n        return true;\\n    }\\n\\n    function distributeVariousAmountsAlongWithETH(address payable[] calldata tos, uint256[] calldata amounts)\\n        external\\n        payable\\n        returns (bool)\\n    {\\n        uint256 val = msg.value / tos.length;\\n        require(msg.value == val * tos.length, \\\"INVALID_MSG_VALUE\\\");\\n        require(tos.length == amounts.length, \\\"NOT_SAME_LENGTH\\\");\\n        for (uint256 i = 0; i < tos.length; i++) {\\n            _transfer(msg.sender, tos[i], amounts[i]);\\n            tos[i].transfer(val);\\n        }\\n        return true;\\n    }\\n\\n    function distributeVariousAmountsOfTokenAndETH(\\n        address payable[] calldata tos,\\n        uint256[] calldata tokenAmounts,\\n        uint256[] calldata etherAmounts\\n    ) external payable returns (bool) {\\n        uint256 totalETHSent = 0;\\n        require(tos.length == tokenAmounts.length, \\\"TOKEN_NOT_SAME_LENGTH\\\");\\n        require(tos.length == etherAmounts.length, \\\"ETH_NOT_SAME_LENGTH\\\");\\n        for (uint256 i = 0; i < tos.length; i++) {\\n            if (tokenAmounts[i] != 0) {\\n                _transfer(msg.sender, tos[i], tokenAmounts[i]);\\n            }\\n            if (etherAmounts[i] != 0) {\\n                tos[i].transfer(etherAmounts[i]);\\n                totalETHSent += etherAmounts[i];\\n            }\\n        }\\n        require(msg.value == totalETHSent, \\\"INVALID_MSG_VALUE\\\");\\n        return true;\\n    }\\n\\n    function transferAndCall(\\n        address to,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bool) {\\n        _transfer(msg.sender, to, amount);\\n        return ITransferReceiver(to).onTokenTransfer(msg.sender, amount, data);\\n    }\\n\\n    function transferFromAndCall(\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bool) {\\n        _transferFrom(from, to, amount);\\n        return ITransferReceiver(to).onTokenTransfer(from, amount, data);\\n    }\\n\\n    function payForAndCall(\\n        address forAddress,\\n        address to,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bool) {\\n        _transfer(msg.sender, to, amount);\\n        return IPaidForReceiver(to).onTokenPaidFor(msg.sender, forAddress, amount, data);\\n    }\\n\\n    // TODO ?\\n    // function transferFromForAndCall(\\n    //     address forAddress,\\n    //     address from,\\n    //     address to,\\n    //     uint256 amount,\\n    //     bytes calldata data\\n    // ) external returns (bool) {\\n    //     _transferFrom(from, to, amount);\\n    //     return ITransferForReceiver(to).onTokenTransferFor(from, forAddress, amount, data);\\n    // }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external override returns (bool) {\\n        _transferFrom(from, to, amount);\\n        return true;\\n    }\\n\\n    function approve(address spender, uint256 amount) external override returns (bool) {\\n        // TODO support metatx ?\\n        _approveFor(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function approveAndCall(\\n        address spender,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bool) {\\n        _approveFor(msg.sender, spender, amount);\\n        return IApprovalReceiver(spender).onTokenApproval(msg.sender, amount, data);\\n    }\\n\\n    function _approveFor(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal override {\\n        require(owner != address(0) && spender != address(0), \\\"INVALID_ZERO_ADDRESS\\\");\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    function _transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        // anybody can transfer from this\\n        // this allow mintAndApprovedCall without gas overhead\\n        if (msg.sender != from && from != address(this)) {\\n            uint256 currentAllowance = _allowances[from][msg.sender];\\n            if (currentAllowance != Constants.UINT256_MAX) {\\n                // save gas when allowance is maximal by not reducing it (see https://github.com/ethereum/EIPs/issues/717)\\n                require(currentAllowance >= amount, \\\"NOT_AUTHOIZED_ALLOWANCE\\\");\\n                _allowances[from][msg.sender] = currentAllowance - amount;\\n            }\\n        }\\n        _transfer(from, to, amount);\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(to != address(0), \\\"INVALID_ZERO_ADDRESS\\\");\\n        require(to != address(this), \\\"INVALID_THIS_ADDRESS\\\");\\n        uint256 currentBalance = _balances[from];\\n        require(currentBalance >= amount, \\\"NOT_ENOUGH_TOKENS\\\");\\n        _balances[from] = currentBalance - amount;\\n        _balances[to] += amount;\\n        emit Transfer(from, to, amount);\\n    }\\n\\n    function _transferAllIfAny(address from, address to) internal {\\n        uint256 balanceLeft = _balances[from];\\n        if (balanceLeft > 0) {\\n            _balances[from] = 0;\\n            _balances[to] += balanceLeft;\\n            emit Transfer(from, to, balanceLeft);\\n        }\\n    }\\n\\n    function _mint(address to, uint256 amount) internal override {\\n        _totalSupply += amount;\\n        _balances[to] += amount;\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burnFrom(address from, uint256 amount) internal override {\\n        uint256 currentBalance = _balances[from];\\n        require(currentBalance >= amount, \\\"NOT_ENOUGH_TOKENS\\\");\\n        _balances[from] = currentBalance - amount;\\n        _totalSupply -= amount;\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\",\"keccak256\":\"0xa33bf9f40607c0c4c316c2027d8c0ec1bcf362c9f6c58844816552f304f25066\",\"license\":\"AGPL-3.0\"},\"src/base/erc20/WithPermitAndFixedDomain.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.9;\\n\\nimport \\\"./ERC20BaseInternal.sol\\\";\\nimport \\\"../../interfaces/IERC2612Standalone.sol\\\";\\n\\nabstract contract WithPermitAndFixedDomain is ERC20BaseInternal, IERC2612Standalone {\\n    bytes32 internal constant PERMIT_TYPEHASH =\\n        keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\n    bytes32 public immutable override DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) internal _nonces;\\n\\n    constructor(string memory version) {\\n        if (bytes(version).length == 0) {\\n            version = \\\"1\\\";\\n        }\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256(\\\"EIP712Domain(string name,string version,address verifyingContract)\\\"),\\n                keccak256(bytes(name())),\\n                keccak256(bytes(version)),\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    function nonces(address owner) external view override returns (uint256) {\\n        return _nonces[owner];\\n    }\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external override {\\n        require(owner != address(0), \\\"INVALID_ZERO_ADDRESS\\\");\\n\\n        uint256 currentNonce = _nonces[owner];\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR,\\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, currentNonce, deadline))\\n            )\\n        );\\n        require(owner == ecrecover(digest, v, r, s), \\\"INVALID_SIGNATURE\\\");\\n        require(deadline == 0 || block.timestamp <= deadline, \\\"TOO_LATE\\\");\\n\\n        _nonces[owner] = currentNonce + 1;\\n        _approveFor(owner, spender, value);\\n    }\\n}\\n\",\"keccak256\":\"0xf0b3d7c51a0b71477ef63eee5fa21ea9f32d424b40480ab3b5343a16a0e4afbc\",\"license\":\"AGPL-3.0\"},\"src/conquest_token/IFreePlayToken.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IFreePlayToken is IERC20 {\\n    function mintViaNativeToken(address to, uint256 amount) external payable;\\n\\n    function mintViaNativeTokenPlusSendExtraNativeTokens(address payable to, uint256 amount) external payable;\\n\\n    function mintMultipleViaNativeTokenPlusSendExtraNativeTokens(\\n        address payable[] calldata tos,\\n        uint256[] calldata amounts,\\n        uint256[] calldata nativeTokenAmounts\\n    ) external payable;\\n\\n    function mint(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external;\\n\\n    function burn(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external;\\n\\n    struct BurnFrom {\\n        address from;\\n        uint256 amount;\\n    }\\n\\n    function burnMultiple(BurnFrom[] calldata list, address to) external;\\n}\\n\",\"keccak256\":\"0x873abb11be35fec3bbe377aea68dfdcccc180058c7a7d268f3ed4f47dfaa04e2\",\"license\":\"AGPL-3.0\"},\"src/conquest_token/IReward.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.9;\\n\\ninterface IReward {\\n    function reward(address to, uint256 amount) external;\\n}\\n\",\"keccak256\":\"0x2ccdc4c0f0a5f63526316f0f0bc316aa5d9f1e59e8574a66e43e3f5a81e233f4\",\"license\":\"AGPL-3.0\"},\"src/conquest_token/PlayToken.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"../base/erc20/UsingERC20Base.sol\\\";\\nimport \\\"../base/erc20/WithPermitAndFixedDomain.sol\\\";\\nimport \\\"hardhat-deploy/solc_0.8/proxy/Proxied.sol\\\";\\n\\ninterface SavingsXDaiAdapter {\\n    function depositXDAI(address receiver) external payable returns (uint256);\\n\\n    function withdrawXDAI(uint256 assets, address receiver) external payable returns (uint256);\\n}\\n\\ninterface SDAI is IERC20 {\\n    function deposit(uint256 assets, address receiver) external returns (uint256);\\n\\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256);\\n\\n    function maxWithdraw(address owner) external view returns (uint256);\\n}\\n\\ncontract PlayToken is UsingERC20Base, WithPermitAndFixedDomain, Proxied {\\n    uint256 internal constant DECIMALS_18 = 1000000000000000000;\\n    uint256 public immutable numTokensPerNativeTokenAt18Decimals;\\n\\n    SavingsXDaiAdapter public immutable sdaiAdapter;\\n    SDAI public immutable sdai;\\n\\n    constructor(\\n        address initialRedeemer,\\n        uint256 _numTokensPerNativeTokenAt18Decimals,\\n        SDAI _sdai,\\n        SavingsXDaiAdapter _sdaiAdapter\\n    ) WithPermitAndFixedDomain(\\\"1\\\") {\\n        numTokensPerNativeTokenAt18Decimals = _numTokensPerNativeTokenAt18Decimals;\\n        sdai = _sdai;\\n        sdaiAdapter = _sdaiAdapter;\\n        _postUpgrade(initialRedeemer, numTokensPerNativeTokenAt18Decimals, _sdai, _sdaiAdapter);\\n    }\\n\\n    function postUpgrade(\\n        address initialRedeemer,\\n        uint256 _numTokensPerNativeTokenAt18Decimals,\\n        SDAI _sdai,\\n        SavingsXDaiAdapter _sdaiAdapter\\n    ) external onlyProxyAdmin {\\n        _postUpgrade(initialRedeemer, _numTokensPerNativeTokenAt18Decimals, _sdai, _sdaiAdapter);\\n    }\\n\\n    function _postUpgrade(address initialRedeemer, uint256, SDAI, SavingsXDaiAdapter) internal {\\n        if (_redeemer() != initialRedeemer) {\\n            assembly {\\n                // keccak256(\\\"play.redeemer\\\") - 1\\n                sstore(0xa38643e3ed511bdab6502b0aaa1583180356304eba44dc9c3bbd0d9bf66e67f9, initialRedeemer)\\n            }\\n            emit Redeemer(initialRedeemer);\\n        }\\n\\n        if (address(sdai) != address(0) && address(sdaiAdapter) != address(0)) {\\n            sdai.approve(address(sdaiAdapter), type(uint256).max);\\n            uint256 xdaiAmount = address(this).balance;\\n            sdaiAdapter.depositXDAI{value: xdaiAmount}(address(this));\\n        }\\n    }\\n\\n    string public constant symbol = \\\"PLAY\\\";\\n\\n    function name() public pure override returns (string memory) {\\n        return \\\"Play\\\";\\n    }\\n\\n    function mint(address to, uint256 amount) external payable {\\n        uint256 xdaiAmount = msg.value;\\n        require((xdaiAmount * numTokensPerNativeTokenAt18Decimals) / DECIMALS_18 == amount, \\\"INVALID_AMOUNT\\\");\\n\\n        if (address(sdai) != address(0) && address(sdaiAdapter) != address(0)) {\\n            sdaiAdapter.depositXDAI{value: xdaiAmount}(address(this));\\n        }\\n\\n        _mint(to, amount);\\n    }\\n\\n    function burn(address payable to, uint256 amount) external {\\n        _burnFrom(msg.sender, amount);\\n        uint256 xDaiAmount = (amount * DECIMALS_18) / numTokensPerNativeTokenAt18Decimals;\\n\\n        if (address(sdai) != address(0) && address(sdaiAdapter) != address(0)) {\\n            sdaiAdapter.withdrawXDAI(xDaiAmount, to);\\n        } else {\\n            to.transfer(xDaiAmount);\\n        }\\n    }\\n\\n    function redeemInterest(address payable to) external returns (uint256) {\\n        require(msg.sender == _redeemer(), \\\"NOT_AUTHORIZED\\\");\\n        if (address(sdai) != address(0) && address(sdaiAdapter) != address(0)) {\\n            uint256 expectedTotalAmount = (_totalSupply * DECIMALS_18) / numTokensPerNativeTokenAt18Decimals;\\n\\n            uint256 maxXDaiAmount = sdai.maxWithdraw(address(this));\\n            if (maxXDaiAmount > expectedTotalAmount) {\\n                uint256 totalToWithdraw = maxXDaiAmount - expectedTotalAmount;\\n                sdaiAdapter.withdrawXDAI(totalToWithdraw, to);\\n                return totalToWithdraw;\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    function interestAvailableToRedeem() external view returns (uint256) {\\n        if (address(sdai) != address(0) && address(sdaiAdapter) != address(0)) {\\n            uint256 expectedTotalAmount = (_totalSupply * DECIMALS_18) / numTokensPerNativeTokenAt18Decimals;\\n            uint256 maxXDaiAmount = sdai.maxWithdraw(address(this));\\n            if (maxXDaiAmount > expectedTotalAmount) {\\n                uint256 totalToWithdraw = maxXDaiAmount - expectedTotalAmount;\\n                return totalToWithdraw;\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    event Redeemer(address newRedeemer);\\n\\n    function _redeemer() internal view returns (address redeemerAddress) {\\n        assembly {\\n            // keccak256(\\\"play.redeemer\\\") - 1\\n            redeemerAddress := sload(0xa38643e3ed511bdab6502b0aaa1583180356304eba44dc9c3bbd0d9bf66e67f9)\\n        }\\n    }\\n\\n    function setRedeemer(address newRedeemer) external {\\n        require(msg.sender == _redeemer(), \\\"NOT_AUTHORIZED\\\");\\n        assembly {\\n            // keccak256(\\\"play.redeemer\\\") - 1\\n            sstore(0xa38643e3ed511bdab6502b0aaa1583180356304eba44dc9c3bbd0d9bf66e67f9, newRedeemer)\\n        }\\n        emit Redeemer(newRedeemer);\\n    }\\n}\\n\",\"keccak256\":\"0x0923174c3ef44fb84d4c9ebf84ab274e1c393b8555fcfdcc4a814eec6ed858f7\",\"license\":\"AGPL-3.0\"},\"src/conquest_token/RewardsGenerator.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"hardhat-deploy/solc_0.8/proxy/Proxied.sol\\\";\\nimport \\\"../outerspace/interfaces/IOnStakeChange.sol\\\";\\nimport \\\"./IReward.sol\\\";\\n\\ncontract RewardsGenerator is IERC20, Proxied, IOnStakeChange {\\n    uint256 internal constant PRECISION = 1e24;\\n    uint256 internal constant DECIMALS_18_MILLIONTH = 1000000000000; // 1 millionth of a token so that it matches with REWARD_RATE_millionth\\n\\n    uint256 public immutable REWARD_RATE_millionth;\\n    uint256 public immutable FIXED_REWARD_RATE_thousands_millionth;\\n\\n    event GameEnabled(address indexed game, uint256 weight, uint256 timestamp);\\n\\n    struct GlobalState {\\n        uint40 lastUpdateTime;\\n        uint104 totalRewardPerPointAtLastUpdate; // PRECISION = 1e24\\n        uint112 totalPoints;\\n    }\\n    GlobalState _global;\\n\\n    struct SharedRatePerAccount {\\n        uint112 points;\\n        uint104 totalRewardPerPointAccounted; // PRECISION = 1e24\\n        // we do not pack here as we want to keep precision\\n        uint112 rewardsToWithdraw;\\n    }\\n\\n    mapping(address => SharedRatePerAccount) _sharedRateRewardPerAccount;\\n\\n    struct FixedRate {\\n        uint112 toWithdraw;\\n        uint40 lastTime;\\n    }\\n    mapping(address => FixedRate) internal _fixedRateRewardPerAccount;\\n\\n    mapping(address => uint256) internal _games;\\n\\n    IReward public immutable reward;\\n\\n    struct Config {\\n        uint256 rewardRateMillionth;\\n        uint256 fixedRewardRateThousandsMillionth;\\n    }\\n\\n    struct InitialAccount {\\n        address account;\\n        uint256 amount;\\n    }\\n\\n    bool internal _init;\\n\\n    constructor(\\n        IReward rewardAddress,\\n        Config memory config,\\n        address[] memory initialGames,\\n        InitialAccount[] memory initialAccounts\\n    ) {\\n        reward = rewardAddress;\\n        REWARD_RATE_millionth = config.rewardRateMillionth;\\n        FIXED_REWARD_RATE_thousands_millionth = config.fixedRewardRateThousandsMillionth;\\n\\n        _postUpgrade(rewardAddress, config, initialGames, initialAccounts);\\n    }\\n\\n    function postUpgrade(\\n        IReward rewardAddress,\\n        Config memory config,\\n        address[] memory initialGames,\\n        InitialAccount[] memory initialAccounts\\n    ) external onlyProxyAdmin {\\n        _postUpgrade(rewardAddress, config, initialGames, initialAccounts);\\n    }\\n\\n    function _postUpgrade(\\n        IReward,\\n        Config memory,\\n        address[] memory initialGames,\\n        InitialAccount[] memory initialAccounts\\n    ) internal {\\n        if (!_init) {\\n            for (uint256 i = 0; i < initialGames.length; i++) {\\n                _enableGame(initialGames[i], 1000000000000000000);\\n            }\\n            for (uint256 i = 0; i < initialAccounts.length; i++) {\\n                _add(initialAccounts[i].account, initialAccounts[i].amount);\\n            }\\n            _init = true;\\n        }\\n    }\\n\\n    string public constant symbol = \\\"POINT\\\";\\n\\n    function name() public pure returns (string memory) {\\n        return \\\"Conquest v0 Points\\\";\\n    }\\n\\n    function enableGame(address game, uint256 weight) external onlyProxyAdmin {\\n        _enableGame(game, weight);\\n    }\\n\\n    function _enableGame(address game, uint256 weight) internal {\\n        _games[game] = weight;\\n        emit GameEnabled(game, weight, block.timestamp);\\n    }\\n\\n    /// @inheritdoc IOnStakeChange\\n    function add(address account, uint256 amount) external override onlyGames {\\n        _add(account, amount);\\n    }\\n\\n    function _add(address account, uint256 amount) internal {\\n        if (amount == 0) {\\n            return;\\n        }\\n\\n        (uint256 totalPointsSoFar, uint256 accountPointsSoFar) = _update(account);\\n\\n        unchecked {\\n            // update total points and the account's point, their reward will be counted on next interaction.\\n            _global.totalPoints = uint112(totalPointsSoFar + amount);\\n            _sharedRateRewardPerAccount[account].points = uint112(accountPointsSoFar + amount);\\n        }\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /// @inheritdoc IOnStakeChange\\n    function remove(address account, uint256 amount) external override onlyGames {\\n        _remove(account, amount);\\n    }\\n\\n    function _remove(address account, uint256 amount) internal {\\n        if (amount == 0) {\\n            return;\\n        }\\n\\n        // update the amount generated, store it in\\n        (uint256 totalPointsSoFar, uint256 accountPointsSoFar) = _update(account);\\n\\n        unchecked {\\n            // update total points and the account's point, their reward will be counted on next interaction.\\n            _global.totalPoints = uint112(totalPointsSoFar - amount);\\n            _sharedRateRewardPerAccount[account].points = uint112(accountPointsSoFar - amount);\\n        }\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /// @inheritdoc IOnStakeChange\\n    function move(address from, address to, uint256 amount) external override onlyGames {\\n        _remove(from, amount);\\n        _add(to, amount);\\n    }\\n\\n    function totalSupply() external view override returns (uint256) {\\n        return _global.totalPoints;\\n    }\\n\\n    function balanceOf(address owner) external view override returns (uint256) {\\n        return _sharedRateRewardPerAccount[owner].points;\\n    }\\n\\n    function allowance(address, address) external pure override returns (uint256) {\\n        return 0;\\n    }\\n\\n    function decimals() external pure virtual returns (uint8) {\\n        return uint8(18);\\n    }\\n\\n    function transfer(address, uint256) external returns (bool) {\\n        revert(\\\"NON_TRANSFERABLE\\\");\\n    }\\n\\n    function approve(address, uint256) external returns (bool) {\\n        revert(\\\"NON_TRANSFERABLE\\\");\\n    }\\n\\n    function transferFrom(address, address, uint256) external returns (bool) {\\n        revert(\\\"NON_TRANSFERABLE\\\");\\n    }\\n\\n    /// @notice update the global pool rate\\n    function update() external {\\n        _updateGlobal();\\n    }\\n\\n    function lastUpdated() external view returns (uint256) {\\n        return _global.lastUpdateTime;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------------------------------\\n    // For Accounts\\n    // ---------------------------------------------------------------------------------------------------------------\\n\\n    /// @notice claim the rewards earned so far in the shared pool\\n    function claimSharedPoolRewards(address to) external {\\n        address account = msg.sender;\\n        uint256 accountPointsSoFar = _sharedRateRewardPerAccount[account].points;\\n\\n        (, uint256 totalRewardPerPoint) = _updateGlobal();\\n        uint256 amount = _computeRewardsEarned(\\n            _sharedRateRewardPerAccount[account].totalRewardPerPointAccounted,\\n            accountPointsSoFar,\\n            totalRewardPerPoint,\\n            _sharedRateRewardPerAccount[account].rewardsToWithdraw\\n        );\\n        _sharedRateRewardPerAccount[account].totalRewardPerPointAccounted = uint104(totalRewardPerPoint);\\n\\n        if (amount > 0) {\\n            _sharedRateRewardPerAccount[account].rewardsToWithdraw = 0;\\n            reward.reward(to, amount);\\n        }\\n    }\\n\\n    /// @notice claim the rewards earned so far using a fixed rate per point\\n    function claimFixedRewards(address to) external {\\n        address account = msg.sender;\\n        uint256 amount = earnedFromFixedRate(account);\\n        if (amount > 0) {\\n            _fixedRateRewardPerAccount[account].lastTime = uint40(block.timestamp);\\n            _fixedRateRewardPerAccount[account].toWithdraw = 0;\\n            reward.reward(to, amount);\\n        }\\n    }\\n\\n    // ---------------------------------------------------------------------------------------------------------------\\n    // Getters\\n    // ---------------------------------------------------------------------------------------------------------------\\n\\n    /// @notice The amount of reward each point has earned so far\\n    function getTotalRewardPerPointWithPrecision24() external view returns (uint256) {\\n        return\\n            _global.totalRewardPerPointAtLastUpdate +\\n            _computeExtraTotalRewardPerPointSinceLastTime(\\n                _global.totalPoints,\\n                REWARD_RATE_millionth,\\n                _global.lastUpdateTime\\n            );\\n    }\\n\\n    /// @notice The amount of reward an account has accrued so far. Does not include already withdrawn rewards.\\n    function earnedFromPoolRate(address account) external view returns (uint256) {\\n        return\\n            _computeRewardsEarned(\\n                _sharedRateRewardPerAccount[account].totalRewardPerPointAccounted,\\n                _sharedRateRewardPerAccount[account].points,\\n                _global.totalRewardPerPointAtLastUpdate +\\n                    _computeExtraTotalRewardPerPointSinceLastTime(\\n                        _global.totalPoints,\\n                        REWARD_RATE_millionth,\\n                        _global.lastUpdateTime\\n                    ),\\n                _sharedRateRewardPerAccount[account].rewardsToWithdraw\\n            );\\n    }\\n\\n    /// @notice The amount of reward an account has accrued so far. Does not include already withdrawn rewards.\\n    function earnedFromFixedRate(address account) public view returns (uint256) {\\n        uint256 extraFixed = ((block.timestamp - _fixedRateRewardPerAccount[account].lastTime) *\\n            _sharedRateRewardPerAccount[account].points *\\n            FIXED_REWARD_RATE_thousands_millionth) / 1000000000;\\n        return extraFixed + _fixedRateRewardPerAccount[account].toWithdraw;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------------------------------\\n    // Internal\\n    // ---------------------------------------------------------------------------------------------------------------\\n\\n    function _computeRewardsEarned(\\n        uint256 totalRewardPerPointAccountedSoFar,\\n        uint256 accountPoints,\\n        uint256 currentTotalRewardPerPoint,\\n        uint256 accountRewardsSoFar\\n    ) internal pure returns (uint256) {\\n        return\\n            accountRewardsSoFar +\\n            (((accountPoints * (currentTotalRewardPerPoint - totalRewardPerPointAccountedSoFar)) *\\n                DECIMALS_18_MILLIONTH) / PRECISION);\\n    }\\n\\n    function _computeExtraTotalRewardPerPointSinceLastTime(\\n        uint256 totalPoints,\\n        uint256 rewardRateMillionth,\\n        uint256 lastUpdateTime\\n    ) internal view returns (uint256) {\\n        if (totalPoints == 0) {\\n            return 0;\\n        }\\n        return ((block.timestamp - lastUpdateTime) * rewardRateMillionth * PRECISION) / totalPoints;\\n    }\\n\\n    function _updateGlobal() internal returns (uint256 totalPointsSoFar, uint256 totalRewardPerPointAllocatedSoFar) {\\n        totalPointsSoFar = _global.totalPoints;\\n\\n        uint256 extraTotalRewardPerPoint = _computeExtraTotalRewardPerPointSinceLastTime(\\n            totalPointsSoFar,\\n            REWARD_RATE_millionth,\\n            _global.lastUpdateTime\\n        );\\n\\n        totalRewardPerPointAllocatedSoFar = _global.totalRewardPerPointAtLastUpdate + extraTotalRewardPerPoint;\\n\\n        _global.totalRewardPerPointAtLastUpdate = uint104(totalRewardPerPointAllocatedSoFar);\\n        _global.lastUpdateTime = uint40(block.timestamp);\\n    }\\n\\n    function _updateAccount(\\n        address account,\\n        uint256 totalRewardPerPointAllocatedSoFar\\n    ) internal returns (uint256 accountPointsSoFar) {\\n        accountPointsSoFar = _sharedRateRewardPerAccount[account].points;\\n\\n        // update the reward that can be withdrawn, catching up account state to global\\n        _sharedRateRewardPerAccount[account].rewardsToWithdraw = uint112(\\n            _computeRewardsEarned(\\n                // last checkpoint : when was the account last updated\\n                _sharedRateRewardPerAccount[account].totalRewardPerPointAccounted,\\n                accountPointsSoFar,\\n                totalRewardPerPointAllocatedSoFar,\\n                // rewards already registered\\n                _sharedRateRewardPerAccount[account].rewardsToWithdraw\\n            )\\n        );\\n        _sharedRateRewardPerAccount[account].totalRewardPerPointAccounted = uint104(totalRewardPerPointAllocatedSoFar);\\n\\n        uint256 extraFixed = ((block.timestamp - _fixedRateRewardPerAccount[account].lastTime) *\\n            accountPointsSoFar *\\n            FIXED_REWARD_RATE_thousands_millionth) / 1000000000;\\n        _fixedRateRewardPerAccount[account].lastTime = uint40(block.timestamp);\\n        _fixedRateRewardPerAccount[account].toWithdraw += uint112(extraFixed);\\n    }\\n\\n    function _update(address account) internal returns (uint256, uint256) {\\n        (uint256 totalPointsSoFar, uint256 totalRewardPerPointAllocatedSoFar) = _updateGlobal();\\n        uint256 accountPointsSoFar = _updateAccount(account, totalRewardPerPointAllocatedSoFar);\\n        return (totalPointsSoFar, accountPointsSoFar);\\n    }\\n\\n    // ---------------------------------------------------------------------------------------------------------------\\n    // Modifiers\\n    // ---------------------------------------------------------------------------------------------------------------\\n\\n    modifier onlyGames() {\\n        require(_games[msg.sender] > 0, \\\"NOT_AUTHORIZED_GAME\\\");\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x4ad437bd74233dcc3dc8f94864428d93e9087ca9a1b7630bd4efafdeb705923a\",\"license\":\"AGPL-3.0\"},\"src/interfaces/IAlliance.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity 0.8.9;\\n\\ninterface IAlliance {\\n    function requestToJoin(address player, bytes calldata data) external returns (bool);\\n\\n    function playerHasLeft(address player) external;\\n}\\n\",\"keccak256\":\"0x56331cf35f0c52161d22a1094809e4e55b6be6dff3f7c18a3070b325e1afced8\",\"license\":\"AGPL-3.0\"},\"src/interfaces/IERC2612Standalone.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity 0.8.9;\\n\\ninterface IERC2612Standalone {\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x98537db7e0bc17ff1c0676d75f2a00c4e95c38cec97510c4778aa98449e7dd45\",\"license\":\"AGPL-3.0\"},\"src/libraries/Constants.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity 0.8.9;\\n\\nlibrary Constants {\\n    uint256 internal constant UINT256_MAX = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n    uint256 internal constant DECIMALS_18 = 1000000000000000000;\\n    uint256 internal constant DECIMALS_14 = 100000000000000;\\n}\\n\",\"keccak256\":\"0x90c9efbfce3d12774196ae69984a23431b94307e71aa4d44e6a96ca3edf901ef\",\"license\":\"AGPL-3.0\"},\"src/libraries/Extraction.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity 0.8.9;\\n\\n// TODO remove\\nimport \\\"hardhat/console.sol\\\";\\n\\nlibrary Extraction {\\n    function value(\\n        bytes32 data,\\n        uint8 leastSignificantBit,\\n        uint8 size\\n    ) internal pure returns (uint256) {\\n        return uint256((data >> leastSignificantBit)) % 2**size;\\n    }\\n\\n    function value8Mod(\\n        bytes32 data,\\n        uint8 leastSignificantBit,\\n        uint8 mod\\n    ) internal pure returns (uint8) {\\n        return uint8(uint256((data >> leastSignificantBit)) % mod);\\n    }\\n\\n    function value8(bytes32 data, uint8 leastSignificantBit) internal pure returns (uint8) {\\n        return uint8(uint256((data >> leastSignificantBit)) % 2**8);\\n    }\\n\\n    // 1+1+2+3+4+6+7+8+8+7+6+4+3+2+1+1 // aproximation of normal distribution with mean=7.5 and standard deviation=3 for 16 values\\n    bytes32 constant n_m7_5_sd3 = 0x01223334444555555666666677777777888888889999999AAAAAABBBBCCCDDEF;\\n\\n    function normal8(bytes32 data, uint8 leastSignificantBit) internal pure returns (uint8) {\\n        uint8 index = value8Mod(data, leastSignificantBit, 64);\\n        uint8 first = index / 2;\\n        uint8 second = index % 2;\\n        uint8 slot = uint8(n_m7_5_sd3[first]);\\n        if (second == 0) {\\n            return slot >> 4;\\n        } else {\\n            return slot % 16;\\n        }\\n    }\\n\\n    function normal16(\\n        bytes32 data,\\n        uint8 leastSignificantBit,\\n        bytes32 selection\\n    ) internal pure returns (uint16) {\\n        uint8 index = normal8(data, leastSignificantBit);\\n        return uint16(uint8(selection[index * 2])) * 2**8 + uint16(uint8(selection[index * 2 + 1]));\\n    }\\n}\\n\",\"keccak256\":\"0x4264ffbd03c4be49f317ed019abbe0594051606df36e7a707d74456b49130c86\",\"license\":\"AGPL-3.0\"},\"src/libraries/Math.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity 0.8.9;\\n\\nlibrary Math {\\n    function mul(\\n        uint256 a,\\n        uint256 b,\\n        string memory overflowError\\n    ) internal pure returns (uint256 c) {\\n        require(b == 0 || a == 0 || ((c = a * b) / b) == a, overflowError);\\n    }\\n\\n    function add(\\n        uint256 a,\\n        uint256 b,\\n        string memory overflowError\\n    ) internal pure returns (uint256 c) {\\n        require((c = a + b) >= a, overflowError);\\n    }\\n\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory underflowError\\n    ) internal pure returns (uint256 c) {\\n        require((c = a - b) <= a, underflowError);\\n    }\\n\\n    function mul18(\\n        uint256 a18,\\n        uint256 b18,\\n        string memory overflowError\\n    ) internal pure returns (uint256) {\\n        return mul(a18, b18, overflowError) / 10**18;\\n    }\\n\\n    function div18(\\n        uint256 a18,\\n        uint256 b18,\\n        string memory overflowError\\n    ) internal pure returns (uint256) {\\n        return mul(a18, 10**18, overflowError) / b18;\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a <= b ? a : b;\\n    }\\n\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    function smin(int256 a, int256 b) internal pure returns (int256) {\\n        return a <= b ? a : b;\\n    }\\n\\n    function smax(int256 a, int256 b) internal pure returns (int256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    function sqrt(uint256 a) internal pure returns (uint256 c) {\\n        uint256 tmp = (a + 1) / 2;\\n        c = a;\\n        while (tmp < c) {\\n            c = tmp;\\n            tmp = ((a / tmp) + tmp) / 2;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa2d7dff3199295e64e0b6361f8533fb093bfdbd6a60154cadd1d4f6619281260\",\"license\":\"AGPL-3.0\"},\"src/outerspace/base/ImportingOuterSpaceConstants.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.9;\\n\\ncontract ImportingOuterSpaceConstants {\\n    uint256 internal constant DECIMALS_18 = 1e18;\\n    uint256 internal constant DECIMALS_14 = 1e14;\\n    uint32 internal constant ACTIVE_MASK = 2**31;\\n    int256 internal constant UINT32_MAX = 2**32 - 1;\\n    int256 internal constant UINT32_MIN = -2147483648;\\n}\\n\",\"keccak256\":\"0x3b5937f8eb83cb02cdffc9935c6ae11a890489aaf80c1bf447295bf28c909e38\",\"license\":\"AGPL-3.0\"},\"src/outerspace/base/UsingOuterSpaceDataLayout.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.9;\\n\\nimport \\\"../types/ImportingOuterSpaceTypes.sol\\\";\\n\\ncontract UsingOuterSpaceDataLayout is ImportingOuterSpaceTypes {\\n    mapping(uint256 => Planet) internal _planets;\\n    mapping(uint256 => Fleet) internal _fleets;\\n\\n    mapping(address => uint256) internal _stakeReadyToBeWithdrawn;\\n\\n    mapping(address => mapping(address => bool)) internal _operators;\\n\\n    // Note: make it namespaces per user, currently it is possible (though unlikely) for 2 users to share a slot if one attack another and quickly send away spaceships\\n    mapping(uint256 => mapping(uint256 => InFlight)) internal _inFlight;\\n\\n    Discovered internal _discovered;\\n    // rewards\\n    mapping(address => uint256) internal _prevRewardIds;\\n    mapping(uint256 => uint256) internal _rewards;\\n    mapping(address => mapping(uint256 => bool)) internal _rewardsToWithdraw;\\n\\n    // This adds 20,000 gas to all resolution\\n    mapping(uint256 => mapping(address => mapping(uint256 => AccumulatedAttack))) internal _attacks;\\n\\n    mapping(address => uint256) internal _freeStakeReadyToBeWithdrawn;\\n    mapping(uint256 => uint256) internal _planetFlagged;\\n}\\n\",\"keccak256\":\"0xc021f1439a1066151e9862c99c2a6687eb9caf7cb9cc10ac6a4f12248718f0fd\",\"license\":\"AGPL-3.0\"},\"src/outerspace/events/ImportingOuterSpaceEvents.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.9;\\n\\ninterface ImportingOuterSpaceEvents {\\n    event BlockTime(uint256 block, uint256 timestamp);\\n    event PlanetStake(\\n        address indexed acquirer,\\n        uint256 indexed location,\\n        uint32 numSpaceships,\\n        int40 travelingUpkeep,\\n        uint32 overflow,\\n        uint256 stake,\\n        bool freegift\\n    );\\n    event FleetSent(\\n        address indexed fleetSender,\\n        address indexed fleetOwner,\\n        uint256 indexed from,\\n        address operator,\\n        uint256 fleet,\\n        uint32 quantity,\\n        uint32 newNumSpaceships,\\n        int40 newTravelingUpkeep,\\n        uint32 newOverflow\\n    );\\n\\n    event FleetRevealed(\\n        uint256 indexed fleetId,\\n        uint256 indexed from,\\n        uint256 indexed to,\\n        uint256 arrivalTimeWanted,\\n        bool gift,\\n        address specific,\\n        bytes32 secret,\\n        address fleetSender,\\n        address operator\\n    );\\n\\n    struct ArrivalData {\\n        uint32 newNumspaceships;\\n        int40 newTravelingUpkeep;\\n        uint32 newOverflow;\\n        uint32 numSpaceshipsAtArrival;\\n        uint32 taxLoss;\\n        uint32 fleetLoss;\\n        uint32 planetLoss;\\n        uint32 inFlightFleetLoss;\\n        uint32 inFlightPlanetLoss;\\n        uint32 accumulatedDefenseAdded;\\n        uint32 accumulatedAttackAdded;\\n    }\\n\\n    event FleetArrived(\\n        uint256 indexed fleet,\\n        address indexed fleetOwner,\\n        address indexed destinationOwner,\\n        uint256 destination,\\n        bool gift,\\n        bool won,\\n        ArrivalData data\\n    );\\n\\n    event TravelingUpkeepRefund(\\n        uint256 indexed origin,\\n        uint256 indexed fleet,\\n        uint32 newNumspaceships,\\n        int40 newTravelingUpkeep,\\n        uint32 newOverflow\\n    );\\n\\n    event PlanetTransfer(\\n        address indexed previousOwner,\\n        address indexed newOwner,\\n        uint256 indexed location,\\n        uint32 newNumspaceships,\\n        int40 newTravelingUpkeep,\\n        uint32 newOverflow\\n    );\\n\\n    event PlanetReset(uint256 indexed location);\\n\\n    event PlanetExit(address indexed owner, uint256 indexed location);\\n\\n    event ExitComplete(address indexed owner, uint256 indexed location, uint256 stake);\\n\\n    event RewardSetup(uint256 indexed location, address indexed giver, uint256 rewardId);\\n    event RewardToWithdraw(address indexed owner, uint256 indexed location, uint256 indexed rewardId);\\n\\n    event StakeToWithdraw(address indexed owner, uint256 newStake, bool freegift);\\n\\n    event Initialized(\\n        bytes32 genesis,\\n        uint256 resolveWindow,\\n        uint256 timePerDistance,\\n        uint256 exitDuration,\\n        uint32 acquireNumSpaceships,\\n        uint32 productionSpeedUp,\\n        uint256 frontrunningDelay,\\n        uint256 productionCapAsDuration,\\n        uint256 upkeepProductionDecreaseRatePer10000th,\\n        uint256 fleetSizeFactor6,\\n        uint32 initialSpaceExpansion,\\n        uint32 expansionDelta,\\n        uint256 giftTaxPer10000\\n    );\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed location);\\n\\n    event GeneratorChanged(address newGenerator);\\n    event GeneratorAdminChanged(address newGeneratorAdmin);\\n}\\n\",\"keccak256\":\"0xb82b6a910ace0da1aa8738a7eae1ed168051279e1a7c12de397e9d1a3a771e3c\",\"license\":\"AGPL-3.0\"},\"src/outerspace/facets/OuterSpaceFacetBase.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.9;\\n\\nimport \\\"../types/ImportingOuterSpaceTypes.sol\\\";\\nimport \\\"../base/ImportingOuterSpaceConstants.sol\\\";\\nimport \\\"../events/ImportingOuterSpaceEvents.sol\\\";\\nimport \\\"../base/UsingOuterSpaceDataLayout.sol\\\";\\n\\nimport \\\"../../libraries/Extraction.sol\\\";\\nimport \\\"../../libraries/Math.sol\\\";\\n\\nimport \\\"../../interfaces/IAlliance.sol\\\";\\nimport \\\"../../alliances/AllianceRegistry.sol\\\";\\n\\nimport \\\"../../conquest_token/IFreePlayToken.sol\\\";\\n\\ninterface StakingToken is IERC20 {\\n    function mint(address to, uint256 amount) external payable;\\n}\\n\\ncontract OuterSpaceFacetBase is\\n    ImportingOuterSpaceTypes,\\n    ImportingOuterSpaceConstants,\\n    ImportingOuterSpaceEvents,\\n    UsingOuterSpaceDataLayout\\n{\\n    using Extraction for bytes32;\\n\\n    StakingToken internal immutable _stakingToken;\\n    IFreePlayToken internal immutable _freeStakingToken;\\n    AllianceRegistry internal immutable _allianceRegistry;\\n\\n    bytes32 internal immutable _genesis;\\n    uint256 internal immutable _resolveWindow;\\n    uint256 internal immutable _timePerDistance;\\n    uint256 internal immutable _exitDuration;\\n    uint32 internal immutable _acquireNumSpaceships; // TODO use uint256\\n    uint32 internal immutable _productionSpeedUp; // TODO use uint256\\n    uint256 internal immutable _frontrunningDelay;\\n    uint256 internal immutable _productionCapAsDuration;\\n    uint256 internal immutable _upkeepProductionDecreaseRatePer10000th;\\n    uint256 internal immutable _fleetSizeFactor6;\\n    uint32 internal immutable _initialSpaceExpansion; // = 16;\\n    uint32 internal immutable _expansionDelta; // = 8;  // TODO use uint256\\n    uint256 internal immutable _giftTaxPer10000; // = 2500;\\n    // // 4,5,5,10,10,15,15, 20, 20, 30,30,40,40,80,80,100\\n    // bytes32 constant stakeRange = 0x000400050005000A000A000F000F00140014001E001E00280028005000500064;\\n    // 6, 8, 10, 12, 14, 16, 18, 20, 20, 22, 24, 32, 40, 48, 56, 72\\n    // bytes32 internal constant stakeRange = 0x00060008000A000C000E00100012001400140016001800200028003000380048;\\n    bytes32 internal immutable _stakeRange;\\n    uint256 internal immutable _stakeMultiplier10000th;\\n    uint256 internal immutable _bootstrapSessionEndTime;\\n    uint256 internal immutable _infinityStartTime;\\n\\n    struct Config {\\n        StakingToken stakingToken;\\n        IFreePlayToken freeStakingToken;\\n        AllianceRegistry allianceRegistry;\\n        bytes32 genesis;\\n        uint256 resolveWindow;\\n        uint256 timePerDistance;\\n        uint256 exitDuration;\\n        uint32 acquireNumSpaceships;\\n        uint32 productionSpeedUp;\\n        uint256 frontrunningDelay;\\n        uint256 productionCapAsDuration;\\n        uint256 upkeepProductionDecreaseRatePer10000th;\\n        uint256 fleetSizeFactor6;\\n        uint32 initialSpaceExpansion;\\n        uint32 expansionDelta;\\n        uint256 giftTaxPer10000;\\n        bytes32 stakeRange;\\n        uint256 stakeMultiplier10000th;\\n        uint256 bootstrapSessionEndTime;\\n        uint256 infinityStartTime;\\n    }\\n\\n    constructor(Config memory config) {\\n        uint32 t = uint32(config.timePerDistance) / 4; // the coordinates space is 4 times bigger\\n        require(t * 4 == config.timePerDistance, \\\"TIME_PER_DIST_NOT_DIVISIBLE_4\\\");\\n\\n        _stakingToken = config.stakingToken;\\n        _freeStakingToken = config.freeStakingToken;\\n        _allianceRegistry = config.allianceRegistry;\\n\\n        _genesis = config.genesis;\\n        _resolveWindow = config.resolveWindow;\\n        _timePerDistance = t;\\n        _exitDuration = config.exitDuration;\\n        _acquireNumSpaceships = config.acquireNumSpaceships;\\n        _productionSpeedUp = config.productionSpeedUp;\\n        _frontrunningDelay = config.frontrunningDelay;\\n        _productionCapAsDuration = config.productionCapAsDuration;\\n        _upkeepProductionDecreaseRatePer10000th = config.upkeepProductionDecreaseRatePer10000th;\\n        _fleetSizeFactor6 = config.fleetSizeFactor6;\\n        _initialSpaceExpansion = config.initialSpaceExpansion;\\n        _expansionDelta = config.expansionDelta;\\n        _giftTaxPer10000 = config.giftTaxPer10000;\\n        _stakeRange = config.stakeRange;\\n        _stakeMultiplier10000th = config.stakeMultiplier10000th;\\n        _bootstrapSessionEndTime = config.bootstrapSessionEndTime;\\n        _infinityStartTime = config.infinityStartTime;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------------------------------\\n    // PLANET STATE\\n    // ---------------------------------------------------------------------------------------------------------------\\n\\n    struct PlanetUpdateState {\\n        uint256 location;\\n        uint40 lastUpdated;\\n        bool active; // modified\\n        uint32 numSpaceships; // modified\\n        int40 travelingUpkeep; // modified\\n        uint40 exitStartTime;\\n        uint40 newExitStartTime; // modified\\n        uint32 overflow; // modified\\n        address owner;\\n        address newOwner; // modified\\n        bytes32 data;\\n        uint24 futureExtraProduction;\\n    }\\n\\n    function _createPlanetUpdateState(\\n        Planet memory planet,\\n        uint256 location\\n    ) internal view returns (PlanetUpdateState memory planetUpdate) {\\n        (bool active, uint32 currentNumSpaceships) = _activeNumSpaceships(planet.numSpaceships);\\n        planetUpdate.location = location;\\n        planetUpdate.lastUpdated = planet.lastUpdated;\\n        planetUpdate.active = active;\\n        planetUpdate.numSpaceships = currentNumSpaceships;\\n        planetUpdate.travelingUpkeep = planet.travelingUpkeep;\\n        planetUpdate.exitStartTime = planet.exitStartTime;\\n        planetUpdate.newExitStartTime = planet.exitStartTime;\\n        planetUpdate.overflow = planet.overflow;\\n        planetUpdate.owner = planet.owner;\\n        planetUpdate.newOwner = planet.owner;\\n        planetUpdate.data = _planetData(location);\\n    }\\n\\n    // solhint-disable-next-line code-complexity\\n    function _computePlanetUpdateForTimeElapsed(PlanetUpdateState memory planetUpdate) internal view {\\n        if (planetUpdate.exitStartTime != 0) {\\n            if (_hasJustExited(planetUpdate.exitStartTime)) {\\n                planetUpdate.newExitStartTime = 0;\\n                planetUpdate.numSpaceships = 0;\\n                planetUpdate.travelingUpkeep = 0;\\n                planetUpdate.newOwner = address(0);\\n                planetUpdate.overflow = 0;\\n                planetUpdate.active = false; // event is emitted at the endof each write function\\n                // lastUpdated is set at the end directly on storage\\n                return;\\n            }\\n        }\\n\\n        uint256 timePassed = block.timestamp - planetUpdate.lastUpdated;\\n        uint16 production = _production(planetUpdate.data);\\n        uint256 amountProducedTheWholeTime = (timePassed * uint256(_productionSpeedUp) * uint256(production)) / 1 hours;\\n\\n        uint256 newNumSpaceships = planetUpdate.numSpaceships;\\n        uint256 extraUpkeepPaid = 0;\\n        if (_productionCapAsDuration > 0) {\\n            uint256 capWhenActive = _capWhenActive(production);\\n            uint256 cap = planetUpdate.active ? capWhenActive : 0;\\n\\n            if (newNumSpaceships > cap) {\\n                uint256 decreaseRate = 1800;\\n                if (planetUpdate.overflow > 0) {\\n                    decreaseRate = (uint256(planetUpdate.overflow) * 1800) / capWhenActive;\\n                    if (decreaseRate < 1800) {\\n                        decreaseRate = 1800;\\n                    }\\n                }\\n\\n                uint256 decrease = (timePassed * uint256(_productionSpeedUp) * decreaseRate) / 1 hours;\\n                if (decrease == 0) {\\n                    // NOTE: To ensure a player cannot simply ping the planet continuously to avoid the decrease\\n                    decrease = 1;\\n                }\\n                if (decrease > newNumSpaceships - cap) {\\n                    decrease = newNumSpaceships - cap;\\n                }\\n\\n                if (planetUpdate.active) {\\n                    extraUpkeepPaid = decrease;\\n                }\\n                newNumSpaceships -= decrease;\\n            } else {\\n                if (planetUpdate.active) {\\n                    uint256 increase = amountProducedTheWholeTime;\\n                    if (planetUpdate.travelingUpkeep > 0) {\\n                        uint256 timeBeforeUpkeepBackToZero = (uint256(uint40(planetUpdate.travelingUpkeep)) * 1 hours) /\\n                            ((uint256(_productionSpeedUp) *\\n                                uint256(production) *\\n                                _upkeepProductionDecreaseRatePer10000th) / 10000); // 10,000 should be extracted as to not reach div by zero (like \\\"1 hours\\\")\\n                        if (timeBeforeUpkeepBackToZero >= timePassed) {\\n                            extraUpkeepPaid = increase;\\n                        } else {\\n                            extraUpkeepPaid =\\n                                (timeBeforeUpkeepBackToZero * uint256(_productionSpeedUp) * uint256(production)) /\\n                                1 hours;\\n                            if (extraUpkeepPaid > increase) {\\n                                extraUpkeepPaid = increase; // TODO remove ? should not be possible\\n                            }\\n                        }\\n                        increase -= extraUpkeepPaid;\\n                    }\\n\\n                    uint256 maxIncrease = cap - newNumSpaceships;\\n                    if (increase > maxIncrease) {\\n                        extraUpkeepPaid += increase - maxIncrease;\\n                        increase = maxIncrease;\\n                    }\\n                    newNumSpaceships += increase;\\n                    // solhint-disable-next-line no-empty-blocks\\n                } else {\\n                    // not effect currently, when inactive, cap == 0, meaning zero spaceship here\\n                    // NOTE: we could do the following assuming we act on upkeepRepaid when inactive, we do not do that currently\\n                    //  extraUpkeepPaid = amountProducedTheWholeTime - upkeepRepaid;\\n                }\\n            }\\n\\n            if (planetUpdate.active) {\\n                uint256 upkeepRepaid = ((amountProducedTheWholeTime * _upkeepProductionDecreaseRatePer10000th) /\\n                    10000) + extraUpkeepPaid;\\n                int256 newTravelingUpkeep = int256(planetUpdate.travelingUpkeep) - int40(uint40(upkeepRepaid));\\n\\n                if (newTravelingUpkeep < -int256(cap)) {\\n                    newTravelingUpkeep = -int256(cap);\\n                }\\n                planetUpdate.travelingUpkeep = int40(newTravelingUpkeep);\\n            }\\n        } else {\\n            // TODO We are not using this branch, and in that branch there is no upkeep or overflow to consider\\n            if (planetUpdate.active) {\\n                newNumSpaceships += amountProducedTheWholeTime;\\n            } else {\\n                // NOTE no need to overflow here  as there is no production cap, so no incentive to regroup spaceships\\n                uint256 decrease = (timePassed * uint256(_productionSpeedUp) * 1800) / 1 hours;\\n                if (decrease > newNumSpaceships) {\\n                    decrease = newNumSpaceships;\\n                    newNumSpaceships = 0;\\n                } else {\\n                    newNumSpaceships -= decrease;\\n                }\\n            }\\n        }\\n\\n        if (newNumSpaceships >= ACTIVE_MASK) {\\n            newNumSpaceships = ACTIVE_MASK - 1;\\n        }\\n        planetUpdate.numSpaceships = uint32(newNumSpaceships);\\n\\n        if (!planetUpdate.active && planetUpdate.numSpaceships == 0) {\\n            planetUpdate.newOwner = address(0);\\n        }\\n    }\\n\\n    function _setPlanet(Planet storage planet, PlanetUpdateState memory planetUpdate, bool exitInterupted) internal {\\n        if (planetUpdate.exitStartTime > 0 && planetUpdate.newExitStartTime == 0) {\\n            // NOTE: planetUpdate.newExitStartTime is only set to zero when exit is actually complete (not interupted)\\n            //  interuption is handled by exitInterupted\\n            // exit has completed, newExitStartTime is not set to zero for interuption,\\n            // interuption is taken care below (owner changes)\\n            _handleExitComplete(planetUpdate);\\n        }\\n        if (planetUpdate.owner != planetUpdate.newOwner) {\\n            planet.owner = planetUpdate.newOwner;\\n            if (planetUpdate.newOwner != address(0)) {\\n                planet.ownershipStartTime = uint40(block.timestamp);\\n            } else {\\n                planet.ownershipStartTime = 0;\\n            }\\n            emit Transfer(planetUpdate.owner, planetUpdate.newOwner, planetUpdate.location);\\n        }\\n\\n        if (exitInterupted) {\\n            // if (planetUpdate.newExitStartTime == 0 && planetUpdate.exitStartTime > 0) {\\n            // exit interupted // TODO event ?\\n            // }\\n            planet.exitStartTime = 0;\\n        } else if (planetUpdate.newExitStartTime != planetUpdate.exitStartTime) {\\n            planet.exitStartTime = planetUpdate.newExitStartTime;\\n        }\\n\\n        planet.numSpaceships = _setActiveNumSpaceships(planetUpdate.active, planetUpdate.numSpaceships);\\n        planet.travelingUpkeep = planetUpdate.travelingUpkeep;\\n\\n        planet.overflow = planetUpdate.overflow;\\n        planet.lastUpdated = uint40(block.timestamp);\\n    }\\n\\n    // ---------------------------------------------------------------------------------------------------------------\\n    // STAKING / PRODUCTION CAPTURE\\n    // ---------------------------------------------------------------------------------------------------------------\\n\\n    function _acquire(address player, uint256 stake, uint256 location, bool freegift) internal whenNotPaused {\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Initialise State Update\\n        // -----------------------------------------------------------------------------------------------------------\\n        Planet storage planet = _getPlanet(location);\\n        PlanetUpdateState memory planetUpdate = _createPlanetUpdateState(planet, location);\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // check requirements\\n        // -----------------------------------------------------------------------------------------------------------\\n        require(stake == uint256(_stake(planetUpdate.data)) * (DECIMALS_14), \\\"INVALID_STAKE_AMOUNT\\\");\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Compute Basic Planet Updates\\n        // -----------------------------------------------------------------------------------------------------------\\n        _computePlanetUpdateForTimeElapsed(planetUpdate);\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Staking logic...\\n        // -----------------------------------------------------------------------------------------------------------\\n        _computePlanetUpdateForStaking(player, planetUpdate);\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Write New State\\n        // -----------------------------------------------------------------------------------------------------------\\n        _setPlanet(planet, planetUpdate, false);\\n        // _setAccountFromPlanetUpdate(planetUpdate);\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Update Space Discovery\\n        // -----------------------------------------------------------------------------------------------------------\\n        _setDiscoveryAfterStaking(location);\\n\\n        if (freegift) {\\n            _planetFlagged[location] = block.timestamp;\\n        } else {\\n            _planetFlagged[location] = 0; // staked with normal tokens\\n        }\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Emit Event\\n        // -----------------------------------------------------------------------------------------------------------\\n        emit BlockTime(block.number, block.timestamp);\\n        emit PlanetStake(\\n            player,\\n            location,\\n            planetUpdate.numSpaceships,\\n            planetUpdate.travelingUpkeep,\\n            planetUpdate.overflow,\\n            stake,\\n            freegift\\n        );\\n        _notifyGeneratorAdd(planetUpdate.newOwner, stake);\\n    }\\n\\n    function _computePlanetUpdateForStaking(address player, PlanetUpdateState memory planetUpdate) internal view {\\n        require(!planetUpdate.active, \\\"STILL_ACTIVE\\\");\\n\\n        uint32 defense;\\n        // NOTE : natives are back automatically once spaceships reaches zero (here we know we are not active)\\n        // TODO consider making natives come back over time => would need to compute the time numSpaceship became zero\\n        if (planetUpdate.numSpaceships == 0) {\\n            defense = _natives(planetUpdate.data);\\n        } else {\\n            // Do not allow staking over occupied planets, they are going to zero at some point though\\n            require(planetUpdate.owner == player, \\\"OCCUPIED\\\");\\n        }\\n\\n        uint16 production = _production(planetUpdate.data);\\n        uint32 cap = uint32(_capWhenActive(production));\\n\\n        // We need to  ensure a player staking on a planet it previously exited work here\\n        planetUpdate.newOwner = player;\\n        if (defense != 0) {\\n            (uint32 attackerLoss, ) = _computeFight(\\n                uint256(_acquireNumSpaceships),\\n                defense,\\n                10000,\\n                _defense(planetUpdate.data)\\n            );\\n            // attacker alwasy win as defense (and stats.native) is restricted to 3500\\n            // (attackerLoss: 0, defenderLoss: 0) would mean defense was zero\\n            require(attackerLoss < _acquireNumSpaceships, \\\"FAILED_CAPTURED\\\");\\n            planetUpdate.numSpaceships = _acquireNumSpaceships - attackerLoss;\\n\\n            // NOTE cannot be overflow here as staking provide a number of spaceships below that\\n            planetUpdate.overflow = 0;\\n        } else {\\n            planetUpdate.numSpaceships += _acquireNumSpaceships;\\n            if (_productionCapAsDuration > 0) {\\n                if (planetUpdate.numSpaceships > cap) {\\n                    planetUpdate.overflow = planetUpdate.numSpaceships - cap;\\n                } else {\\n                    planetUpdate.overflow = 0;\\n                }\\n            }\\n        }\\n\\n        // NOTE when staking on a planet, we set an allowance for traveling upkeep\\n        planetUpdate.travelingUpkeep =\\n            -int32(uint32((uint256(cap) * _upkeepProductionDecreaseRatePer10000th) / 10000)) -\\n            int32(planetUpdate.numSpaceships);\\n        planetUpdate.active = true;\\n    }\\n\\n    // solhint-disable-next-line code-complexity\\n    function _setDiscoveryAfterStaking(uint256 location) internal {\\n        Discovered memory discovered = _discovered;\\n\\n        int256 x = int256(int128(int256(location & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)));\\n        int256 y = int256(int128(int256(location >> 128)));\\n\\n        bool changes = false;\\n        if (x < 0) {\\n            require(-x <= int256(uint256(discovered.minX)), \\\"NOT_REACHABLE_YET_MINX\\\");\\n            x = -x + int32(_expansionDelta);\\n            if (x > UINT32_MAX) {\\n                x = UINT32_MAX;\\n            }\\n            if (int256(uint256(discovered.minX)) < x) {\\n                discovered.minX = uint32(uint256(x));\\n                changes = true;\\n            }\\n        } else {\\n            require(x <= int256(uint256(discovered.maxX)), \\\"NOT_REACHABLE_YET_MAXX\\\");\\n            x = x + int32(_expansionDelta);\\n            if (x > UINT32_MAX) {\\n                x = UINT32_MAX;\\n            }\\n            if (discovered.maxX < uint32(uint256(x))) {\\n                discovered.maxX = uint32(uint256(x));\\n                changes = true;\\n            }\\n        }\\n\\n        if (y < 0) {\\n            require(-y <= int256(uint256(discovered.minY)), \\\"NOT_REACHABLE_YET_MINY\\\");\\n            y = -y + int32(_expansionDelta);\\n            if (y > UINT32_MAX) {\\n                y = UINT32_MAX;\\n            }\\n            if (int256(uint256(discovered.minY)) < y) {\\n                discovered.minY = uint32(uint256(y));\\n                changes = true;\\n            }\\n        } else {\\n            require(y <= int256(uint256(discovered.maxY)), \\\"NOT_REACHABLE_YET_MAXY\\\");\\n            y = y + int32(_expansionDelta);\\n            if (y > UINT32_MAX) {\\n                y = UINT32_MAX;\\n            }\\n            if (int256(uint256(discovered.maxY)) < y) {\\n                discovered.maxY = uint32(uint256(y));\\n                changes = true;\\n            }\\n        }\\n        if (changes) {\\n            _discovered = discovered;\\n        }\\n    }\\n\\n    // ---------------------------------------------------------------------------------------------------------------\\n    // EXITS / WITHDRAWALS\\n    // ---------------------------------------------------------------------------------------------------------------\\n\\n    function _handleExitComplete(PlanetUpdateState memory planetUpdate) internal {\\n        uint256 stake = _completeExit(planetUpdate.owner, planetUpdate.location, planetUpdate.data);\\n\\n        // Note we could Transfer to zero and Transfer from zero ?\\n\\n        // optional so we can use it in the batch withdraw,\\n\\n        uint256 flagTime = _planetFlagged[planetUpdate.location];\\n        if (flagTime > 0) {\\n            if (planetUpdate.exitStartTime >= flagTime + (6 days / _productionSpeedUp)) {\\n                _freeStakingToken.burn(address(this), address(this), stake);\\n                uint256 newStake = _stakeReadyToBeWithdrawn[planetUpdate.owner] + stake;\\n                _stakeReadyToBeWithdrawn[planetUpdate.owner] = newStake;\\n                emit StakeToWithdraw(planetUpdate.owner, newStake, false);\\n            } else {\\n                uint256 newStake = _freeStakeReadyToBeWithdrawn[planetUpdate.owner] + stake;\\n                _freeStakeReadyToBeWithdrawn[planetUpdate.owner] = newStake;\\n                emit StakeToWithdraw(planetUpdate.owner, newStake, true);\\n            }\\n        } else {\\n            uint256 newStake = _stakeReadyToBeWithdrawn[planetUpdate.owner] + stake;\\n            _stakeReadyToBeWithdrawn[planetUpdate.owner] = newStake;\\n            emit StakeToWithdraw(planetUpdate.owner, newStake, false);\\n        }\\n    }\\n\\n    function _completeExit(address owner, uint256 location, bytes32 data) internal returns (uint256 stake) {\\n        stake = uint256(_stake(data)) * (DECIMALS_14);\\n        emit BlockTime(block.number, block.timestamp);\\n        emit ExitComplete(owner, location, stake);\\n\\n        // --------------------------------------------------------\\n        // Extra Reward was added\\n        // --------------------------------------------------------\\n        uint256 rewardId = _rewards[location];\\n        if (rewardId != 0) {\\n            // rewardId would contains the package. maybe this could be handled by an external contract\\n            _rewardsToWithdraw[owner][rewardId] = true;\\n            _rewards[location] = 0; // reset\\n            // if you had reward to a planet in he process of exiting,\\n            // you are adding the reward to the player exiting unless _setPlanetAfterExit is called first\\n            emit RewardToWithdraw(owner, location, rewardId);\\n        }\\n        // --------------------------------------------------------\\n    }\\n\\n    function _unsafe_exit_for(address owner, uint256 location) internal {\\n        Planet storage planet = _getPlanet(location);\\n        (bool active, ) = _activeNumSpaceships(planet.numSpaceships);\\n        require(active, \\\"NOT_ACTIVE\\\");\\n        require(owner == planet.owner, \\\"NOT_OWNER\\\");\\n        require(planet.exitStartTime == 0, \\\"EXITING_ALREADY\\\");\\n\\n        planet.exitStartTime = uint40(block.timestamp);\\n        emit BlockTime(block.number, block.timestamp);\\n        emit PlanetExit(owner, location);\\n\\n        // stake is removed as soon as we start exist\\n        // If the exit is interupted, it is given to the player interupting\\n        _notifyGeneratorRemove(owner, uint256(_stake(_planetData(location))) * (DECIMALS_14));\\n    }\\n\\n    function _fetchAndWithdrawFor(address owner, uint256[] calldata locations) internal {\\n        uint256 addedStake = 0;\\n        uint256 freeAddedStake = 0;\\n        for (uint256 i = 0; i < locations.length; i++) {\\n            Planet storage planet = _getPlanet(locations[i]);\\n            if (_hasJustExited(planet.exitStartTime)) {\\n                require(owner == planet.owner, \\\"NOT_OWNER\\\");\\n                emit Transfer(owner, address(0), locations[i]);\\n\\n                uint256 flagTime = _planetFlagged[locations[i]];\\n                if (flagTime > 0) {\\n                    if (planet.exitStartTime >= flagTime + (6 days / _productionSpeedUp)) {\\n                        uint256 extra = _completeExit(planet.owner, locations[i], _planetData(locations[i]));\\n                        addedStake += extra;\\n                        _freeStakingToken.burn(address(this), address(this), extra);\\n                    } else {\\n                        freeAddedStake += _completeExit(planet.owner, locations[i], _planetData(locations[i]));\\n                    }\\n                } else {\\n                    addedStake += _completeExit(planet.owner, locations[i], _planetData(locations[i]));\\n                }\\n\\n                planet.owner = address(0);\\n                planet.ownershipStartTime = 0;\\n                planet.exitStartTime = 0;\\n                planet.numSpaceships = 0;\\n                planet.overflow = 0;\\n                planet.travelingUpkeep = 0;\\n                planet.lastUpdated = uint40(block.timestamp);\\n            }\\n        }\\n        uint256 newStake = _stakeReadyToBeWithdrawn[owner] + addedStake;\\n        _unsafe_withdrawAll(owner, newStake);\\n\\n        uint256 newFreeStake = _freeStakeReadyToBeWithdrawn[owner] + freeAddedStake;\\n        _free_unsafe_withdrawAll(owner, newFreeStake);\\n    }\\n\\n    function _unsafe_withdrawAll(address owner, uint256 amount) internal {\\n        _stakeReadyToBeWithdrawn[owner] = 0;\\n        emit StakeToWithdraw(owner, amount, false);\\n        require(_stakingToken.transfer(owner, amount), \\\"FAILED_TRANSFER\\\");\\n        emit StakeToWithdraw(owner, 0, false);\\n    }\\n\\n    function _free_unsafe_withdrawAll(address owner, uint256 amount) internal {\\n        _freeStakeReadyToBeWithdrawn[owner] = 0;\\n        emit StakeToWithdraw(owner, amount, true);\\n        require(_freeStakingToken.transfer(owner, amount), \\\"FAILED_TRANSFER\\\");\\n        emit StakeToWithdraw(owner, 0, true);\\n    }\\n\\n    function _hasJustExited(uint40 exitTime) internal view returns (bool) {\\n        if (exitTime == 0) {\\n            return false;\\n        }\\n        uint256 timestamp = block.timestamp;\\n        if (_bootstrapSessionEndTime > 0 && timestamp >= _bootstrapSessionEndTime && exitTime < _infinityStartTime) {\\n            return true;\\n        }\\n\\n        return timestamp > exitTime + _exitDuration;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------------------------------\\n    // REWARDS\\n    // ---------------------------------------------------------------------------------------------------------------\\n\\n    function _addReward(uint256 location, address sponsor) internal {\\n        uint256 rewardId = _rewards[location];\\n        require(rewardId == 0, \\\"REWARD_ALREADY_AT_THIS_LOCATION\\\");\\n        // TODO ?\\n        // Planet storage planet = _getPlanet(location);\\n        // require(planet.lastUpdated == 0, \\\"PLANET_ALREADY_COLONIZED\\\");\\n        rewardId = ++_prevRewardIds[sponsor];\\n        _rewards[location] = (uint256(uint160(sponsor)) << 96) + rewardId;\\n        emit RewardSetup(location, sponsor, rewardId);\\n    }\\n\\n    // ---------------------------------------------------------------------------------------------------------------\\n    // FLEET SENDING\\n    // ---------------------------------------------------------------------------------------------------------------\\n\\n    function _unsafe_sendFor(uint256 fleetId, address operator, FleetLaunch memory launch) internal whenNotPaused {\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Initialise State Update\\n        // -----------------------------------------------------------------------------------------------------------\\n        Planet storage planet = _getPlanet(launch.from);\\n        PlanetUpdateState memory planetUpdate = _createPlanetUpdateState(planet, launch.from);\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // check requirements\\n        // -----------------------------------------------------------------------------------------------------------\\n\\n        require(launch.quantity < 2 ** 30, \\\"TOO_MANY_SPACESHIPS\\\"); // only 2^30 because the first 2 bits = resolution\\n        require(launch.quantity > 0, \\\"NO_SPACESHIPS\\\");\\n        require(planet.exitStartTime == 0, \\\"PLANET_EXIT\\\");\\n        require(launch.fleetSender == planet.owner, \\\"NOT_OWNER\\\");\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Compute Basic Planet Updates\\n        // -----------------------------------------------------------------------------------------------------------\\n        _computePlanetUpdateForTimeElapsed(planetUpdate);\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Requirements post Planet Updates\\n        // -----------------------------------------------------------------------------------------------------------\\n\\n        require(planetUpdate.numSpaceships >= launch.quantity, \\\"SPACESHIPS_NOT_ENOUGH\\\");\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Sending logic...\\n        // -----------------------------------------------------------------------------------------------------------\\n        _computePlanetUpdateForFleetLaunch(planetUpdate, launch.quantity);\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Write New State\\n        // -----------------------------------------------------------------------------------------------------------\\n        _setPlanet(planet, planetUpdate, false);\\n        // _setAccountFromPlanetUpdate(planetUpdate);\\n\\n        _setFleetFlyingSlot(launch.from, launch.quantity);\\n\\n        require(_fleets[fleetId].quantity == 0, \\\"FLEET_EXISTS\\\");\\n        _fleets[fleetId] = Fleet({\\n            launchTime: uint40(block.timestamp),\\n            owner: launch.fleetOwner,\\n            quantity: launch.quantity,\\n            futureExtraProduction: planetUpdate.futureExtraProduction,\\n            defender: address(0),\\n            arrivalTime: 0,\\n            defenderLoss: 0,\\n            victory: false,\\n            planetActive: false\\n        });\\n\\n        emit BlockTime(block.number, block.timestamp);\\n        emit FleetSent(\\n            launch.fleetSender,\\n            launch.fleetOwner,\\n            launch.from,\\n            operator,\\n            fleetId,\\n            launch.quantity,\\n            planetUpdate.numSpaceships,\\n            planetUpdate.travelingUpkeep,\\n            planetUpdate.overflow\\n        );\\n    }\\n\\n    function _computePlanetUpdateForFleetLaunch(PlanetUpdateState memory planetUpdate, uint32 quantity) internal view {\\n        planetUpdate.numSpaceships -= quantity;\\n        if (_productionCapAsDuration > 0) {\\n            if (planetUpdate.active) {\\n                // NOTE we do not update travelingUpkeep on Inactive planets\\n                //  these get reset on staking\\n\\n                uint16 production = _production(planetUpdate.data);\\n                uint256 cap = _capWhenActive(production);\\n                if (planetUpdate.numSpaceships < cap) {\\n                    uint256 futureExtraProduction = cap - planetUpdate.numSpaceships;\\n                    if (futureExtraProduction > quantity) {\\n                        futureExtraProduction = quantity;\\n                    }\\n                    int256 newTravelingUpkeep = int256(planetUpdate.travelingUpkeep) + int256(futureExtraProduction);\\n                    if (newTravelingUpkeep > int256(cap)) {\\n                        newTravelingUpkeep = int256(cap);\\n                    }\\n                    planetUpdate.travelingUpkeep = int40(newTravelingUpkeep);\\n                    planetUpdate.futureExtraProduction = uint24(futureExtraProduction); // cap is always smaller than uint24\\n                }\\n            }\\n\\n            if (planetUpdate.overflow > quantity) {\\n                planetUpdate.overflow -= quantity;\\n            } else {\\n                planetUpdate.overflow = 0;\\n            }\\n        }\\n    }\\n\\n    function _setFleetFlyingSlot(uint256 from, uint32 quantity) internal {\\n        // -----------------------------------------------------------------------------------------------------------\\n        // record flying fleets (to prevent front-running, see resolution)\\n        // -----------------------------------------------------------------------------------------------------------\\n        uint256 timeSlot = block.timestamp / (_frontrunningDelay / 2);\\n        uint32 flying = _inFlight[from][timeSlot].flying;\\n        unchecked {\\n            flying = flying + quantity;\\n        }\\n        require(flying >= quantity, \\\"ORBIT_OVERFLOW\\\"); // unlikely to ever happen,\\n        // would need a huge amount of spaceships to be received and each in turn being sent\\n        // TOEXPLORE could also cap, that would result in some fleet being able to escape.\\n        _inFlight[from][timeSlot].flying = flying;\\n        // -----------------------------------------------------------------------------------------------------------\\n    }\\n\\n    // ---------------------------------------------------------------------------------------------------------------\\n    // FLEET RESOLUTION, ATTACK / REINFORCEMENT\\n    // ---------------------------------------------------------------------------------------------------------------\\n    struct ResolutionState {\\n        address fleetOwner;\\n        uint40 fleetLaunchTime;\\n        uint32 originalQuantity;\\n        uint32 fleetQuantity;\\n        bytes32 fromData;\\n        uint32 inFlightFleetLoss;\\n        uint32 inFlightPlanetLoss;\\n        bool gifting;\\n        bool taxed;\\n        bool victory;\\n        uint32 attackerLoss;\\n        uint32 defenderLoss;\\n        uint32 orbitDefense1;\\n        uint32 orbitDefenseDestroyed1;\\n        uint32 orbitDefense2;\\n        uint32 orbitDefenseDestroyed2;\\n        uint40 arrivalTime;\\n        uint32 accumulatedDefenseAdded;\\n        uint32 accumulatedAttackAdded;\\n        uint16 attackPower;\\n        uint24 futureExtraProduction;\\n    }\\n\\n    function _resolveFleet(uint256 fleetId, FleetResolution calldata resolution) internal {\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Initialise State Update\\n        // -----------------------------------------------------------------------------------------------------------\\n        Planet storage toPlanet = _getPlanet(resolution.to);\\n        PlanetUpdateState memory toPlanetUpdate = _createPlanetUpdateState(toPlanet, resolution.to);\\n        ResolutionState memory rState = _createResolutionState(_fleets[fleetId], resolution.from);\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // check requirements\\n        // -----------------------------------------------------------------------------------------------------------\\n\\n        require(\\n            rState.fleetQuantity > 0,\\n            rState.fleetOwner != address(0) ? \\\"FLEET_RESOLVED_ALREADY\\\" : \\\"FLEET_DO_NOT_EXIST\\\"\\n        );\\n        _requireCorrectDistance(\\n            resolution.distance,\\n            resolution.from,\\n            resolution.to,\\n            rState.fromData,\\n            toPlanetUpdate.data\\n        );\\n        _requireCorrectTimeAndUpdateArrivalTime(\\n            resolution.distance,\\n            resolution.arrivalTimeWanted,\\n            rState.fleetLaunchTime,\\n            rState.fromData,\\n            rState\\n        );\\n\\n        if (_bootstrapSessionEndTime > 0) {\\n            uint256 timestamp = block.timestamp;\\n\\n            if (timestamp >= _bootstrapSessionEndTime) {\\n                require(rState.fleetLaunchTime >= _infinityStartTime, \\\"FLEET_LAUNCHED_IN_BOOTSTRAP\\\");\\n            }\\n        }\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Compute Basic Planet Updates\\n        // -----------------------------------------------------------------------------------------------------------\\n        _computePlanetUpdateForTimeElapsed(toPlanetUpdate);\\n\\n        address ownerAtArrival = toPlanetUpdate.newOwner; // this can be owner == address(0)\\n\\n        uint32 numSpaceshipsAtArrival = toPlanetUpdate.numSpaceships;\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Traveling logic...\\n        // -----------------------------------------------------------------------------------------------------------\\n\\n        _computeInFlightLossForFleet(rState, resolution);\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Resolution logic...\\n        // -----------------------------------------------------------------------------------------------------------\\n\\n        _updateFleetForGifting(rState, resolution, toPlanetUpdate.newOwner);\\n\\n        _computeResolutionResult(rState, toPlanetUpdate);\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Write New State\\n        // -----------------------------------------------------------------------------------------------------------\\n\\n        _recordInOrbitLossAfterAttack(rState, toPlanetUpdate);\\n\\n        _recordOrbitLossAccountingForFleetOrigin(rState, resolution);\\n\\n        _setTravelingUpkeepFromOrigin(fleetId, rState, resolution.from);\\n\\n        _setPlanet(toPlanet, toPlanetUpdate, rState.victory);\\n\\n        _setAccumulatedAttack(rState, toPlanetUpdate);\\n\\n        _fleets[fleetId].quantity = (1 << 31) | _fleets[fleetId].quantity;\\n        _fleets[fleetId].defender = ownerAtArrival;\\n        _fleets[fleetId].defenderLoss = rState.defenderLoss;\\n        _fleets[fleetId].arrivalTime = uint40(block.timestamp);\\n        _fleets[fleetId].planetActive = toPlanetUpdate.active;\\n        _fleets[fleetId].victory = rState.victory;\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Events\\n        // -----------------------------------------------------------------------------------------------------------\\n        _emitFleetArrived(\\n            fleetId,\\n            rState,\\n            ownerAtArrival,\\n            resolution,\\n            _arrivalData(rState, toPlanetUpdate, numSpaceshipsAtArrival)\\n        );\\n\\n        if (toPlanetUpdate.active && rState.victory) {\\n            // if active and the fleet was victorious we need to handle stake change of hands\\n            if (toPlanetUpdate.exitStartTime != 0) {\\n                // exit has been interupted\\n                // we add stake to new owner\\n                _notifyGeneratorAdd(toPlanetUpdate.newOwner, uint256(_stake(toPlanetUpdate.data)) * (DECIMALS_14));\\n            } else {\\n                // there was no exit, so we move the stake\\n                _notifyGeneratorMove(\\n                    toPlanetUpdate.owner,\\n                    toPlanetUpdate.newOwner,\\n                    uint256(_stake(toPlanetUpdate.data)) * (DECIMALS_14)\\n                );\\n            }\\n        }\\n    }\\n\\n    function _arrivalData(\\n        ResolutionState memory rState,\\n        PlanetUpdateState memory toPlanetUpdate,\\n        uint32 numSpaceshipsAtArrival\\n    ) internal pure returns (ArrivalData memory arrivalData) {\\n        arrivalData.newNumspaceships = toPlanetUpdate.numSpaceships;\\n        arrivalData.newTravelingUpkeep = toPlanetUpdate.travelingUpkeep;\\n        arrivalData.newOverflow = toPlanetUpdate.overflow;\\n        arrivalData.numSpaceshipsAtArrival = numSpaceshipsAtArrival;\\n        arrivalData.taxLoss = rState.taxed\\n            ? (rState.originalQuantity - rState.inFlightFleetLoss) - rState.fleetQuantity\\n            : 0;\\n        arrivalData.fleetLoss = rState.attackerLoss;\\n        arrivalData.planetLoss = rState.defenderLoss;\\n        arrivalData.inFlightFleetLoss = rState.inFlightFleetLoss;\\n        arrivalData.inFlightPlanetLoss = rState.inFlightPlanetLoss;\\n        arrivalData.accumulatedDefenseAdded = rState.accumulatedDefenseAdded;\\n        arrivalData.accumulatedAttackAdded = rState.accumulatedAttackAdded;\\n    }\\n\\n    function _emitFleetArrived(\\n        uint256 fleetId,\\n        ResolutionState memory rState,\\n        address planetOwner,\\n        FleetResolution memory resolution,\\n        ArrivalData memory arrivalData\\n    ) internal {\\n        emit BlockTime(block.number, block.timestamp);\\n        emit FleetRevealed(\\n            fleetId,\\n            resolution.from,\\n            resolution.to,\\n            resolution.arrivalTimeWanted,\\n            resolution.gift,\\n            resolution.specific,\\n            resolution.secret,\\n            resolution.fleetSender,\\n            resolution.operator\\n        );\\n        emit FleetArrived(\\n            fleetId,\\n            rState.fleetOwner,\\n            planetOwner,\\n            resolution.to,\\n            rState.gifting,\\n            rState.victory,\\n            arrivalData\\n        );\\n    }\\n\\n    function _requireCorrectDistance(\\n        uint256 distance,\\n        uint256 from,\\n        uint256 to,\\n        bytes32 fromPlanetData,\\n        bytes32 toPlanetData\\n    ) internal pure {\\n        // check input instead of compute sqrt\\n\\n        (int8 fromSubX, int8 fromSubY) = _subLocation(fromPlanetData);\\n        (int8 toSubX, int8 toSubY) = _subLocation(toPlanetData);\\n        uint256 distanceSquared = uint256(\\n            int256( // check input instead of compute sqrt\\n                ((int128(int256(to & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) * 4 + toSubX) -\\n                    (int128(int256(from & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) * 4 + fromSubX)) **\\n                    2 +\\n                    ((int128(int256(to >> 128)) * 4 + toSubY) - (int128(int256(from >> 128)) * 4 + fromSubY)) ** 2\\n            )\\n        );\\n        require(distance ** 2 <= distanceSquared && distanceSquared < (distance + 1) ** 2, \\\"wrong distance\\\");\\n    }\\n\\n    function _requireCorrectTimeAndUpdateArrivalTime(\\n        uint256 distance,\\n        uint256 arrivalTimeWanted,\\n        uint40 launchTime,\\n        bytes32 fromPlanetData,\\n        ResolutionState memory rState\\n    ) internal view {\\n        uint256 minReachTime = launchTime + (distance * (_timePerDistance * 10000)) / _speed(fromPlanetData);\\n        uint256 reachTime = Math.max(arrivalTimeWanted, minReachTime);\\n        if (arrivalTimeWanted > 0) {\\n            rState.arrivalTime = uint40(arrivalTimeWanted);\\n        } else {\\n            rState.arrivalTime = uint40(minReachTime);\\n        }\\n        require(block.timestamp >= reachTime, \\\"too early\\\");\\n        require(block.timestamp < reachTime + _resolveWindow, \\\"too late, your spaceships are lost in space\\\");\\n    }\\n\\n    function _computeInFlightLossForFleet(\\n        ResolutionState memory rState,\\n        FleetResolution memory resolution\\n    ) internal view {\\n        // -----------------------------------------------------------------------------------------------------------\\n        // check if fleet was attacked while departing (used to prevent front-running, see fleet sending)\\n        // -----------------------------------------------------------------------------------------------------------\\n        uint256 timeSlot = rState.fleetLaunchTime / (_frontrunningDelay / 2);\\n        uint32 destroyed = _inFlight[resolution.from][timeSlot].destroyed;\\n        uint32 originalQuantity = rState.fleetQuantity;\\n        if (destroyed < rState.fleetQuantity) {\\n            rState.fleetQuantity -= uint32(destroyed);\\n        } else {\\n            rState.fleetQuantity = 0;\\n        }\\n\\n        rState.inFlightFleetLoss = originalQuantity - rState.fleetQuantity;\\n        // -----------------------------------------------------------------------------------------------------------\\n    }\\n\\n    function _updateFleetForGifting(\\n        ResolutionState memory rState,\\n        FleetResolution memory resolution,\\n        address destinationOwner\\n    ) internal view {\\n        (bool gifting, bool taxed) = _computeGifting(destinationOwner, resolution, rState);\\n        rState.gifting = gifting;\\n        rState.taxed = taxed;\\n    }\\n\\n    // TODO simplify and apply that to attack (when fleetOwner is not fleetSender)\\n    //  if (resolution.gift) { rState.fleetOwner = destinationOwner }\\n    //  then compute tax based on fleetOwner != fleetSender, box for attacks and gift\\n    //  combined attack could even work for non-allies ?\\n    //  in _computeGift calculate the tax for every branch that result in `gifting` being false\\n    //  then in attack, add tax to the quantity of fleet + modify event\\n\\n    // solhint-disable-next-line code-complexity\\n    function _computeGifting(\\n        address destinationOwner,\\n        FleetResolution memory resolution,\\n        ResolutionState memory rState\\n    ) internal view returns (bool gifting, bool taxed) {\\n        if (destinationOwner == address(0)) {\\n            // destination has no owner : this is an attack\\n            return (false, _isFleetOwnerTaxed(rState.fleetOwner, resolution.fleetSender, rState.fleetLaunchTime));\\n        }\\n        if (destinationOwner == rState.fleetOwner && destinationOwner == resolution.fleetSender) {\\n            // destination is sender is fleet owner: this is a non-taxed gift\\n            return (true, false);\\n        }\\n\\n        if (resolution.gift || destinationOwner == rState.fleetOwner) {\\n            // intent was gift\\n            if (\\n                resolution.specific == address(0) || // anyone\\n                resolution.specific == destinationOwner || // only one address and matching owner\\n                destinationOwner == rState.fleetOwner // owner is fleet owner => gift\\n            ) {\\n                // and it was for anyone or specific destination owner that is the same as the current one\\n                // or it was simply that fleetOwner = destinationOwner\\n\\n                // check tax applies with sender\\n                (, uint96 joinTime) = _allianceRegistry.havePlayersAnAllianceInCommon(\\n                    resolution.fleetSender,\\n                    destinationOwner,\\n                    rState.fleetLaunchTime\\n                );\\n                return (true, joinTime == 0 || joinTime > rState.fleetLaunchTime);\\n            }\\n\\n            if (resolution.specific == address(1)) {\\n                // or the specific specify any common alliances (1)\\n\\n                if (rState.fleetOwner == resolution.fleetSender) {\\n                    (, uint96 joinTime) = _allianceRegistry.havePlayersAnAllianceInCommon(\\n                        resolution.fleetSender,\\n                        destinationOwner,\\n                        rState.fleetLaunchTime\\n                    );\\n                    return (joinTime > 0, joinTime > rState.fleetLaunchTime);\\n                } else {\\n                    (, uint96 fleetOwnerJoinTime) = _allianceRegistry.havePlayersAnAllianceInCommon(\\n                        rState.fleetOwner,\\n                        destinationOwner,\\n                        rState.fleetLaunchTime\\n                    );\\n\\n                    if (fleetOwnerJoinTime == 0) {\\n                        // not in an alliance\\n                        return (\\n                            false,\\n                            _isFleetOwnerTaxed(rState.fleetOwner, resolution.fleetSender, rState.fleetLaunchTime)\\n                        );\\n                    }\\n\\n                    // alliance => means gift\\n                    // check if taxed:\\n                    (, uint96 senderJoinTime) = _allianceRegistry.havePlayersAnAllianceInCommon(\\n                        resolution.fleetSender,\\n                        destinationOwner,\\n                        rState.fleetLaunchTime\\n                    );\\n\\n                    return (true, senderJoinTime == 0 || senderJoinTime > rState.fleetLaunchTime);\\n                }\\n            }\\n\\n            if (uint160(resolution.specific) > 1) {\\n                // or a specific alliance that matches\\n\\n                (uint96 joinTimeToSpecific, ) = _allianceRegistry.getAllianceData(\\n                    destinationOwner,\\n                    IAlliance(resolution.specific)\\n                );\\n\\n                if (joinTimeToSpecific > 0) {\\n                    (, uint96 joinTime) = _allianceRegistry.havePlayersAnAllianceInCommon(\\n                        resolution.fleetSender,\\n                        destinationOwner,\\n                        rState.fleetLaunchTime\\n                    );\\n                    return (true, joinTime == 0 || joinTime > rState.fleetLaunchTime);\\n                }\\n            }\\n        } else {\\n            // intent was attack\\n            if (resolution.specific == address(1)) {\\n                // and the attack was on any non-allies\\n\\n                if (rState.fleetOwner == resolution.fleetSender) {\\n                    // make it a gift if the destination owner is actually an ally\\n                    (, uint96 joinTime) = _allianceRegistry.havePlayersAnAllianceInCommon(\\n                        resolution.fleetSender,\\n                        destinationOwner,\\n                        rState.fleetLaunchTime\\n                    );\\n                    return (joinTime > 0, joinTime > rState.fleetLaunchTime);\\n                } else {\\n                    (, uint96 fleetOwnerJoinTime) = _allianceRegistry.havePlayersAnAllianceInCommon(\\n                        rState.fleetOwner,\\n                        destinationOwner,\\n                        rState.fleetLaunchTime\\n                    );\\n\\n                    if (fleetOwnerJoinTime == 0) {\\n                        // not in an alliance\\n                        return (\\n                            false,\\n                            _isFleetOwnerTaxed(rState.fleetOwner, resolution.fleetSender, rState.fleetLaunchTime)\\n                        );\\n                    }\\n\\n                    // alliance => means gift\\n                    // check if taxed:\\n                    (, uint96 senderJoinTime) = _allianceRegistry.havePlayersAnAllianceInCommon(\\n                        resolution.fleetSender,\\n                        destinationOwner,\\n                        rState.fleetLaunchTime\\n                    );\\n\\n                    return (true, senderJoinTime == 0 || senderJoinTime > rState.fleetLaunchTime);\\n                }\\n            }\\n\\n            if (uint160(resolution.specific) > 1 && resolution.specific != destinationOwner) {\\n                // but specific not matching current owner\\n\\n                (uint96 joinTimeToSpecific, ) = _allianceRegistry.getAllianceData(\\n                    destinationOwner,\\n                    IAlliance(resolution.specific)\\n                );\\n\\n                // make it a gift if the destination is not matching the specific alliance\\n                // (or owner, in which case since it is not an alliance, it will also not match)\\n                if (joinTimeToSpecific == 0) {\\n                    (, uint96 joinTime) = _allianceRegistry.havePlayersAnAllianceInCommon(\\n                        resolution.fleetSender,\\n                        destinationOwner,\\n                        rState.fleetLaunchTime\\n                    );\\n                    return (true, joinTime == 0 || joinTime > rState.fleetLaunchTime);\\n                }\\n            }\\n        }\\n        return (false, _isFleetOwnerTaxed(rState.fleetOwner, resolution.fleetSender, rState.fleetLaunchTime));\\n    }\\n\\n    function _isFleetOwnerTaxed(\\n        address fleetOwner,\\n        address fleetSender,\\n        uint40 fleetLaunchTime\\n    ) internal view returns (bool) {\\n        if (fleetOwner == fleetSender) {\\n            return false;\\n        }\\n        (, uint96 joinTime) = _allianceRegistry.havePlayersAnAllianceInCommon(fleetOwner, fleetSender, fleetLaunchTime);\\n        return joinTime == 0 || joinTime > fleetLaunchTime;\\n    }\\n\\n    function _setTravelingUpkeepFromOrigin(uint256 fleetID, ResolutionState memory rState, uint256 location) internal {\\n        // // we have to update the origin\\n        Planet storage fromPlanet = _planets[location];\\n        PlanetUpdateState memory fromPlanetUpdate = _createPlanetUpdateState(fromPlanet, location);\\n        _computePlanetUpdateForTimeElapsed(fromPlanetUpdate);\\n\\n        uint16 production = _production(fromPlanetUpdate.data);\\n        uint256 capWhenActive = _capWhenActive(production);\\n\\n        uint256 refund = rState.futureExtraProduction;\\n        uint256 timePassed = block.timestamp - rState.fleetLaunchTime;\\n        uint256 amountProducedTheWholeTime = (timePassed * uint256(_productionSpeedUp) * uint256(production)) / 1 hours;\\n        uint256 consumed = amountProducedTheWholeTime +\\n            (amountProducedTheWholeTime * _upkeepProductionDecreaseRatePer10000th) /\\n            10000;\\n        if (consumed > refund) {\\n            refund = 0;\\n        } else {\\n            refund -= consumed;\\n        }\\n\\n        int256 newTravelingUpkeep = int256(fromPlanetUpdate.travelingUpkeep) - int256(refund);\\n        if (newTravelingUpkeep < -int256(capWhenActive)) {\\n            newTravelingUpkeep = -int256(capWhenActive);\\n        }\\n        fromPlanetUpdate.travelingUpkeep = int40(newTravelingUpkeep);\\n\\n        _setPlanet(fromPlanet, fromPlanetUpdate, false);\\n\\n        emit BlockTime(block.number, block.timestamp);\\n        emit TravelingUpkeepRefund(\\n            location,\\n            fleetID,\\n            fromPlanetUpdate.numSpaceships,\\n            fromPlanetUpdate.travelingUpkeep,\\n            fromPlanetUpdate.overflow\\n        );\\n    }\\n\\n    function _setAccumulatedAttack(ResolutionState memory rState, PlanetUpdateState memory toPlanetUpdate) internal {\\n        if (!rState.taxed) {\\n            AccumulatedAttack storage attack = _attacks[toPlanetUpdate.location][rState.fleetOwner][rState.arrivalTime];\\n\\n            // NOTE: target is required for the case where a different player capture the planet in-between\\n            //  otherwise, that player would be hitted with higher attack than would be fair\\n            //  hmm would it acutally ? the accumulatedDefenseAdded would still be counted\\n            //  Indeed, the only real player affected by _attacks[location][fleetOwner][arrivalTime] is the fleetOwner\\n            //  regardless of who is owner of the planet\\n            // attack.target = toPlanetUpdate.owner;\\n            // we leave this as is as we do not want to change the struct\\n            attack.damageCausedSoFar = rState.defenderLoss + rState.inFlightPlanetLoss + rState.accumulatedDefenseAdded;\\n            attack.numAttackSpent =\\n                rState.attackerLoss +\\n                rState.accumulatedAttackAdded +\\n                // when victorius we consider the full number of spaceship as used\\n                // this way if a combined attack arrive later, it can still count the whole attack and get a refund\\n                (rState.victory ? toPlanetUpdate.numSpaceships : 0);\\n            attack.averageAttackPower = rState.attackPower;\\n        }\\n    }\\n\\n    function _combinedRefund(\\n        ResolutionState memory rState,\\n        PlanetUpdateState memory toPlanetUpdate\\n    ) internal view returns (uint256 accumulationRefund) {\\n        _updateAccumulation(rState, toPlanetUpdate);\\n        if (rState.accumulatedAttackAdded > 0) {\\n            uint16 attack = rState.attackPower;\\n            uint16 defense = _defense(toPlanetUpdate.data);\\n            uint256 numAttack = rState.fleetQuantity + rState.accumulatedAttackAdded;\\n            (uint32 attackerLoss, ) = _computeFight(numAttack, rState.accumulatedDefenseAdded, attack, defense);\\n            if (rState.accumulatedAttackAdded > attackerLoss) {\\n                accumulationRefund = rState.accumulatedAttackAdded - attackerLoss;\\n                if (accumulationRefund > rState.accumulatedAttackAdded) {\\n                    rState.accumulatedAttackAdded = 0;\\n                } else {\\n                    rState.accumulatedAttackAdded = uint32(uint256(rState.accumulatedAttackAdded) - accumulationRefund);\\n                }\\n            }\\n        }\\n    }\\n\\n    function _createResolutionState(\\n        Fleet storage fleet,\\n        uint256 from\\n    ) internal view returns (ResolutionState memory rState) {\\n        uint32 q = fleet.quantity >> 31 == 1 ? 0 : fleet.quantity;\\n        rState.fleetOwner = fleet.owner;\\n        rState.fleetLaunchTime = fleet.launchTime;\\n        rState.originalQuantity = q;\\n        rState.fleetQuantity = q;\\n        rState.futureExtraProduction = fleet.futureExtraProduction;\\n        rState.fromData = _planetData(from);\\n        rState.attackPower = _attack(rState.fromData);\\n    }\\n\\n    function _recordOrbitLossAccountingForFleetOrigin(\\n        ResolutionState memory rState,\\n        FleetResolution memory resolution\\n    ) internal {\\n        if (rState.inFlightFleetLoss > 0) {\\n            uint256 timeSlot = rState.fleetLaunchTime / (_frontrunningDelay / 2);\\n\\n            // NOTE we already computed that destroyed cannot be smaller than inFlightFleetLoss\\n            //  see _computeInFlightLossForFleet\\n            _inFlight[resolution.from][timeSlot].destroyed -= rState.inFlightFleetLoss;\\n        }\\n    }\\n\\n    function _computeResolutionResult(\\n        ResolutionState memory rState,\\n        PlanetUpdateState memory toPlanetUpdate\\n    ) internal view {\\n        if (rState.taxed) {\\n            rState.fleetQuantity = uint32(\\n                uint256(rState.fleetQuantity) - (uint256(rState.fleetQuantity) * _giftTaxPer10000) / 10000\\n            );\\n        }\\n        if (rState.gifting) {\\n            _computeGiftingResolutionResult(rState, toPlanetUpdate);\\n        } else {\\n            _computeAttackResolutionResult(rState, toPlanetUpdate);\\n        }\\n    }\\n\\n    function _computeGiftingResolutionResult(\\n        ResolutionState memory rState,\\n        PlanetUpdateState memory toPlanetUpdate\\n    ) internal view {\\n        uint256 newNumSpaceships = toPlanetUpdate.numSpaceships +\\n            rState.fleetQuantity +\\n            _combinedRefund(rState, toPlanetUpdate);\\n        if (newNumSpaceships >= ACTIVE_MASK) {\\n            newNumSpaceships = ACTIVE_MASK - 1;\\n        }\\n\\n        toPlanetUpdate.numSpaceships = uint32(newNumSpaceships);\\n        if (!toPlanetUpdate.active) {\\n            // NOTE: not active, overflow is applied on cap = 0\\n            if (toPlanetUpdate.numSpaceships > toPlanetUpdate.overflow) {\\n                toPlanetUpdate.overflow = toPlanetUpdate.numSpaceships;\\n            }\\n        } else {\\n            uint32 cap = uint32(_capWhenActive(_production(toPlanetUpdate.data)));\\n            if (_productionCapAsDuration > 0 && newNumSpaceships > cap) {\\n                if (toPlanetUpdate.numSpaceships - cap > toPlanetUpdate.overflow) {\\n                    toPlanetUpdate.overflow = uint32(toPlanetUpdate.numSpaceships - cap);\\n                }\\n            } else {\\n                toPlanetUpdate.overflow = 0;\\n            }\\n        }\\n    }\\n\\n    function _updateAccumulation(ResolutionState memory rState, PlanetUpdateState memory toPlanetUpdate) internal view {\\n        // TODO 45min config ?\\n        if (!rState.taxed && block.timestamp < rState.arrivalTime + 45 minutes) {\\n            AccumulatedAttack memory acc = _attacks[toPlanetUpdate.location][rState.fleetOwner][rState.arrivalTime];\\n\\n            // TODO  acc.target == toPlanetUpdate.owner || toPlanetUpdate.owner == fleetOwner  so your combined attack works when you get it\\n            // what about your allies ?\\n            // taxed work as he accumulated attack is already shared with allies (s)\\n            // so we should not need to modify here ?\\n            // if (acc.target == toPlanetUpdate.owner && acc.numAttackSpent != 0) {\\n            if (acc.numAttackSpent != 0) {\\n                rState.attackPower = uint16(\\n                    (uint256(rState.attackPower) *\\n                        uint256(rState.fleetQuantity) +\\n                        uint256(acc.averageAttackPower) *\\n                        uint256(acc.numAttackSpent)) / (uint256(rState.fleetQuantity) + uint256(acc.numAttackSpent))\\n                );\\n                rState.accumulatedAttackAdded = acc.numAttackSpent;\\n                rState.accumulatedDefenseAdded = acc.damageCausedSoFar;\\n            }\\n        }\\n    }\\n\\n    function _computeAttackResolutionResult(\\n        ResolutionState memory rState,\\n        PlanetUpdateState memory toPlanetUpdate\\n    ) internal view {\\n        // NOTE natives come back to power once numSPaceships == 0 and planet not active\\n        if (!toPlanetUpdate.active && toPlanetUpdate.numSpaceships < _natives(toPlanetUpdate.data)) {\\n            _updatePlanetUpdateStateAndResolutionStateForNativeAttack(rState, toPlanetUpdate);\\n        } else {\\n            _updateAccumulation(rState, toPlanetUpdate);\\n\\n            _updatePlanetUpdateStateAndResolutionStateForPlanetAttack(rState, toPlanetUpdate);\\n        }\\n    }\\n\\n    function _updatePlanetUpdateStateAndResolutionStateForNativeAttack(\\n        ResolutionState memory rState,\\n        PlanetUpdateState memory toPlanetUpdate\\n    ) internal view {\\n        // NOTE: when we are dealing with native attacks, we do not consider combined attacks\\n        // TODO We need to consider that case in the UI\\n        uint16 attack = _attack(rState.fromData);\\n        uint16 defense = _defense(toPlanetUpdate.data);\\n        uint16 natives = _natives(toPlanetUpdate.data);\\n        (uint32 attackerLoss, uint32 defenderLoss) = _computeFight(rState.fleetQuantity, natives, attack, defense);\\n        rState.attackerLoss = attackerLoss;\\n        if (defenderLoss == natives && rState.fleetQuantity > attackerLoss) {\\n            // (attackerLoss: 0, defenderLoss: 0) means that numAttack was zero as natives cannot be zero\\n            toPlanetUpdate.numSpaceships = rState.fleetQuantity - attackerLoss;\\n            rState.defenderLoss = defenderLoss;\\n            rState.victory = true;\\n            toPlanetUpdate.newOwner = rState.fleetOwner;\\n            // solhint-disable-next-line no-empty-blocks\\n        }\\n        // NOTE else (attacker lost) then nothing happen\\n    }\\n\\n    function _updatePlanetUpdateStateAndResolutionStateForPlanetAttack(\\n        ResolutionState memory rState,\\n        PlanetUpdateState memory toPlanetUpdate\\n    ) internal view {\\n        _updateResolutionStateFromOrbitDefense(rState, toPlanetUpdate);\\n        uint256 numDefense = toPlanetUpdate.numSpaceships +\\n            rState.accumulatedDefenseAdded +\\n            rState.orbitDefense1 +\\n            rState.orbitDefense2;\\n        uint16 production = _production(toPlanetUpdate.data);\\n\\n        if (numDefense == 0 && rState.fleetQuantity > 0) {\\n            // scenario where there is actually no defense on the place,\\n\\n            toPlanetUpdate.newOwner = rState.fleetOwner;\\n            toPlanetUpdate.numSpaceships = rState.fleetQuantity;\\n            if (!toPlanetUpdate.active) {\\n                // numDefense = 0 so numAttack is the overflow, attacker took over\\n                toPlanetUpdate.overflow = toPlanetUpdate.numSpaceships;\\n            } else {\\n                if (_productionCapAsDuration > 0) {\\n                    uint32 cap = uint32(_capWhenActive(production));\\n                    if (toPlanetUpdate.numSpaceships > cap) {\\n                        // numDefense = 0 so numAttack is the overflow, attacker took over\\n                        toPlanetUpdate.overflow = uint32(toPlanetUpdate.numSpaceships - cap);\\n                    } else {\\n                        toPlanetUpdate.overflow = 0;\\n                    }\\n                }\\n            }\\n\\n            rState.victory = true;\\n        } else {\\n            _computeAttack(rState, toPlanetUpdate, numDefense);\\n            _computeTravelingUpkeepReductionFromDefenseLoss(rState, toPlanetUpdate, production);\\n        }\\n    }\\n\\n    function _updateResolutionStateFromOrbitDefense(\\n        ResolutionState memory rState,\\n        PlanetUpdateState memory toPlanetUpdate\\n    ) internal view {\\n        // -----------------------------------------------------------------------------------------------------------\\n        // consider fleets that just departed from the planet (used to prevent front-running, see fleet sending)\\n        // -----------------------------------------------------------------------------------------------------------\\n        uint256 timeSlot = block.timestamp / (_frontrunningDelay / 2);\\n        InFlight storage slot1 = _inFlight[toPlanetUpdate.location][timeSlot - 1];\\n        rState.orbitDefense1 = slot1.flying > 2 ** 31 ? 2 ** 31 - 1 : uint32(slot1.flying);\\n        rState.orbitDefenseDestroyed1 = slot1.destroyed > 2 ** 31 ? 2 ** 31 - 1 : uint32(slot1.destroyed);\\n        InFlight storage slot2 = _inFlight[toPlanetUpdate.location][timeSlot];\\n        rState.orbitDefense2 = slot2.flying > 2 ** 31 ? 2 ** 31 - 1 : uint32(slot2.flying);\\n        rState.orbitDefenseDestroyed2 = slot2.destroyed > 2 ** 31 ? 2 ** 31 - 1 : uint32(slot2.destroyed);\\n    }\\n\\n    // solhint-disable-next-line code-complexity\\n    function _computeAttack(\\n        ResolutionState memory rState,\\n        PlanetUpdateState memory toPlanetUpdate,\\n        uint256 numDefense\\n    ) internal view {\\n        uint16 attack = rState.attackPower;\\n        uint16 defense = _defense(toPlanetUpdate.data);\\n        uint256 numAttack = rState.fleetQuantity + rState.accumulatedAttackAdded;\\n        (uint32 attackerLoss, uint32 defenderLoss) = _computeFight(numAttack, numDefense, attack, defense);\\n        rState.defenderLoss = defenderLoss;\\n        rState.attackerLoss = rState.accumulatedAttackAdded > attackerLoss\\n            ? 0\\n            : attackerLoss - rState.accumulatedAttackAdded;\\n\\n        // (attackerLoss: 0, defenderLoss: 0) could either mean attack was zero or defense was zero :\\n        if (rState.fleetQuantity > 0 && rState.defenderLoss == numDefense) {\\n            // NOTE Attacker wins\\n\\n            // all orbiting fleets are destroyed, inFlightPlanetLoss is all that is left\\n            uint256 inFlightPlanetLoss = numDefense - toPlanetUpdate.numSpaceships - rState.accumulatedDefenseAdded;\\n            if (inFlightPlanetLoss > ACTIVE_MASK) {\\n                // cap it\\n                // TODO investigate potential issues\\n                inFlightPlanetLoss = ACTIVE_MASK - 1;\\n            }\\n            rState.inFlightPlanetLoss = uint32(inFlightPlanetLoss);\\n\\n            rState.defenderLoss = rState.defenderLoss - rState.inFlightPlanetLoss;\\n\\n            toPlanetUpdate.numSpaceships = rState.fleetQuantity - rState.attackerLoss;\\n            rState.victory = true;\\n\\n            toPlanetUpdate.newOwner = rState.fleetOwner;\\n\\n            if (!toPlanetUpdate.active) {\\n                // attack took over, overflow is numSpaceships\\n                toPlanetUpdate.overflow = toPlanetUpdate.numSpaceships;\\n            } else {\\n                if (_productionCapAsDuration > 0) {\\n                    uint16 production = _production(toPlanetUpdate.data);\\n                    uint32 cap = uint32(_capWhenActive(production));\\n                    if (toPlanetUpdate.numSpaceships > cap) {\\n                        if (toPlanetUpdate.numSpaceships - cap > toPlanetUpdate.overflow) {\\n                            toPlanetUpdate.overflow = toPlanetUpdate.numSpaceships - cap;\\n                        }\\n                    } else {\\n                        toPlanetUpdate.overflow = 0;\\n                    }\\n                }\\n            }\\n        } else if (rState.attackerLoss == rState.fleetQuantity) {\\n            // NOTE Defender wins\\n\\n            if (defenderLoss > toPlanetUpdate.numSpaceships + rState.accumulatedDefenseAdded) {\\n                rState.inFlightPlanetLoss =\\n                    defenderLoss -\\n                    toPlanetUpdate.numSpaceships -\\n                    rState.accumulatedDefenseAdded;\\n\\n                toPlanetUpdate.numSpaceships = 0;\\n                // TODO change owner already if incative ?\\n                //  not needed though as this is the same has having numSpaceships = 1 and become zero over time\\n\\n                if (rState.orbitDefense1 >= rState.inFlightPlanetLoss) {\\n                    rState.orbitDefense1 -= rState.inFlightPlanetLoss;\\n                    rState.orbitDefenseDestroyed1 += rState.inFlightPlanetLoss;\\n                } else {\\n                    rState.orbitDefenseDestroyed1 += rState.orbitDefense1;\\n                    uint32 extra = (rState.inFlightPlanetLoss - rState.orbitDefense1);\\n                    if (rState.orbitDefense2 >= extra) {\\n                        rState.orbitDefense2 -= extra;\\n                        rState.orbitDefenseDestroyed2 += extra;\\n                    } else {\\n                        rState.orbitDefenseDestroyed2 += rState.orbitDefense2;\\n                        rState.orbitDefense2 = 0; // should never reach minus but let simply set it to zero\\n                    }\\n                    rState.orbitDefense1 = 0;\\n                }\\n            } else {\\n                toPlanetUpdate.numSpaceships =\\n                    toPlanetUpdate.numSpaceships +\\n                    rState.accumulatedDefenseAdded -\\n                    defenderLoss;\\n\\n                // TODO change owner already if incative and numSpaceship == 0 (like above)\\n                //  not needed though as this is the same has having numSpaceships = 1 and become zero over time\\n            }\\n\\n            // same as numSpaceshipAtArrival - toPlanetUpdate.numSpaceship;\\n            rState.defenderLoss = rState.defenderLoss - rState.inFlightPlanetLoss - rState.accumulatedDefenseAdded;\\n\\n            if (!toPlanetUpdate.active) {\\n                if (defenderLoss > toPlanetUpdate.overflow) {\\n                    toPlanetUpdate.overflow = 0;\\n                } else {\\n                    toPlanetUpdate.overflow -= defenderLoss;\\n                }\\n            } else {\\n                if (_productionCapAsDuration > 0) {\\n                    uint16 production = _production(toPlanetUpdate.data);\\n                    uint32 cap = uint32(_capWhenActive(production));\\n                    if (toPlanetUpdate.numSpaceships > cap) {\\n                        if (defenderLoss <= toPlanetUpdate.overflow) {\\n                            toPlanetUpdate.overflow -= defenderLoss;\\n                        } else {\\n                            toPlanetUpdate.overflow = 0;\\n                        }\\n                    } else {\\n                        toPlanetUpdate.overflow = 0;\\n                    }\\n                }\\n            }\\n        } else {\\n            // should not happen\\n            // because we check for numDefense == 0 before performing the attack, see _updatePlanetUpdateStateAndResolutionStateForPlanetAttack\\n            revert(\\\"ZERO_ZERO\\\");\\n        }\\n    }\\n\\n    function _computeFight(\\n        uint256 numAttack,\\n        uint256 numDefense,\\n        uint256 attack,\\n        uint256 defense\\n    ) internal view returns (uint32 attackerLoss, uint32 defenderLoss) {\\n        if (numAttack == 0 || numDefense == 0) {\\n            // this edge case need to be considered,\\n            // as the result of this function cannot tell from it whos is winning here\\n            return (0, 0);\\n        }\\n\\n        uint256 attackFactor = numAttack *\\n            ((1000000 - _fleetSizeFactor6) + ((_fleetSizeFactor6 * numAttack) / numDefense));\\n        uint256 attackDamage = (attackFactor * attack) / defense / 1000000;\\n\\n        if (numDefense > attackDamage) {\\n            // attack fails\\n            attackerLoss = uint32(numAttack); // all attack destroyed\\n            defenderLoss = uint32(attackDamage); // 1 spaceship will be left at least as attackDamage < numDefense\\n        } else {\\n            // attack succeed\\n            uint256 defenseFactor = numDefense *\\n                ((1000000 - _fleetSizeFactor6) + ((_fleetSizeFactor6 * numDefense) / numAttack));\\n            uint256 defenseDamage = uint32((defenseFactor * defense) / attack / 1000000);\\n\\n            if (defenseDamage >= numAttack) {\\n                defenseDamage = numAttack - 1; // ensure 1 spaceship left\\n            }\\n\\n            attackerLoss = uint32(defenseDamage);\\n            defenderLoss = uint32(numDefense); // all defense destroyed\\n        }\\n    }\\n\\n    function _computeTravelingUpkeepReductionFromDefenseLoss(\\n        ResolutionState memory rState,\\n        PlanetUpdateState memory toPlanetUpdate,\\n        uint16 production\\n    ) internal view {\\n        // allow the attacker to pay for upkeep as part of the attack\\n        // only get to keep the upkeep that was there as a result of spaceships sent away\\n\\n        uint256 capWhenActive = _capWhenActive(production);\\n\\n        int256 totalDefenseLoss = int256(uint256(rState.defenderLoss) + uint256(rState.inFlightPlanetLoss));\\n        int256 newTravelingUpkeep = int256(toPlanetUpdate.travelingUpkeep) - totalDefenseLoss;\\n        if (newTravelingUpkeep < -int256(capWhenActive)) {\\n            newTravelingUpkeep = -int256(capWhenActive);\\n        }\\n        toPlanetUpdate.travelingUpkeep = int40(newTravelingUpkeep);\\n    }\\n\\n    function _recordInOrbitLossAfterAttack(\\n        ResolutionState memory rState,\\n        PlanetUpdateState memory toPlanetUpdate\\n    ) internal {\\n        if (rState.inFlightPlanetLoss > 0) {\\n            InFlight storage slot1 = _inFlight[toPlanetUpdate.location][block.timestamp / (_frontrunningDelay / 2) - 1];\\n            slot1.flying = rState.orbitDefense1;\\n            slot1.destroyed = rState.orbitDefenseDestroyed1;\\n\\n            InFlight storage slot2 = _inFlight[toPlanetUpdate.location][block.timestamp / (_frontrunningDelay / 2)];\\n            slot2.flying = rState.orbitDefense2;\\n            slot2.destroyed = rState.orbitDefenseDestroyed2;\\n        }\\n    }\\n\\n    function _callWithGas(address to, bytes memory data, uint256 gas) internal {\\n        // We want to ensure enough gas were given for the generator, but no more\\n        // This way if the generator is broken/compromised (we are planning to update it)\\n        // then this will always continue to work\\n        // Reversely, a player have to provide enough gas\\n        // and we want to ensure the player can't force a revert on the hook\\n        // In particular. to prevent players to make a call to `remove` fails\\n\\n        if (to != address(0)) {\\n            // we could do the check prior:\\n            // uint256 gasAvailable = gasleft() - 2000;\\n            // require(gasAvailable - gasAvailable / 64  >= gas, \\\"NOT_ENOUGH_GAS_FOR_INNER_CALL\\\");\\n            // to.call{gas: gas}(data);\\n            // but we instead chose to do the check after.\\n            // for more info see: https://ronan.eth.limo/blog/ethereum-gas-dangers/\\n\\n            to.call{gas: gas}(data);\\n            // we use after the gas check as this allow us to not require heavy gas use if not needed\\n            // instead of + 100,000 for 96,000 gas we can just add 1,524 gas (+ a bit more)\\n            require(gasleft() > gas / 63, \\\"NOT_ENOUGH_GAS_FOR_INNER_CALL\\\");\\n        }\\n    }\\n\\n    function _generator() internal view returns (address generator) {\\n        assembly {\\n            // keccak256(\\\"generator\\\") - 1\\n            generator := sload(0x27ec6af4a6510eb9b7e0cc7f39415b7f15e430e53eb0cd3997e7c7e0cf680f6e)\\n        }\\n    }\\n\\n    function _notifyGeneratorAdd(address player, uint256 amount) internal {\\n        _callWithGas(_generator(), abi.encodeWithSelector(IOnStakeChange.add.selector, player, amount), 96000);\\n    }\\n\\n    function _notifyGeneratorRemove(address player, uint256 amount) internal {\\n        _callWithGas(_generator(), abi.encodeWithSelector(IOnStakeChange.remove.selector, player, amount), 96000);\\n    }\\n\\n    function _notifyGeneratorMove(address from, address to, uint256 amount) internal {\\n        _callWithGas(_generator(), abi.encodeWithSelector(IOnStakeChange.move.selector, from, to, amount), 192000);\\n    }\\n\\n    // ---------------------------------------------------------------------------------------------------------------\\n    // PLANET STATS\\n    // ---------------------------------------------------------------------------------------------------------------\\n\\n    function _planetData(uint256 location) internal view returns (bytes32) {\\n        return keccak256(abi.encodePacked(_genesis, location));\\n    }\\n\\n    function _subLocation(bytes32 data) internal pure returns (int8 subX, int8 subY) {\\n        subX = 1 - int8(data.value8Mod(0, 3));\\n        subY = 1 - int8(data.value8Mod(2, 3));\\n    }\\n\\n    function _stake(bytes32 data) internal view returns (uint32) {\\n        require(_exists(data), \\\"PLANET_NOT_EXISTS\\\");\\n        // return data.normal16(4, 0x000400050005000A000A000F000F00140014001E001E00280028005000500064);\\n        uint8 productionIndex = data.normal8(12); // production affect the stake value\\n\\n        // TODO remove or decide otherwise:\\n        // uint16 offset = data.normal16(4, 0x0000000100010002000200030003000400040005000500060006000700070008);\\n        // uint16 stakeIndex = productionIndex + offset;\\n        // if (stakeIndex < 4) {\\n        //     stakeIndex = 0;\\n        // } else if (stakeIndex > 19) {\\n        //     stakeIndex = 15;\\n        // } else {\\n        //     stakeIndex -= 4;\\n        // }\\n        uint16 stakeIndex = productionIndex;\\n        return\\n            uint32(\\n                uint256(\\n                    uint16(uint8(_stakeRange[stakeIndex * 2])) * 0x100 + uint16(uint8(_stakeRange[stakeIndex * 2 + 1]))\\n                ) * _stakeMultiplier10000th\\n            );\\n    }\\n\\n    function _production(bytes32 data) internal pure returns (uint16) {\\n        require(_exists(data), \\\"PLANET_NOT_EXISTS\\\");\\n        // TODO TRY : 1800,2100,2400,2700,3000,3300,3600, 3600, 3600, 3600,4000,4400,4800,5400,6200,7200 ?\\n\\n        // 1800,2100,2400,2700,3000,3300,3600, 3600, 3600, 3600,4200,5400,6600,7800,9000,12000\\n        // 0x0708083409600a8c0bb80ce40e100e100e100e101068151819c81e7823282ee0\\n        return data.normal16(12, 0x0708083409600a8c0bb80ce40e100e100e100e101068151819c81e7823282ee0); // per hour\\n    }\\n\\n    function _capWhenActive(uint16 production) internal view returns (uint256) {\\n        return _acquireNumSpaceships + (uint256(production) * _productionCapAsDuration) / 1 hours;\\n    }\\n\\n    function _attack(bytes32 data) internal pure returns (uint16) {\\n        require(_exists(data), \\\"PLANET_NOT_EXISTS\\\");\\n        return 4000 + data.normal8(20) * 400; // 4,000 - 7,000 - 10,000\\n    }\\n\\n    function _defense(bytes32 data) internal pure returns (uint16) {\\n        require(_exists(data), \\\"PLANET_NOT_EXISTS\\\");\\n        return 4000 + data.normal8(28) * 400; // 4,000 - 7,000 - 10,000\\n    }\\n\\n    function _speed(bytes32 data) internal pure returns (uint16) {\\n        require(_exists(data), \\\"PLANET_NOT_EXISTS\\\");\\n        return 5005 + data.normal8(36) * 333; // 5,005 - 7,502.5 - 10,000\\n    }\\n\\n    function _natives(bytes32 data) internal pure returns (uint16) {\\n        require(_exists(data), \\\"PLANET_NOT_EXISTS\\\");\\n        return 15000 + data.normal8(44) * 3000; // 15,000 - 37,500 - 60,000\\n    }\\n\\n    function _exists(bytes32 data) internal pure returns (bool) {\\n        return data.value8Mod(52, 16) == 1; // 16 => 36 so : 1 planet per 6 (=24 min unit) square\\n        // also:\\n        // 20000 average starting numSpaceships (or max?)\\n        // speed of min unit = 30 min ( 1 hour per square)\\n        // production : 20000 per 6 hours\\n        // exit : 3 days ? => 72 distance\\n    }\\n\\n    // ---------------------------------------------------------------------------------------------------------------\\n    // GETTERS\\n    // ---------------------------------------------------------------------------------------------------------------\\n\\n    function _getPlanet(uint256 location) internal view returns (Planet storage) {\\n        return _planets[location];\\n    }\\n\\n    function _getPlanetStats(uint256 location) internal view returns (PlanetStats memory) {\\n        bytes32 data = _planetData(location);\\n        require(_exists(data), \\\"no planet in this location\\\");\\n\\n        (int8 subX, int8 subY) = _subLocation(data);\\n        return\\n            PlanetStats({\\n                subX: subX,\\n                subY: subY,\\n                stake: _stake(data),\\n                production: _production(data),\\n                attack: _attack(data),\\n                defense: _defense(data),\\n                speed: _speed(data),\\n                natives: _natives(data)\\n            });\\n    }\\n\\n    // ---------------------------------------------------------------------------------------------------------------\\n    // UTILS\\n    // ---------------------------------------------------------------------------------------------------------------\\n\\n    function _activeNumSpaceships(uint32 numSpaceshipsData) internal pure returns (bool active, uint32 numSpaceships) {\\n        active = (numSpaceshipsData & ACTIVE_MASK) == ACTIVE_MASK;\\n        numSpaceships = numSpaceshipsData % (ACTIVE_MASK);\\n    }\\n\\n    function _setActiveNumSpaceships(bool active, uint32 numSpaceships) internal pure returns (uint32) {\\n        return uint32((active ? ACTIVE_MASK : 0) + numSpaceships);\\n    }\\n\\n    function _msgSender() internal view returns (address) {\\n        return msg.sender; // TODO metatx\\n    }\\n\\n    modifier whenNotPaused() {\\n        if (_bootstrapSessionEndTime > 0) {\\n            uint256 timestamp = block.timestamp;\\n            uint256 pauseStart = _bootstrapSessionEndTime;\\n            uint256 pauseEnd = _infinityStartTime;\\n\\n            require(timestamp < pauseStart || timestamp >= pauseEnd, \\\"PAUSED\\\");\\n        }\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x499bac08f4fc743771473d6fe8c392ff260cae9125737c70990dc8babba461b5\",\"license\":\"AGPL-3.0\"},\"src/outerspace/interfaces/IOnStakeChange.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.9;\\n\\ninterface IOnStakeChange {\\n    function add(address account, uint256 amount) external;\\n\\n    function remove(address account, uint256 amount) external;\\n\\n    function move(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external;\\n}\\n\",\"keccak256\":\"0xeb5f9874b6b35990ada4462b815e369b00969e2a3338741f79e9d88037bdf6fa\",\"license\":\"AGPL-3.0\"},\"src/outerspace/interfaces/IOuterSpace.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.9;\\n\\nimport \\\"./IOuterSpaceGenericRead.sol\\\";\\nimport \\\"./IOuterSpaceFleetsRead.sol\\\";\\nimport \\\"./IOuterSpaceFleetsCommit.sol\\\";\\nimport \\\"./IOuterSpaceFleetsReveal.sol\\\";\\nimport \\\"./IOuterSpacePlanets.sol\\\";\\nimport \\\"./IOuterSpaceInformation.sol\\\";\\nimport \\\"./IOuterSpaceStaking.sol\\\";\\n\\n// solhint-disable-next-line no-empty-blocks\\ninterface IOuterSpace is\\n    IOuterSpaceGenericRead,\\n    IOuterSpaceFleetsRead,\\n    IOuterSpaceFleetsCommit,\\n    IOuterSpaceFleetsReveal,\\n    IOuterSpacePlanets,\\n    IOuterSpaceInformation,\\n    IOuterSpaceStaking\\n{\\n\\n}\\n\",\"keccak256\":\"0x85c1d717005d535037a3149f7d2c2c1323125f8c2280361d3d23ad568c6719d6\",\"license\":\"AGPL-3.0\"},\"src/outerspace/interfaces/IOuterSpaceFleetsCommit.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.9;\\n\\nimport \\\"../types/ImportingOuterSpaceTypes.sol\\\";\\nimport \\\"../events/ImportingOuterSpaceEvents.sol\\\";\\n\\ninterface IOuterSpaceFleetsCommit is ImportingOuterSpaceTypes, ImportingOuterSpaceEvents {\\n    function send(uint256 from, uint32 quantity, bytes32 toHash) external;\\n\\n    function sendFor(FleetLaunch calldata launch) external;\\n\\n    function sendWithPayee(uint256 from, uint32 quantity, bytes32 toHash, address payable payee) external payable;\\n\\n    function sendForWithPayee(FleetLaunch calldata launch, address payable payee) external payable;\\n\\n    function sendForMultipleWithPayee(FleetLaunch[] calldata launches, address payable payee) external payable;\\n}\\n\",\"keccak256\":\"0x191a3ba3dd4d1347c2a78797dab54624c432e295b3d5fb6d7dce14f1f6648cba\",\"license\":\"AGPL-3.0\"},\"src/outerspace/interfaces/IOuterSpaceFleetsRead.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.9;\\n\\nimport \\\"../types/ImportingOuterSpaceTypes.sol\\\";\\nimport \\\"../events/ImportingOuterSpaceEvents.sol\\\";\\n\\ninterface IOuterSpaceFleetsRead is ImportingOuterSpaceTypes, ImportingOuterSpaceEvents {\\n    function getFleet(\\n        uint256 fleetId,\\n        uint256 from\\n    )\\n        external\\n        view\\n        returns (\\n            address owner,\\n            uint40 launchTime,\\n            uint32 quantity,\\n            uint64 flyingAtLaunch, // can be more than quantity if multiple fleet were launched around the same time from the same planet\\n            uint64 destroyedAtLaunch\\n        );\\n\\n    function getFleetData(uint256 fleetId, uint256 from) external view returns (FleetData memory data);\\n}\\n\",\"keccak256\":\"0x121ef0b19c28b28644b83e04e980df77e6c85c0876deb9b92dc7f1af427f1d9f\",\"license\":\"AGPL-3.0\"},\"src/outerspace/interfaces/IOuterSpaceFleetsReveal.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.9;\\n\\nimport \\\"../types/ImportingOuterSpaceTypes.sol\\\";\\nimport \\\"../events/ImportingOuterSpaceEvents.sol\\\";\\n\\ninterface IOuterSpaceFleetsReveal is ImportingOuterSpaceTypes, ImportingOuterSpaceEvents {\\n    function resolveFleet(uint256 fleetId, FleetResolution calldata resolution) external;\\n}\\n\",\"keccak256\":\"0x3ae06dfdeb3e7e456ab977a28475dba0e006058fda35dd125000dcd350d9c3cc\",\"license\":\"AGPL-3.0\"},\"src/outerspace/interfaces/IOuterSpaceGenericRead.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.9;\\n\\ninterface IOuterSpaceGenericRead {\\n    function read(uint256 slot) external view returns (bytes32 data);\\n\\n    function readMultiple(uint256[] calldata slots) external view returns (bytes32[] memory data);\\n\\n    function readRange(uint256 start, uint256 num) external view returns (bytes32[] memory data);\\n}\\n\",\"keccak256\":\"0x997480b990acad5e039e596912720a17031168246e4284804c4eadf1d297e51b\",\"license\":\"AGPL-3.0\"},\"src/outerspace/interfaces/IOuterSpaceInformation.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.9;\\n\\nimport \\\"../types/ImportingOuterSpaceTypes.sol\\\";\\nimport \\\"../facets/OuterSpaceFacetBase.sol\\\";\\n\\ninterface IOuterSpaceInformation is ImportingOuterSpaceTypes {\\n    function getGeneisHash() external view returns (bytes32);\\n\\n    function getConfig() external view returns (OuterSpaceFacetBase.Config memory);\\n\\n    function getAllianceRegistry() external view returns (AllianceRegistry);\\n\\n    function getDiscovered() external view returns (Discovered memory);\\n\\n    function getPlanetStates(\\n        uint256[] calldata locations\\n    ) external view returns (ExternalPlanet[] memory planetStates, Discovered memory discovered);\\n}\\n\",\"keccak256\":\"0xf683fd391173e258d53c72d0b87510b8291e9ec7eea0340e43ab4533ba3e82fd\",\"license\":\"AGPL-3.0\"},\"src/outerspace/interfaces/IOuterSpacePlanets.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.9;\\n\\nimport \\\"../types/ImportingOuterSpaceTypes.sol\\\";\\nimport \\\"../events/ImportingOuterSpaceEvents.sol\\\";\\n\\ninterface IOuterSpacePlanets is ImportingOuterSpaceTypes, ImportingOuterSpaceEvents {\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    function ownerOf(uint256 location) external view returns (address);\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 location\\n    ) external;\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 location,\\n        bytes calldata data\\n    ) external;\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 location\\n    ) external;\\n\\n    function ownerAndOwnershipStartTimeOf(uint256 location)\\n        external\\n        view\\n        returns (address owner, uint40 ownershipStartTime);\\n\\n    function getPlanet(uint256 location) external view returns (ExternalPlanet memory state, PlanetStats memory stats);\\n\\n    function getPlanetState(uint256 location) external view returns (ExternalPlanet memory state);\\n\\n    function getUpdatedPlanetState(uint256 location) external view returns (ExternalPlanet memory state);\\n}\\n\",\"keccak256\":\"0x7aa4c574cc1fdaa5000c3c5dbda119c77ec478456bfbc4aae334112d2542dc03\",\"license\":\"AGPL-3.0\"},\"src/outerspace/interfaces/IOuterSpaceStaking.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.9;\\n\\nimport \\\"../types/ImportingOuterSpaceTypes.sol\\\";\\n\\ninterface IOuterSpaceStaking is ImportingOuterSpaceTypes {\\n    function onTokenTransfer(address, uint256 amount, bytes calldata data) external returns (bool);\\n\\n    function onTokenPaidFor(address, address forAddress, uint256 amount, bytes calldata data) external returns (bool);\\n\\n    function acquireViaTransferFrom(uint256 location, uint256 amount) external;\\n\\n    function acquireViaFreeTokenTransferFrom(uint256 location, uint256 amount) external;\\n\\n    function acquireViaNativeTokenAndStakingToken(\\n        uint256 location,\\n        uint256 amountToMint,\\n        uint256 tokenAmount\\n    ) external payable;\\n\\n    function acquireMultipleViaNativeTokenAndStakingToken(\\n        uint256[] memory locations,\\n        uint256 amountToMint,\\n        uint256 tokenAmount\\n    ) external payable;\\n\\n    function exitFor(address owner, uint256 location) external;\\n\\n    function exitMultipleFor(address owner, uint256[] calldata locations) external;\\n\\n    function fetchAndWithdrawFor(address owner, uint256[] calldata locations) external;\\n\\n    function balanceToWithdraw(address owner) external view returns (uint256);\\n\\n    function withdrawFor(address owner) external;\\n}\\n\",\"keccak256\":\"0xd376c711522b5ff11765e179ffcca352831c0fcada9b479632eb4bc52b2f629a\",\"license\":\"AGPL-3.0\"},\"src/outerspace/types/ImportingOuterSpaceTypes.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../interfaces/IOnStakeChange.sol\\\";\\n\\ninterface ImportingOuterSpaceTypes {\\n    // front running protection : _frontruunningDelay / 2 slots\\n    struct InFlight {\\n        uint32 flying;\\n        uint32 destroyed;\\n        // STORE last attack too, to compute combined attack on it ? uint128 is plainty enough\\n    }\\n\\n    // TODO remove\\n    // struct Account {\\n    //     // TODO add more info\\n    //     // stake for example ? => coild it be used by staking ?\\n    //     // numPlanets ?\\n    //     // numSpaceships ? => probably too much ?\\n    //     uint64 totalProduction;\\n    //     uint64 productionDebt;\\n    // }\\n\\n    struct Discovered {\\n        uint32 minX;\\n        uint32 maxX;\\n        uint32 minY;\\n        uint32 maxY;\\n    }\\n\\n    // TODO split in 2 structs ? PlanetOwnership and PlanetState ?\\n    struct Planet {\\n        address owner;\\n        uint40 ownershipStartTime; // ~ 34865 years, should be enough :)\\n        uint40 exitStartTime; // ~ 34865 years, should be enough :)\\n        // TODO uint16 ?\\n        ///\\n        uint32 numSpaceships; // uint31 + first bit => active // TODO use bool active ?\\n        uint40 lastUpdated; // ~ 34865 years, should be enough :)\\n        int40 travelingUpkeep; // decrease per _upkeepProductionDecreaseRatePer10000th  * production\\n        uint32 overflow;\\n        // bool active; // TODO ?\\n        // bool exiting; // TODO ?\\n    }\\n\\n    struct Fleet {\\n        address owner;\\n        uint40 launchTime; // ~ 34865 years, should be enough :)\\n        uint32 quantity; // TODO? first bit = done? to keep quantity value on-chain post resolution, actually not needed, can be given in the hash\\n        uint24 futureExtraProduction;\\n        address defender;\\n        uint40 arrivalTime;\\n        uint32 defenderLoss;\\n        bool planetActive;\\n        bool victory;\\n        // we got 24bit more to store if needed\\n        // operator ? // signer ?\\n    }\\n\\n    struct FleetData {\\n        bool arrived;\\n        address owner;\\n        uint40 launchTime;\\n        uint32 quantity;\\n        uint64 flyingAtLaunch; // can be more than quantity if multiple fleet were launched around the same time from the same planet\\n        uint64 destroyedAtLaunch;\\n        address defender;\\n        uint40 arrivalTime;\\n        uint32 defenderLoss;\\n        bool planetActive;\\n        bool victory;\\n    }\\n\\n    struct PlanetStats {\\n        int8 subX;\\n        int8 subY;\\n        uint32 stake;\\n        uint16 production;\\n        uint16 attack;\\n        uint16 defense;\\n        uint16 speed;\\n        uint16 natives;\\n    }\\n\\n    struct ExternalPlanet {\\n        address owner;\\n        uint40 ownershipStartTime; // ~ 34865 years, should be enough :)\\n        uint40 exitStartTime; // ~ 34865 years, should be enough :)\\n        uint32 numSpaceships;\\n        uint32 overflow;\\n        uint40 lastUpdated; // ~ 34865 years, should be enough :)\\n        bool active;\\n        // bool exiting;\\n        uint256 reward;\\n    }\\n\\n    struct FleetLaunch {\\n        address fleetSender;\\n        address fleetOwner;\\n        uint256 from;\\n        uint32 quantity;\\n        bytes32 toHash;\\n    }\\n    struct FleetResolution {\\n        uint256 from;\\n        uint256 to;\\n        uint256 distance;\\n        uint256 arrivalTimeWanted;\\n        bool gift;\\n        address specific;\\n        bytes32 secret;\\n        address fleetSender; // does not work ?\\n        address operator; // should be saved ?\\n    }\\n\\n    struct AccumulatedAttack {\\n        address target;\\n        uint32 numAttackSpent;\\n        uint32 damageCausedSoFar;\\n        uint16 averageAttackPower;\\n    }\\n}\\n\",\"keccak256\":\"0x3906d94bc2fb81e50d0de6cb215feca2eed8c9cc257c00d8f014af535f009777\",\"license\":\"AGPL-3.0\"},\"src/yakuza/Yakuza.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.9;\\n\\nimport \\\"../conquest_token/RewardsGenerator.sol\\\";\\nimport \\\"../conquest_token/PlayToken.sol\\\";\\nimport \\\"../outerspace/interfaces/IOuterSpace.sol\\\";\\nimport \\\"../outerspace/types/ImportingOuterSpaceTypes.sol\\\";\\nimport \\\"hardhat-deploy/solc_0.8/proxy/Proxied.sol\\\";\\nimport \\\"../base/erc20/UsingERC20Base.sol\\\";\\nimport \\\"../base/erc20/WithPermitAndFixedDomain.sol\\\";\\nimport \\\"../libraries/Extraction.sol\\\";\\n\\ninterface IClaim {\\n    function claim(address to) external;\\n}\\n\\ncontract Yakuza is UsingERC20Base, WithPermitAndFixedDomain, Proxied {\\n    using Extraction for bytes32;\\n\\n    // --------------------------------------------------------------------------------------------\\n    // TYPES\\n    // --------------------------------------------------------------------------------------------\\n    struct Config {\\n        uint256 numSecondsPerTokens;\\n        uint256 spaceshipsToKeepPer10000;\\n        uint256 acquireNumSpaceships;\\n        uint256 productionCapAsDuration;\\n        uint256 frontrunningDelay;\\n        uint256 minAverageStakePerPlanet;\\n        uint256 maxClaimDelay;\\n        uint256 minimumSubscriptionWhenStaking;\\n        uint256 minimumSubscriptionWhenNotStaking;\\n        bytes32 genesis;\\n    }\\n    // --------------------------------------------------------------------------------------------\\n\\n    // --------------------------------------------------------------------------------------------\\n    // EVENTS\\n    // --------------------------------------------------------------------------------------------\\n    event YakuzaSubscribed(address indexed subscriber, uint256 startTime, uint256 endTime, uint256 contribution);\\n    event YakuzaClaimed(\\n        address indexed sender,\\n        uint256 indexed fleetId,\\n        uint256 indexed attackedPlanet,\\n        uint256 fleetSentId,\\n        uint256 amount,\\n        uint256 amountLeft\\n    );\\n\\n    event RewardReceiverSet(address newRewardReceiver);\\n    // --------------------------------------------------------------------------------------------\\n\\n    // --------------------------------------------------------------------------------------------\\n    // IMMUTABLES\\n    // --------------------------------------------------------------------------------------------\\n    IOuterSpace public immutable outerSpace;\\n    PlayToken public immutable playToken;\\n\\n    bytes32 internal immutable _genesis;\\n    uint256 internal immutable _acquireNumSpaceships;\\n    uint256 internal immutable _productionCapAsDuration;\\n    uint256 internal immutable _frontrunningDelay;\\n\\n    uint256 public immutable numSecondsPerTokens;\\n    uint256 public immutable spaceshipsToKeepPer10000;\\n    uint256 public immutable minAverageStakePerPlanet;\\n    uint256 public immutable maxClaimDelay;\\n    uint256 public immutable minimumSubscriptionWhenStaking;\\n    uint256 public immutable minimumSubscriptionWhenNotStaking;\\n    // --------------------------------------------------------------------------------------------\\n\\n    // --------------------------------------------------------------------------------------------\\n    // STATE VARIABLES\\n    // --------------------------------------------------------------------------------------------\\n    address public rewardReceiver;\\n    RewardsGenerator public generator;\\n\\n    struct Subscription {\\n        uint256 startTime;\\n        uint256 endTime;\\n    }\\n    mapping(address => Subscription) public subscriptions;\\n\\n    struct Claim {\\n        bool claimed;\\n        uint248 amountLeft;\\n    }\\n    mapping(uint256 => Claim) public claims;\\n\\n    // --------------------------------------------------------------------------------------------\\n\\n    // --------------------------------------------------------------------------------------------\\n    // CONSTRUCTOR\\n    // --------------------------------------------------------------------------------------------\\n    constructor(\\n        address initialRewardReceiver,\\n        RewardsGenerator initialGenerator,\\n        IOuterSpace initialOuterSpace,\\n        PlayToken initialPlayToken,\\n        Config memory config\\n    ) WithPermitAndFixedDomain(\\\"1\\\") {\\n        outerSpace = initialOuterSpace;\\n        playToken = initialPlayToken;\\n\\n        _genesis = config.genesis;\\n        _acquireNumSpaceships = config.acquireNumSpaceships;\\n        _productionCapAsDuration = config.productionCapAsDuration;\\n        _frontrunningDelay = config.frontrunningDelay;\\n\\n        numSecondsPerTokens = config.numSecondsPerTokens;\\n        spaceshipsToKeepPer10000 = config.spaceshipsToKeepPer10000;\\n        maxClaimDelay = config.maxClaimDelay;\\n        minAverageStakePerPlanet = config.minAverageStakePerPlanet;\\n        minimumSubscriptionWhenStaking = config.minimumSubscriptionWhenStaking;\\n        minimumSubscriptionWhenNotStaking = config.minimumSubscriptionWhenNotStaking;\\n\\n        _postUpgrade(initialRewardReceiver, initialGenerator);\\n    }\\n\\n    function postUpgrade(\\n        address initialRewardReceiver,\\n        RewardsGenerator initialGenerator,\\n        IOuterSpace,\\n        PlayToken,\\n        Config calldata\\n    ) external onlyProxyAdmin {\\n        _postUpgrade(initialRewardReceiver, initialGenerator);\\n    }\\n\\n    function _postUpgrade(address initialRewardReceiver, RewardsGenerator initialGenerator) internal {\\n        rewardReceiver = initialRewardReceiver;\\n        generator = initialGenerator;\\n    }\\n\\n    // --------------------------------------------------------------------------------------------\\n\\n    // --------------------------------------------------------------------------------------------\\n    // ERC20\\n    // --------------------------------------------------------------------------------------------\\n    string public constant symbol = \\\"YKZ1\\\";\\n\\n    function name() public pure override returns (string memory) {\\n        return \\\"YAKUZA1\\\";\\n    }\\n\\n    // --------------------------------------------------------------------------------------------\\n\\n    // --------------------------------------------------------------------------------------------\\n    // Subscribe to Yakuza\\n    // --------------------------------------------------------------------------------------------\\n\\n    function subscribeWithoutStaking(uint256 amountToMint, uint256 tokenAmount) external payable {\\n        require(tokenAmount + amountToMint >= minimumSubscriptionWhenNotStaking, \\\"MINIMUM_SUBSCRIPTION_REQUIRED\\\");\\n\\n        address sender = msg.sender;\\n        if (tokenAmount > 0) {\\n            playToken.transferFrom(sender, address(this), tokenAmount);\\n        }\\n        playToken.mint{value: msg.value}(address(this), amountToMint);\\n        _recordContribution(sender, amountToMint + tokenAmount);\\n    }\\n\\n    function subscribeViaStaking(\\n        uint256[] memory locations,\\n        uint256 amountToMint,\\n        uint256 tokenAmount,\\n        uint256 amountFromYakuza\\n    ) external payable {\\n        address sender = msg.sender;\\n\\n        require(tokenAmount + amountToMint >= minimumSubscriptionWhenStaking, \\\"MINIMUM_SUBSCRIPTION_REQUIRED\\\");\\n\\n        if (tokenAmount > 0) {\\n            playToken.transferFrom(sender, address(this), tokenAmount);\\n        }\\n\\n        if (tokenAmount + amountFromYakuza > 0) {\\n            playToken.approve(address(outerSpace), tokenAmount + amountFromYakuza);\\n        }\\n        outerSpace.acquireMultipleViaNativeTokenAndStakingToken{value: msg.value}(\\n            locations,\\n            amountToMint,\\n            tokenAmount + amountFromYakuza\\n        );\\n        uint256 contribution = amountToMint + tokenAmount;\\n        uint256 averagePerPlanet = (amountToMint + tokenAmount + amountFromYakuza) / locations.length;\\n        require(averagePerPlanet >= minAverageStakePerPlanet, \\\"PLANETS_TOO_SMALL\\\");\\n        _recordContribution(sender, contribution);\\n    }\\n\\n    function _recordContribution(address subscriber, uint256 contribution) internal {\\n        _mint(subscriber, contribution);\\n        uint256 startTime = subscriptions[subscriber].startTime;\\n        uint256 endTime = subscriptions[subscriber].endTime;\\n        if (block.timestamp > endTime) {\\n            startTime = block.timestamp;\\n            subscriptions[subscriber].startTime = startTime;\\n            endTime = startTime + (numSecondsPerTokens * contribution) / 1e18;\\n        } else {\\n            endTime = endTime + (numSecondsPerTokens * contribution) / 1e18;\\n        }\\n\\n        subscriptions[subscriber].endTime = endTime;\\n        emit YakuzaSubscribed(subscriber, startTime, endTime, contribution);\\n    }\\n\\n    // --------------------------------------------------------------------------------------------\\n    // Claim attack by providing the details of the fleet that captured your planet\\n    // --------------------------------------------------------------------------------------------\\n\\n    function claimCounterAttack(\\n        uint256 fleetId,\\n        ImportingOuterSpaceTypes.FleetResolution calldata resolution,\\n        uint32 amount,\\n        uint256 from,\\n        bytes32 toHash,\\n        uint256 arrivalTimeWanted,\\n        bytes32 secret,\\n        address payable payee\\n    ) external payable {\\n        if (msg.value > 0) {\\n            require(payee != address(0), \\\"NO_PAYEE\\\");\\n            payee.transfer(msg.value);\\n        }\\n\\n        // we enforce sending back, which make such fleet visible to anyone\\n        bytes32 expectedToHash = keccak256(\\n            abi.encodePacked(secret, resolution.to, false, address(0), arrivalTimeWanted)\\n        );\\n\\n        require(expectedToHash == toHash, \\\"INVALID_TO_HASH\\\");\\n\\n        _claimAttack(fleetId, resolution, amount, from, toHash);\\n    }\\n\\n    function _claimAttack(\\n        uint256 fleetId,\\n        ImportingOuterSpaceTypes.FleetResolution calldata resolution,\\n        uint32 amount,\\n        uint256 from,\\n        bytes32 toHash\\n    ) internal {\\n        address sender = msg.sender;\\n        // You cannot claim the same winning fleet twice\\n        require(!claims[fleetId].claimed, \\\"ALREADY_CLAIMED\\\");\\n\\n        // you have to be subscribed\\n        require(block.timestamp < subscriptions[sender].endTime, \\\"SUBSCRIPTION_EXPIRED\\\");\\n\\n        ImportingOuterSpaceTypes.FleetData memory fleet = outerSpace.getFleetData(fleetId, resolution.from);\\n\\n        require(fleet.owner != address(this), \\\"FLEET_IS_YAKUZA\\\");\\n        require(fleet.defender == sender || fleet.defender == address(this), \\\"DID_NOT_TARGETED_YOU_NOR_YAKUZA\\\");\\n\\n        // Fleet arrived before you subscribe (minus _frontrunningDelay)\\n        require(fleet.arrivalTime - _frontrunningDelay > subscriptions[sender].startTime, \\\"FLEET_NOT_COVERED\\\");\\n\\n        // There is a delay after which you cannot claim anymore\\n        require(block.timestamp < fleet.arrivalTime + maxClaimDelay, \\\"TOO_LATE_TO_CLAIM\\\");\\n\\n        // the fleet need to exist\\n        require(fleet.quantity > 0, \\\"NO_FLEET\\\");\\n\\n        ImportingOuterSpaceTypes.ExternalPlanet memory yakuzaPlanet = outerSpace.getUpdatedPlanetState(from);\\n        Stats memory statsForYakuzaPlanet = _getStats(from);\\n        uint256 yakuzaCap = _capWhenActive(statsForYakuzaPlanet.production);\\n        uint256 minimumSpaceshipsToLeave = (yakuzaCap * spaceshipsToKeepPer10000) / 10000;\\n\\n        // There is a minimum number of spaceships Yakuza want to keep on each planet\\n        require(yakuzaPlanet.numSpaceships > minimumSpaceshipsToLeave, \\\"NOT_ENOUGH_SPACESHIPS\\\");\\n        require(amount <= yakuzaPlanet.numSpaceships - minimumSpaceshipsToLeave, \\\"NEED_TO_LEAVE_ENOUGH_DEFENSE\\\");\\n\\n        // Revenge can only be made on actual cpature of active planets\\n        require(fleet.planetActive && fleet.victory, \\\"NOT_ACTIVE_VICTORY\\\");\\n\\n        // we give you revenge enough to capture it back\\n        uint256 amountLeft = claims[fleetId].amountLeft;\\n        if (amountLeft == 0) {\\n            // TODO optimize re-calculate here with genesisHash\\n            Stats memory statsForAttackedPlanet = _getStats(resolution.to);\\n            uint256 attackedPlanetCap = _capWhenActive(statsForAttackedPlanet.production);\\n            amountLeft = ((attackedPlanetCap * statsForAttackedPlanet.defense) / statsForYakuzaPlanet.attack) + 1;\\n        }\\n        if (amount >= amountLeft) {\\n            amountLeft = 0;\\n            claims[fleetId].claimed = true;\\n        } else {\\n            amountLeft = uint248(amountLeft - amount);\\n        }\\n        claims[fleetId].amountLeft = uint248(amountLeft);\\n\\n        // Here we verify the validity of the fleet and its data\\n        require(\\n            uint256(\\n                keccak256(\\n                    abi.encodePacked(\\n                        keccak256(\\n                            abi.encodePacked(\\n                                resolution.secret,\\n                                resolution.to,\\n                                resolution.gift,\\n                                resolution.specific,\\n                                resolution.arrivalTimeWanted\\n                            )\\n                        ),\\n                        resolution.from,\\n                        resolution.fleetSender,\\n                        resolution.operator\\n                    )\\n                )\\n            ) == fleetId,\\n            \\\"INVALID_FLEET_DATA_OR_SECRET\\\"\\n        );\\n\\n        // then we do a basic send\\n        // Yakuza is going to take control of the planet\\n        // This also ensure this cannot be abused by losing planet in purpose\\n        outerSpace.send(from, amount, toHash);\\n\\n        uint256 fleetSentId = uint256(keccak256(abi.encodePacked(toHash, from, address(this), address(this))));\\n        emit YakuzaClaimed(sender, fleetId, resolution.to, fleetSentId, amount, amountLeft);\\n    }\\n\\n    // --------------------------------------------------------------------------------------------\\n\\n    // --------------------------------------------------------------------------------------------\\n    // Reward Receiver\\n    // --------------------------------------------------------------------------------------------\\n\\n    function setRewardReceiver(address newRewardReceiver) external {\\n        require(msg.sender == rewardReceiver, \\\"NOT_ALLOWED\\\");\\n        rewardReceiver = newRewardReceiver;\\n        emit RewardReceiverSet(newRewardReceiver);\\n    }\\n\\n    // --------------------------------------------------------------------------------------------\\n\\n    // --------------------------------------------------------------------------------------------\\n    // REWARDS FOR OWNER\\n    // --------------------------------------------------------------------------------------------\\n    function claimSharedPoolRewards(address to) external {\\n        require(msg.sender == rewardReceiver, \\\"NOT_ALLOWED\\\");\\n        generator.claimSharedPoolRewards(to);\\n    }\\n\\n    function claimFixedRewards(address to) external {\\n        require(msg.sender == rewardReceiver, \\\"NOT_ALLOWED\\\");\\n        generator.claimFixedRewards(to);\\n    }\\n\\n    // support upgrade of generator if any\\n    function claim(address to) external {\\n        require(msg.sender == rewardReceiver, \\\"NOT_ALLOWED\\\");\\n        IClaim(address(generator)).claim(to);\\n    }\\n\\n    function changegGenerator(RewardsGenerator newGenerator) external {\\n        require(msg.sender == rewardReceiver, \\\"NOT_ALLOWED\\\");\\n        generator = newGenerator;\\n    }\\n\\n    // --------------------------------------------------------------------------------------------\\n\\n    // --------------------------------------------------------------------------------------------\\n    // CONQUEST LOGIC\\n    // --------------------------------------------------------------------------------------------\\n\\n    function _capWhenActive(uint16 production) internal view returns (uint256) {\\n        return _acquireNumSpaceships + (uint256(production) * _productionCapAsDuration) / 1 hours;\\n    }\\n\\n    struct Stats {\\n        uint16 production;\\n        uint16 attack;\\n        uint16 defense;\\n    }\\n\\n    function _getStats(uint256 location) internal view returns (Stats memory stats) {\\n        bytes32 data = _planetData(location);\\n        stats.production = _production(data);\\n        stats.attack = _attack(data);\\n        stats.defense = _defense(data);\\n    }\\n\\n    function _planetData(uint256 location) internal view returns (bytes32) {\\n        return keccak256(abi.encodePacked(_genesis, location));\\n    }\\n\\n    function _exists(bytes32 data) internal pure returns (bool) {\\n        return data.value8Mod(52, 16) == 1;\\n    }\\n\\n    function _production(bytes32 data) internal pure returns (uint16) {\\n        return data.normal16(12, 0x0708083409600a8c0bb80ce40e100e100e100e101068151819c81e7823282ee0); // per hour\\n    }\\n\\n    function _attack(bytes32 data) internal pure returns (uint16) {\\n        return 4000 + data.normal8(20) * 400; // 4,000 - 7,000 - 10,000\\n    }\\n\\n    function _defense(bytes32 data) internal pure returns (uint16) {\\n        return 4000 + data.normal8(28) * 400; // 4,000 - 7,000 - 10,000\\n    }\\n}\\n\",\"keccak256\":\"0x1e1590c2c4707b0432e675952ba444e6a05a70bbb8e397646d64675f9bcb50ac\",\"license\":\"AGPL-3.0\"}},\"version\":1}",
  "bytecode": "0x6102206040523480156200001257600080fd5b5060405162004a5238038062004a528339810160408190526200003591620001d9565b6040805180820190915260018152603160f81b60208201527f91ab3d17e3a50a9d89e63fd30b92be7f5336b03b287bb946787a83a9d62a27666200009360408051808201909152600781526659414b555a413160c81b602082015290565b8051602091820120835184830120604080519384019490945292820152606081019190915230608082015260a00160408051601f19818403018152918152815160209283012060809081526001600160a01b0380881660a090815290871660c09081526101208088015160e090815294880151610100908152606089015190915292870151610140528651610160529386015161018052928501516101c052918401516101a0528301516101e05282015161020052506200017d8585600480546001600160a01b039384166001600160a01b03199182161790915560058054929093169116179055565b5050505050620002d3565b6001600160a01b03811681146200019e57600080fd5b50565b60405161014081016001600160401b0381118282101715620001d357634e487b7160e01b600052604160045260246000fd5b60405290565b60008060008060008587036101c0811215620001f457600080fd5b8651620002018162000188565b6020880151909650620002148162000188565b6040880151909550620002278162000188565b60608801519094506200023a8162000188565b9250610140607f1982018113156200025157600080fd5b6200025b620001a1565b91506080880151825260a0880151602083015260c0880151604083015260e08801516060830152610100808901516080840152610120808a015160a0850152828a015160c08501526101608a015160e08501526101808a0151828501526101a08a015181850152505050809150509295509295909350565b60805160a05160c05160e05161010051610120516101405161016051610180516101a0516101c0516101e0516102005161466b620003e7600039600081816106950152610ffb01526000818161097a015261122801526000818161050f0152612daa01526000818161044b015261157f0152600081816105770152612fa7015260008181610543015281816128cf015261291d01526000612d150152600061374e01526000613787015260006136cc0152600081816108ea015281816110e5015281816111980152818161131101526113b8015260008181610634015281816113df015281816114c401528181612b1001528181612eed01526134a40152600081816104bb0152611ab8015261466b6000f3fe6080604052600436106102c65760003560e01c80637776cbe211610179578063cae9ca51116100d6578063e3cb85631161008a578063f2ae4b5311610064578063f2ae4b5314610968578063fc72b9761461099c578063ff1e03e9146109af57600080fd5b8063e3cb8563146108d8578063e7fcb0651461090c578063f046395a1461091f57600080fd5b8063dae254dd116100bb578063dae254dd14610885578063dd62ed3e146108a5578063df752eed146108c557600080fd5b8063cae9ca5114610845578063d505accf1461086557600080fd5b8063a53ebf481161012d578063a9059cbb11610112578063a9059cbb146107e5578063b732407e14610805578063c1d34b891461082557600080fd5b8063a53ebf4814610743578063a888c2cd1461075657600080fd5b80637e9ae1b31161015e5780637e9ae1b3146106835780637ecebe00146106b757806395d89b41146106fa57600080fd5b80637776cbe2146106225780637afa1eed1461065657600080fd5b8063313ce567116102275780635ffbe9ef116101db57806364aa8347116101c057806364aa8347146105b95780636b515ece146105cc57806370a08231146105df57600080fd5b80635ffbe9ef1461056557806363d994c71461059957600080fd5b80634000aea01161020c5780634000aea0146104dd57806351b6eae6146104fd5780635b5ae5ec1461053157600080fd5b8063313ce5671461048d5780633644e515146104a957600080fd5b80631da511241161027e5780631e83409a116102635780631e83409a14610419578063200653701461043957806323b872dd1461046d57600080fd5b80631da51124146103a75780631dac30b0146103c757600080fd5b8063095ea7b3116102af578063095ea7b3146103455780630e02df541461037557806318160ddd1461038857600080fd5b8063066112f9146102cb57806306fdde03146102ed575b600080fd5b3480156102d757600080fd5b506102eb6102e636600461395b565b6109cf565b005b3480156102f957600080fd5b5060408051808201909152600781527f59414b555a41310000000000000000000000000000000000000000000000000060208201525b60405161033c919061397f565b60405180910390f35b34801561035157600080fd5b506103656103603660046139f2565b610ade565b604051901515815260200161033c565b610365610383366004613a6a565b610af5565b34801561039457600080fd5b506000545b60405190815260200161033c565b3480156103b357600080fd5b506102eb6103c236600461395b565b610cbe565b3480156103d357600080fd5b506004546103f49073ffffffffffffffffffffffffffffffffffffffff1681565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200161033c565b34801561042557600080fd5b506102eb61043436600461395b565b610d86565b34801561044557600080fd5b506103997f000000000000000000000000000000000000000000000000000000000000000081565b34801561047957600080fd5b50610365610488366004613ab6565b610e5f565b34801561049957600080fd5b506040516012815260200161033c565b3480156104b557600080fd5b506103997f000000000000000000000000000000000000000000000000000000000000000081565b3480156104e957600080fd5b506103656104f8366004613b39565b610e76565b34801561050957600080fd5b506103997f000000000000000000000000000000000000000000000000000000000000000081565b34801561053d57600080fd5b506103997f000000000000000000000000000000000000000000000000000000000000000081565b34801561057157600080fd5b506103997f000000000000000000000000000000000000000000000000000000000000000081565b3480156105a557600080fd5b506103656105b4366004613b95565b610f36565b6102eb6105c7366004613c08565b610ff9565b6102eb6105da366004613cd2565b611225565b3480156105eb57600080fd5b506103996105fa36600461395b565b73ffffffffffffffffffffffffffffffffffffffff1660009081526001602052604090205490565b34801561062e57600080fd5b506103f47f000000000000000000000000000000000000000000000000000000000000000081565b34801561066257600080fd5b506005546103f49073ffffffffffffffffffffffffffffffffffffffff1681565b34801561068f57600080fd5b506103997f000000000000000000000000000000000000000000000000000000000000000081565b3480156106c357600080fd5b506103996106d236600461395b565b73ffffffffffffffffffffffffffffffffffffffff1660009081526003602052604090205490565b34801561070657600080fd5b5061032f6040518060400160405280600481526020017f594b5a310000000000000000000000000000000000000000000000000000000081525081565b6102eb610751366004613da0565b61161a565b34801561076257600080fd5b506107ae610771366004613e4b565b60076020526000908152604090205460ff81169061010090047effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1682565b6040805192151583527effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff90911660208301520161033c565b3480156107f157600080fd5b506103656108003660046139f2565b6117a3565b34801561081157600080fd5b506102eb610820366004613e64565b6117b0565b34801561083157600080fd5b50610365610840366004613b95565b6118be565b34801561085157600080fd5b50610365610860366004613b39565b611923565b34801561087157600080fd5b506102eb610880366004613efd565b611986565b34801561089157600080fd5b506102eb6108a036600461395b565b611cbb565b3480156108b157600080fd5b506103996108c0366004613f74565b611db5565b6103656108d3366004613fad565b611e35565b3480156108e457600080fd5b506103f47f000000000000000000000000000000000000000000000000000000000000000081565b61036561091a3660046139f2565b611ff2565b34801561092b57600080fd5b5061095361093a36600461395b565b6006602052600090815260409020805460019091015482565b6040805192835260208301919091520161033c565b34801561097457600080fd5b506103997f000000000000000000000000000000000000000000000000000000000000000081565b6103656109aa36600461400d565b612041565b3480156109bb57600080fd5b506102eb6109ca36600461395b565b6122d4565b60045473ffffffffffffffffffffffffffffffffffffffff163314610a55576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600b60248201527f4e4f545f414c4c4f57454400000000000000000000000000000000000000000060448201526064015b60405180910390fd5b6005546040517f066112f900000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff83811660048301529091169063066112f9906024015b600060405180830381600087803b158015610ac357600080fd5b505af1158015610ad7573d6000803e3d6000fd5b5050505050565b6000610aeb3384846123ad565b5060015b92915050565b600080610b028434614105565b9050610b0e8482614119565b3414610b76576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f494e56414c49445f4d53475f56414c55450000000000000000000000000000006044820152606401610a4c565b6000610b828585614105565b9050610b8e8582614119565b8414610bf6576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f494e56414c49445f544f54414c5f414d4f554e540000000000000000000000006044820152606401610a4c565b60005b85811015610cb157610c3233888884818110610c1757610c17614156565b9050602002016020810190610c2c919061395b565b846124bb565b868682818110610c4457610c44614156565b9050602002016020810190610c59919061395b565b73ffffffffffffffffffffffffffffffffffffffff166108fc849081150290604051600060405180830381858888f19350505050158015610c9e573d6000803e3d6000fd5b5080610ca981614185565b915050610bf9565b5060019695505050505050565b60045473ffffffffffffffffffffffffffffffffffffffff163314610d3f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600b60248201527f4e4f545f414c4c4f5745440000000000000000000000000000000000000000006044820152606401610a4c565b600580547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff92909216919091179055565b60045473ffffffffffffffffffffffffffffffffffffffff163314610e07576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600b60248201527f4e4f545f414c4c4f5745440000000000000000000000000000000000000000006044820152606401610a4c565b6005546040517f1e83409a00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff838116600483015290911690631e83409a90602401610aa9565b6000610e6c848484612709565b5060019392505050565b6000610e833386866124bb565b6040517fa4c0ed3600000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff86169063a4c0ed3690610edb903390889088908890600401614207565b602060405180830381600087803b158015610ef557600080fd5b505af1158015610f09573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f2d919061425b565b95945050505050565b6000610f433386866124bb565b6040517f9b6be06500000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff861690639b6be06590610f9d9033908a90899089908990600401614278565b602060405180830381600087803b158015610fb757600080fd5b505af1158015610fcb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fef919061425b565b9695505050505050565b7f000000000000000000000000000000000000000000000000000000000000000061102483836142c3565b101561108c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f4d494e494d554d5f535542534352495054494f4e5f52455155495245440000006044820152606401610a4c565b338115611163576040517f23b872dd00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8281166004830152306024830152604482018490527f000000000000000000000000000000000000000000000000000000000000000016906323b872dd90606401602060405180830381600087803b15801561112957600080fd5b505af115801561113d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611161919061425b565b505b6040517f40c10f19000000000000000000000000000000000000000000000000000000008152306004820152602481018490527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16906340c10f199034906044016000604051808303818588803b1580156111f257600080fd5b505af1158015611206573d6000803e3d6000fd5b505050505061122081838561121b91906142c3565b612855565b505050565b337f000000000000000000000000000000000000000000000000000000000000000061125185856142c3565b10156112b9576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f4d494e494d554d5f535542534352495054494f4e5f52455155495245440000006044820152606401610a4c565b821561138f576040517f23b872dd00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8281166004830152306024830152604482018590527f000000000000000000000000000000000000000000000000000000000000000016906323b872dd90606401602060405180830381600087803b15801561135557600080fd5b505af1158015611369573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061138d919061425b565b505b600061139b83856142c3565b11156114ad5773ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001663095ea7b37f000000000000000000000000000000000000000000000000000000000000000061140885876142c3565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e085901b16815273ffffffffffffffffffffffffffffffffffffffff90921660048301526024820152604401602060405180830381600087803b15801561147357600080fd5b505af1158015611487573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906114ab919061425b565b505b73ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001663861399e73487876114f687896142c3565b6040518563ffffffff1660e01b8152600401611514939291906142db565b6000604051808303818588803b15801561152d57600080fd5b505af1158015611541573d6000803e3d6000fd5b50505050506000838561155491906142c3565b90506000865184868861156791906142c3565b61157191906142c3565b61157b9190614105565b90507f0000000000000000000000000000000000000000000000000000000000000000811015611607576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f504c414e4554535f544f4f5f534d414c4c0000000000000000000000000000006044820152606401610a4c565b6116118383612855565b50505050505050565b34156116e15773ffffffffffffffffffffffffffffffffffffffff811661169d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600860248201527f4e4f5f50415945450000000000000000000000000000000000000000000000006044820152606401610a4c565b60405173ffffffffffffffffffffffffffffffffffffffff8216903480156108fc02916000818181858888f193505050501580156116df573d6000803e3d6000fd5b505b604080516020808201859052898101358284015260006060830181905260618301526075808301879052835180840390910181526095909201909252805191012084811461178b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600f60248201527f494e56414c49445f544f5f4841534800000000000000000000000000000000006044820152606401610a4c565b61179889898989896129cb565b505050505050505050565b6000610aeb3384846124bb565b7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d61035473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614611866576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f4e4f545f415554484f52495a45440000000000000000000000000000000000006044820152606401610a4c565b610ad785856004805473ffffffffffffffffffffffffffffffffffffffff9384167fffffffffffffffffffffffff00000000000000000000000000000000000000009182161790915560058054929093169116179055565b60006118cb868686612709565b6040517fa4c0ed3600000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff86169063a4c0ed3690610f9d908990889088908890600401614207565b60006119303386866123ad565b6040517eba451f00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff86169062ba451f90610edb903390889088908890600401614207565b73ffffffffffffffffffffffffffffffffffffffff8716611a03576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f494e56414c49445f5a45524f5f414444524553530000000000000000000000006044820152606401610a4c565b73ffffffffffffffffffffffffffffffffffffffff87811660008181526003602090815260408083205481517f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c98185015280830195909552948b166060850152608084018a905260a0840185905260c08085018a90528151808603909101815260e0850190915280519101207f19010000000000000000000000000000000000000000000000000000000000006101008401527f00000000000000000000000000000000000000000000000000000000000000006101028401526101228301529061014201604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081840301815282825280516020918201206000845290830180835281905260ff8816918301919091526060820186905260808201859052915060019060a0016020604051602081039080840390855afa158015611b6e573d6000803e3d6000fd5b5050506020604051035173ffffffffffffffffffffffffffffffffffffffff168973ffffffffffffffffffffffffffffffffffffffff1614611c0c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f494e56414c49445f5349474e41545552450000000000000000000000000000006044820152606401610a4c565b851580611c195750854211155b611c7f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600860248201527f544f4f5f4c4154450000000000000000000000000000000000000000000000006044820152606401610a4c565b611c8a8260016142c3565b73ffffffffffffffffffffffffffffffffffffffff8a166000908152600360205260409020556117988989896123ad565b60045473ffffffffffffffffffffffffffffffffffffffff163314611d3c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600b60248201527f4e4f545f414c4c4f5745440000000000000000000000000000000000000000006044820152606401610a4c565b600480547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff83169081179091556040519081527f083dc55b3248fa3ebfe8473cfe49ec0028fb069195dc28d6513564cbc9f162df9060200160405180910390a150565b600073ffffffffffffffffffffffffffffffffffffffff8316301415611dfc57507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff610aef565b5073ffffffffffffffffffffffffffffffffffffffff918216600090815260026020908152604080832093909416825291909152205490565b600080611e428534614105565b9050611e4e8582614119565b3414611eb6576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f494e56414c49445f4d53475f56414c55450000000000000000000000000000006044820152606401610a4c565b848314611f1f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600f60248201527f4e4f545f53414d455f4c454e47544800000000000000000000000000000000006044820152606401610a4c565b60005b85811015610cb157611f7333888884818110611f4057611f40614156565b9050602002016020810190611f55919061395b565b878785818110611f6757611f67614156565b905060200201356124bb565b868682818110611f8557611f85614156565b9050602002016020810190611f9a919061395b565b73ffffffffffffffffffffffffffffffffffffffff166108fc839081150290604051600060405180830381858888f19350505050158015611fdf573d6000803e3d6000fd5b5080611fea81614185565b915050611f22565b6000611fff3384846124bb565b60405173ffffffffffffffffffffffffffffffffffffffff8416903480156108fc02916000818181858888f19350505050158015610e6c573d6000803e3d6000fd5b6000808685146120ad576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f544f4b454e5f4e4f545f53414d455f4c454e47544800000000000000000000006044820152606401610a4c565b868314612116576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f4554485f4e4f545f53414d455f4c454e475448000000000000000000000000006044820152606401610a4c565b60005b8781101561225c5786868281811061213357612133614156565b9050602002013560001461217e5761217e338a8a8481811061215757612157614156565b905060200201602081019061216c919061395b565b898985818110611f6757611f67614156565b84848281811061219057612190614156565b9050602002013560001461224a578888828181106121b0576121b0614156565b90506020020160208101906121c5919061395b565b73ffffffffffffffffffffffffffffffffffffffff166108fc8686848181106121f0576121f0614156565b905060200201359081150290604051600060405180830381858888f19350505050158015612222573d6000803e3d6000fd5b5084848281811061223557612235614156565b905060200201358261224791906142c3565b91505b8061225481614185565b915050612119565b508034146122c6576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f494e56414c49445f4d53475f56414c55450000000000000000000000000000006044820152606401610a4c565b506001979650505050505050565b60045473ffffffffffffffffffffffffffffffffffffffff163314612355576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600b60248201527f4e4f545f414c4c4f5745440000000000000000000000000000000000000000006044820152606401610a4c565b6005546040517fff1e03e900000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff83811660048301529091169063ff1e03e990602401610aa9565b73ffffffffffffffffffffffffffffffffffffffff8316158015906123e7575073ffffffffffffffffffffffffffffffffffffffff821615155b61244d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f494e56414c49445f5a45524f5f414444524553530000000000000000000000006044820152606401610a4c565b73ffffffffffffffffffffffffffffffffffffffff83811660008181526002602090815260408083209487168084529482529182902085905590518481527f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925910160405180910390a3505050565b73ffffffffffffffffffffffffffffffffffffffff8216612538576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f494e56414c49445f5a45524f5f414444524553530000000000000000000000006044820152606401610a4c565b73ffffffffffffffffffffffffffffffffffffffff82163014156125b8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f494e56414c49445f544849535f414444524553530000000000000000000000006044820152606401610a4c565b73ffffffffffffffffffffffffffffffffffffffff831660009081526001602052604090205481811015612648576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f4e4f545f454e4f5547485f544f4b454e530000000000000000000000000000006044820152606401610a4c565b6126528282614328565b73ffffffffffffffffffffffffffffffffffffffff80861660009081526001602052604080822093909355908516815290812080548492906126959084906142c3565b925050819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040516126fb91815260200190565b60405180910390a350505050565b3373ffffffffffffffffffffffffffffffffffffffff841614801590612745575073ffffffffffffffffffffffffffffffffffffffff83163014155b1561284a5773ffffffffffffffffffffffffffffffffffffffff831660009081526002602090815260408083203384529091529020547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8114612848578181101561280c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f4e4f545f415554484f495a45445f414c4c4f57414e43450000000000000000006044820152606401610a4c565b6128168282614328565b73ffffffffffffffffffffffffffffffffffffffff851660009081526002602090815260408083203384529091529020555b505b6112208383836124bb565b61285f8282613607565b73ffffffffffffffffffffffffffffffffffffffff8216600090815260066020526040902080546001909101544281101561290e5773ffffffffffffffffffffffffffffffffffffffff8416600090815260066020526040902042908190559150670de0b6b3a76400006128f3847f0000000000000000000000000000000000000000000000000000000000000000614119565b6128fd9190614105565b61290790836142c3565b9050612958565b670de0b6b3a7640000612941847f0000000000000000000000000000000000000000000000000000000000000000614119565b61294b9190614105565b61295590826142c3565b90505b73ffffffffffffffffffffffffffffffffffffffff841660008181526006602090815260409182902060010184905581518581529081018490529081018590527f84e29dfb21faa8f81567f23e0deadf87489d59618e472a5ee03e027cbc516e909060600160405180910390a250505050565b600085815260076020526040902054339060ff1615612a46576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600f60248201527f414c52454144595f434c41494d454400000000000000000000000000000000006044820152606401610a4c565b73ffffffffffffffffffffffffffffffffffffffff81166000908152600660205260409020600101544210612ad7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f535542534352495054494f4e5f455850495245440000000000000000000000006044820152606401610a4c565b6040517f7a7f1e4200000000000000000000000000000000000000000000000000000000815260048101879052853560248201526000907f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1690637a7f1e42906044016101606040518083038186803b158015612b6857600080fd5b505afa158015612b7c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612ba09190614382565b602081015190915073ffffffffffffffffffffffffffffffffffffffff16301415612c27576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600f60248201527f464c4545545f49535f59414b555a4100000000000000000000000000000000006044820152606401610a4c565b8173ffffffffffffffffffffffffffffffffffffffff168160c0015173ffffffffffffffffffffffffffffffffffffffff161480612c7e575060c081015173ffffffffffffffffffffffffffffffffffffffff1630145b612ce4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f4449445f4e4f545f54415247455445445f594f555f4e4f525f59414b555a41006044820152606401610a4c565b73ffffffffffffffffffffffffffffffffffffffff821660009081526006602052604090205460e0820151612d41907f00000000000000000000000000000000000000000000000000000000000000009064ffffffffff16614328565b11612da8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f464c4545545f4e4f545f434f56455245440000000000000000000000000000006044820152606401610a4c565b7f00000000000000000000000000000000000000000000000000000000000000008160e0015164ffffffffff16612ddf91906142c3565b4210612e47576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f544f4f5f4c4154455f544f5f434c41494d0000000000000000000000000000006044820152606401610a4c565b6000816060015163ffffffff1611612ebb576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600860248201527f4e4f5f464c4545540000000000000000000000000000000000000000000000006044820152606401610a4c565b6040517f1e7c86ea000000000000000000000000000000000000000000000000000000008152600481018590526000907f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1690631e7c86ea906024016101006040518083038186803b158015612f4557600080fd5b505afa158015612f59573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612f7d919061445c565b90506000612f8a866136a9565b90506000612f9b8260000151613744565b90506000612710612fcc7f000000000000000000000000000000000000000000000000000000000000000084614119565b612fd69190614105565b905080846060015163ffffffff161161304b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f4e4f545f454e4f5547485f5350414345534849505300000000000000000000006044820152606401610a4c565b80846060015163ffffffff166130619190614328565b8963ffffffff1611156130d0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f4e4545445f544f5f4c454156455f454e4f5547485f444546454e5345000000006044820152606401610a4c565b84610120015180156130e457508461014001515b61314a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f4e4f545f4143544956455f564943544f525900000000000000000000000000006044820152606401610a4c565b60008b81526007602052604090205461010090047effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff16806131dd5760006131938c602001356136a9565b905060006131a48260000151613744565b9050856020015161ffff16826040015161ffff16826131c39190614119565b6131cd9190614105565b6131d89060016142c3565b925050505b808a63ffffffff1610613227575060008b815260076020526040812080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016600117905561325b565b61323763ffffffff8b1682614328565b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1690505b80600760008e815260200190815260200160002060000160016101000a8154817effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff02191690837effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1602179055508b8b60c001358c602001358d60800160208101906132e49190614522565b8e60a00160208101906132f7919061395b565b8f60600135604051602001613356959493929190948552602085019390935290151560f81b604084015260601b7fffffffffffffffffffffffffffffffffffffffff000000000000000000000000166041830152605582015260750190565b604051602081830303815290604052805190602001208c600001358d60e0016020810190613384919061395b565b8e610100016020810190613398919061395b565b6040805160208101959095528401929092527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606091821b81168285015291901b1660748201526088016040516020818303038152906040528051906020012060001c14613462576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f494e56414c49445f464c4545545f444154415f4f525f534543524554000000006044820152606401610a4c565b6040517f112e6851000000000000000000000000000000000000000000000000000000008152600481018a905263ffffffff8b166024820152604481018990527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff169063112e685190606401600060405180830381600087803b1580156134fd57600080fd5b505af1158015613511573d6000803e3d6000fd5b505060408051602081018c90529081018c905230606090811b7fffffffffffffffffffffffffffffffffffffffff000000000000000000000000169082018190526074820152600092506088019050604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0818403018152828252805160209182012080845263ffffffff8f16848301529183018590529092508d0135908e9073ffffffffffffffffffffffffffffffffffffffff8b16907fd595445e01dfe4702f0b9704620ff922721c1f357ef471206103254c667a30f59060600160405180910390a450505050505050505050505050565b8060008082825461361891906142c3565b909155505073ffffffffffffffffffffffffffffffffffffffff8216600090815260016020526040812080548392906136529084906142c3565b909155505060405181815273ffffffffffffffffffffffffffffffffffffffff8316906000907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9060200160405180910390a35050565b6040805160608082018352600080835260208084018290528385019190915283517f00000000000000000000000000000000000000000000000000000000000000008183015280850186905284518082038601815292019093528051920191909120613714816137ab565b61ffff168252613723816137d9565b61ffff16602083015261373581613801565b61ffff16604083015250919050565b6000610e106137777f000000000000000000000000000000000000000000000000000000000000000061ffff8516614119565b6137819190614105565b610aef907f00000000000000000000000000000000000000000000000000000000000000006142c3565b6000610aef82600c7f0708083409600a8c0bb80ce40e100e100e100e101068151819c81e7823282ee061380e565b60006137e682601461387f565b6137f59060ff1661019061453f565b610aef90610fa0614569565b60006137e682601c61387f565b60008061381b858561387f565b90508261382982600261458f565b6138349060016145b8565b60ff166020811061384757613847614156565b1a8361385483600261458f565b60ff166020811061386757613867614156565b61387591901a61010061453f565b610f2d9190614569565b60008061388e84846040613919565b9050600061389d6002836145dd565b905060006138ac6002846145ff565b905060007f01223334444555555666666677777777888888889999999aaaaaabbbbcccddef60ff8416602081106138e5576138e5614156565b1a905060ff82166139035760048160ff16901c945050505050610aef565b61390e6010826145ff565b945050505050610aef565b600061392e60ff80841690851686901c614621565b949350505050565b73ffffffffffffffffffffffffffffffffffffffff8116811461395857600080fd5b50565b60006020828403121561396d57600080fd5b813561397881613936565b9392505050565b600060208083528351808285015260005b818110156139ac57858101830151858201604001528201613990565b818111156139be576000604083870101525b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016929092016040019392505050565b60008060408385031215613a0557600080fd5b8235613a1081613936565b946020939093013593505050565b60008083601f840112613a3057600080fd5b50813567ffffffffffffffff811115613a4857600080fd5b6020830191508360208260051b8501011115613a6357600080fd5b9250929050565b600080600060408486031215613a7f57600080fd5b833567ffffffffffffffff811115613a9657600080fd5b613aa286828701613a1e565b909790965060209590950135949350505050565b600080600060608486031215613acb57600080fd5b8335613ad681613936565b92506020840135613ae681613936565b929592945050506040919091013590565b60008083601f840112613b0957600080fd5b50813567ffffffffffffffff811115613b2157600080fd5b602083019150836020828501011115613a6357600080fd5b60008060008060608587031215613b4f57600080fd5b8435613b5a81613936565b935060208501359250604085013567ffffffffffffffff811115613b7d57600080fd5b613b8987828801613af7565b95989497509550505050565b600080600080600060808688031215613bad57600080fd5b8535613bb881613936565b94506020860135613bc881613936565b935060408601359250606086013567ffffffffffffffff811115613beb57600080fd5b613bf788828901613af7565b969995985093965092949392505050565b60008060408385031215613c1b57600080fd5b50508035926020909101359150565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051610160810167ffffffffffffffff81118282101715613c7d57613c7d613c2a565b60405290565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff81118282101715613cca57613cca613c2a565b604052919050565b60008060008060808587031215613ce857600080fd5b843567ffffffffffffffff80821115613d0057600080fd5b818701915087601f830112613d1457600080fd5b8135602082821115613d2857613d28613c2a565b8160051b9250613d39818401613c83565b828152928401810192818101908b851115613d5357600080fd5b948201945b84861015613d7157853582529482019490820190613d58565b9b918a01359a505060408901359860600135975095505050505050565b63ffffffff8116811461395857600080fd5b600080600080600080600080888a03610200811215613dbe57600080fd5b893598506101207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe082011215613df357600080fd5b50602089019650610140890135613e0981613d8e565b9550610160890135945061018089013593506101a089013592506101c089013591506101e0890135613e3a81613936565b809150509295985092959890939650565b600060208284031215613e5d57600080fd5b5035919050565b60008060008060008587036101c0811215613e7e57600080fd5b8635613e8981613936565b95506020870135613e9981613936565b94506040870135613ea981613936565b93506060870135613eb981613936565b92506101407fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8082011215613eec57600080fd5b506080860190509295509295909350565b600080600080600080600060e0888a031215613f1857600080fd5b8735613f2381613936565b96506020880135613f3381613936565b95506040880135945060608801359350608088013560ff81168114613f5757600080fd5b9699959850939692959460a0840135945060c09093013592915050565b60008060408385031215613f8757600080fd5b8235613f9281613936565b91506020830135613fa281613936565b809150509250929050565b60008060008060408587031215613fc357600080fd5b843567ffffffffffffffff80821115613fdb57600080fd5b613fe788838901613a1e565b9096509450602087013591508082111561400057600080fd5b50613b8987828801613a1e565b6000806000806000806060878903121561402657600080fd5b863567ffffffffffffffff8082111561403e57600080fd5b61404a8a838b01613a1e565b9098509650602089013591508082111561406357600080fd5b61406f8a838b01613a1e565b9096509450604089013591508082111561408857600080fd5b5061409589828a01613a1e565b979a9699509497509295939492505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600082614114576141146140a7565b500490565b6000817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0483118215151615614151576141516140d6565b500290565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8214156141b7576141b76140d6565b5060010190565b8183528181602085013750600060208284010152600060207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116840101905092915050565b73ffffffffffffffffffffffffffffffffffffffff85168152836020820152606060408201526000610fef6060830184866141be565b801515811461395857600080fd5b80516142568161423d565b919050565b60006020828403121561426d57600080fd5b81516139788161423d565b600073ffffffffffffffffffffffffffffffffffffffff8088168352808716602084015250846040830152608060608301526142b86080830184866141be565b979650505050505050565b600082198211156142d6576142d66140d6565b500190565b606080825284519082018190526000906020906080840190828801845b82811015614314578151845292840192908401906001016142f8565b505050908301949094525060400152919050565b60008282101561433a5761433a6140d6565b500390565b805161425681613936565b805164ffffffffff8116811461425657600080fd5b805161425681613d8e565b805167ffffffffffffffff8116811461425657600080fd5b6000610160828403121561439557600080fd5b61439d613c59565b6143a68361424b565b81526143b46020840161433f565b60208201526143c56040840161434a565b60408201526143d66060840161435f565b60608201526143e76080840161436a565b60808201526143f860a0840161436a565b60a082015261440960c0840161433f565b60c082015261441a60e0840161434a565b60e082015261010061442d81850161435f565b9082015261012061443f84820161424b565b9082015261014061445184820161424b565b908201529392505050565b600061010080838503121561447057600080fd5b6040519081019067ffffffffffffffff8211818310171561449357614493613c2a565b81604052835191506144a482613936565b8181526144b36020850161434a565b60208201526144c46040850161434a565b60408201526144d56060850161435f565b60608201526144e66080850161435f565b60808201526144f760a0850161434a565b60a082015261450860c0850161424b565b60c082015260e084015160e0820152809250505092915050565b60006020828403121561453457600080fd5b81356139788161423d565b600061ffff80831681851681830481118215151615614560576145606140d6565b02949350505050565b600061ffff808316818516808303821115614586576145866140d6565b01949350505050565b600060ff821660ff84168160ff04811182151516156145b0576145b06140d6565b029392505050565b600060ff821660ff84168060ff038211156145d5576145d56140d6565b019392505050565b600060ff8316806145f0576145f06140a7565b8060ff84160491505092915050565b600060ff831680614612576146126140a7565b8060ff84160691505092915050565b600082614630576146306140a7565b50069056fea26469706673582212203212c4f518f09f62e5a9fea9a8b0d6d14eff1b4da64e5990627d0f04a987487a64736f6c63430008090033",
  "deployedBytecode": "0x6080604052600436106102c65760003560e01c80637776cbe211610179578063cae9ca51116100d6578063e3cb85631161008a578063f2ae4b5311610064578063f2ae4b5314610968578063fc72b9761461099c578063ff1e03e9146109af57600080fd5b8063e3cb8563146108d8578063e7fcb0651461090c578063f046395a1461091f57600080fd5b8063dae254dd116100bb578063dae254dd14610885578063dd62ed3e146108a5578063df752eed146108c557600080fd5b8063cae9ca5114610845578063d505accf1461086557600080fd5b8063a53ebf481161012d578063a9059cbb11610112578063a9059cbb146107e5578063b732407e14610805578063c1d34b891461082557600080fd5b8063a53ebf4814610743578063a888c2cd1461075657600080fd5b80637e9ae1b31161015e5780637e9ae1b3146106835780637ecebe00146106b757806395d89b41146106fa57600080fd5b80637776cbe2146106225780637afa1eed1461065657600080fd5b8063313ce567116102275780635ffbe9ef116101db57806364aa8347116101c057806364aa8347146105b95780636b515ece146105cc57806370a08231146105df57600080fd5b80635ffbe9ef1461056557806363d994c71461059957600080fd5b80634000aea01161020c5780634000aea0146104dd57806351b6eae6146104fd5780635b5ae5ec1461053157600080fd5b8063313ce5671461048d5780633644e515146104a957600080fd5b80631da511241161027e5780631e83409a116102635780631e83409a14610419578063200653701461043957806323b872dd1461046d57600080fd5b80631da51124146103a75780631dac30b0146103c757600080fd5b8063095ea7b3116102af578063095ea7b3146103455780630e02df541461037557806318160ddd1461038857600080fd5b8063066112f9146102cb57806306fdde03146102ed575b600080fd5b3480156102d757600080fd5b506102eb6102e636600461395b565b6109cf565b005b3480156102f957600080fd5b5060408051808201909152600781527f59414b555a41310000000000000000000000000000000000000000000000000060208201525b60405161033c919061397f565b60405180910390f35b34801561035157600080fd5b506103656103603660046139f2565b610ade565b604051901515815260200161033c565b610365610383366004613a6a565b610af5565b34801561039457600080fd5b506000545b60405190815260200161033c565b3480156103b357600080fd5b506102eb6103c236600461395b565b610cbe565b3480156103d357600080fd5b506004546103f49073ffffffffffffffffffffffffffffffffffffffff1681565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200161033c565b34801561042557600080fd5b506102eb61043436600461395b565b610d86565b34801561044557600080fd5b506103997f000000000000000000000000000000000000000000000000000000000000000081565b34801561047957600080fd5b50610365610488366004613ab6565b610e5f565b34801561049957600080fd5b506040516012815260200161033c565b3480156104b557600080fd5b506103997f000000000000000000000000000000000000000000000000000000000000000081565b3480156104e957600080fd5b506103656104f8366004613b39565b610e76565b34801561050957600080fd5b506103997f000000000000000000000000000000000000000000000000000000000000000081565b34801561053d57600080fd5b506103997f000000000000000000000000000000000000000000000000000000000000000081565b34801561057157600080fd5b506103997f000000000000000000000000000000000000000000000000000000000000000081565b3480156105a557600080fd5b506103656105b4366004613b95565b610f36565b6102eb6105c7366004613c08565b610ff9565b6102eb6105da366004613cd2565b611225565b3480156105eb57600080fd5b506103996105fa36600461395b565b73ffffffffffffffffffffffffffffffffffffffff1660009081526001602052604090205490565b34801561062e57600080fd5b506103f47f000000000000000000000000000000000000000000000000000000000000000081565b34801561066257600080fd5b506005546103f49073ffffffffffffffffffffffffffffffffffffffff1681565b34801561068f57600080fd5b506103997f000000000000000000000000000000000000000000000000000000000000000081565b3480156106c357600080fd5b506103996106d236600461395b565b73ffffffffffffffffffffffffffffffffffffffff1660009081526003602052604090205490565b34801561070657600080fd5b5061032f6040518060400160405280600481526020017f594b5a310000000000000000000000000000000000000000000000000000000081525081565b6102eb610751366004613da0565b61161a565b34801561076257600080fd5b506107ae610771366004613e4b565b60076020526000908152604090205460ff81169061010090047effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1682565b6040805192151583527effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff90911660208301520161033c565b3480156107f157600080fd5b506103656108003660046139f2565b6117a3565b34801561081157600080fd5b506102eb610820366004613e64565b6117b0565b34801561083157600080fd5b50610365610840366004613b95565b6118be565b34801561085157600080fd5b50610365610860366004613b39565b611923565b34801561087157600080fd5b506102eb610880366004613efd565b611986565b34801561089157600080fd5b506102eb6108a036600461395b565b611cbb565b3480156108b157600080fd5b506103996108c0366004613f74565b611db5565b6103656108d3366004613fad565b611e35565b3480156108e457600080fd5b506103f47f000000000000000000000000000000000000000000000000000000000000000081565b61036561091a3660046139f2565b611ff2565b34801561092b57600080fd5b5061095361093a36600461395b565b6006602052600090815260409020805460019091015482565b6040805192835260208301919091520161033c565b34801561097457600080fd5b506103997f000000000000000000000000000000000000000000000000000000000000000081565b6103656109aa36600461400d565b612041565b3480156109bb57600080fd5b506102eb6109ca36600461395b565b6122d4565b60045473ffffffffffffffffffffffffffffffffffffffff163314610a55576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600b60248201527f4e4f545f414c4c4f57454400000000000000000000000000000000000000000060448201526064015b60405180910390fd5b6005546040517f066112f900000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff83811660048301529091169063066112f9906024015b600060405180830381600087803b158015610ac357600080fd5b505af1158015610ad7573d6000803e3d6000fd5b5050505050565b6000610aeb3384846123ad565b5060015b92915050565b600080610b028434614105565b9050610b0e8482614119565b3414610b76576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f494e56414c49445f4d53475f56414c55450000000000000000000000000000006044820152606401610a4c565b6000610b828585614105565b9050610b8e8582614119565b8414610bf6576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f494e56414c49445f544f54414c5f414d4f554e540000000000000000000000006044820152606401610a4c565b60005b85811015610cb157610c3233888884818110610c1757610c17614156565b9050602002016020810190610c2c919061395b565b846124bb565b868682818110610c4457610c44614156565b9050602002016020810190610c59919061395b565b73ffffffffffffffffffffffffffffffffffffffff166108fc849081150290604051600060405180830381858888f19350505050158015610c9e573d6000803e3d6000fd5b5080610ca981614185565b915050610bf9565b5060019695505050505050565b60045473ffffffffffffffffffffffffffffffffffffffff163314610d3f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600b60248201527f4e4f545f414c4c4f5745440000000000000000000000000000000000000000006044820152606401610a4c565b600580547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff92909216919091179055565b60045473ffffffffffffffffffffffffffffffffffffffff163314610e07576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600b60248201527f4e4f545f414c4c4f5745440000000000000000000000000000000000000000006044820152606401610a4c565b6005546040517f1e83409a00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff838116600483015290911690631e83409a90602401610aa9565b6000610e6c848484612709565b5060019392505050565b6000610e833386866124bb565b6040517fa4c0ed3600000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff86169063a4c0ed3690610edb903390889088908890600401614207565b602060405180830381600087803b158015610ef557600080fd5b505af1158015610f09573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f2d919061425b565b95945050505050565b6000610f433386866124bb565b6040517f9b6be06500000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff861690639b6be06590610f9d9033908a90899089908990600401614278565b602060405180830381600087803b158015610fb757600080fd5b505af1158015610fcb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fef919061425b565b9695505050505050565b7f000000000000000000000000000000000000000000000000000000000000000061102483836142c3565b101561108c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f4d494e494d554d5f535542534352495054494f4e5f52455155495245440000006044820152606401610a4c565b338115611163576040517f23b872dd00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8281166004830152306024830152604482018490527f000000000000000000000000000000000000000000000000000000000000000016906323b872dd90606401602060405180830381600087803b15801561112957600080fd5b505af115801561113d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611161919061425b565b505b6040517f40c10f19000000000000000000000000000000000000000000000000000000008152306004820152602481018490527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16906340c10f199034906044016000604051808303818588803b1580156111f257600080fd5b505af1158015611206573d6000803e3d6000fd5b505050505061122081838561121b91906142c3565b612855565b505050565b337f000000000000000000000000000000000000000000000000000000000000000061125185856142c3565b10156112b9576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f4d494e494d554d5f535542534352495054494f4e5f52455155495245440000006044820152606401610a4c565b821561138f576040517f23b872dd00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8281166004830152306024830152604482018590527f000000000000000000000000000000000000000000000000000000000000000016906323b872dd90606401602060405180830381600087803b15801561135557600080fd5b505af1158015611369573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061138d919061425b565b505b600061139b83856142c3565b11156114ad5773ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001663095ea7b37f000000000000000000000000000000000000000000000000000000000000000061140885876142c3565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e085901b16815273ffffffffffffffffffffffffffffffffffffffff90921660048301526024820152604401602060405180830381600087803b15801561147357600080fd5b505af1158015611487573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906114ab919061425b565b505b73ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001663861399e73487876114f687896142c3565b6040518563ffffffff1660e01b8152600401611514939291906142db565b6000604051808303818588803b15801561152d57600080fd5b505af1158015611541573d6000803e3d6000fd5b50505050506000838561155491906142c3565b90506000865184868861156791906142c3565b61157191906142c3565b61157b9190614105565b90507f0000000000000000000000000000000000000000000000000000000000000000811015611607576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f504c414e4554535f544f4f5f534d414c4c0000000000000000000000000000006044820152606401610a4c565b6116118383612855565b50505050505050565b34156116e15773ffffffffffffffffffffffffffffffffffffffff811661169d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600860248201527f4e4f5f50415945450000000000000000000000000000000000000000000000006044820152606401610a4c565b60405173ffffffffffffffffffffffffffffffffffffffff8216903480156108fc02916000818181858888f193505050501580156116df573d6000803e3d6000fd5b505b604080516020808201859052898101358284015260006060830181905260618301526075808301879052835180840390910181526095909201909252805191012084811461178b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600f60248201527f494e56414c49445f544f5f4841534800000000000000000000000000000000006044820152606401610a4c565b61179889898989896129cb565b505050505050505050565b6000610aeb3384846124bb565b7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d61035473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614611866576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f4e4f545f415554484f52495a45440000000000000000000000000000000000006044820152606401610a4c565b610ad785856004805473ffffffffffffffffffffffffffffffffffffffff9384167fffffffffffffffffffffffff00000000000000000000000000000000000000009182161790915560058054929093169116179055565b60006118cb868686612709565b6040517fa4c0ed3600000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff86169063a4c0ed3690610f9d908990889088908890600401614207565b60006119303386866123ad565b6040517eba451f00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff86169062ba451f90610edb903390889088908890600401614207565b73ffffffffffffffffffffffffffffffffffffffff8716611a03576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f494e56414c49445f5a45524f5f414444524553530000000000000000000000006044820152606401610a4c565b73ffffffffffffffffffffffffffffffffffffffff87811660008181526003602090815260408083205481517f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c98185015280830195909552948b166060850152608084018a905260a0840185905260c08085018a90528151808603909101815260e0850190915280519101207f19010000000000000000000000000000000000000000000000000000000000006101008401527f00000000000000000000000000000000000000000000000000000000000000006101028401526101228301529061014201604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081840301815282825280516020918201206000845290830180835281905260ff8816918301919091526060820186905260808201859052915060019060a0016020604051602081039080840390855afa158015611b6e573d6000803e3d6000fd5b5050506020604051035173ffffffffffffffffffffffffffffffffffffffff168973ffffffffffffffffffffffffffffffffffffffff1614611c0c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f494e56414c49445f5349474e41545552450000000000000000000000000000006044820152606401610a4c565b851580611c195750854211155b611c7f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600860248201527f544f4f5f4c4154450000000000000000000000000000000000000000000000006044820152606401610a4c565b611c8a8260016142c3565b73ffffffffffffffffffffffffffffffffffffffff8a166000908152600360205260409020556117988989896123ad565b60045473ffffffffffffffffffffffffffffffffffffffff163314611d3c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600b60248201527f4e4f545f414c4c4f5745440000000000000000000000000000000000000000006044820152606401610a4c565b600480547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff83169081179091556040519081527f083dc55b3248fa3ebfe8473cfe49ec0028fb069195dc28d6513564cbc9f162df9060200160405180910390a150565b600073ffffffffffffffffffffffffffffffffffffffff8316301415611dfc57507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff610aef565b5073ffffffffffffffffffffffffffffffffffffffff918216600090815260026020908152604080832093909416825291909152205490565b600080611e428534614105565b9050611e4e8582614119565b3414611eb6576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f494e56414c49445f4d53475f56414c55450000000000000000000000000000006044820152606401610a4c565b848314611f1f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600f60248201527f4e4f545f53414d455f4c454e47544800000000000000000000000000000000006044820152606401610a4c565b60005b85811015610cb157611f7333888884818110611f4057611f40614156565b9050602002016020810190611f55919061395b565b878785818110611f6757611f67614156565b905060200201356124bb565b868682818110611f8557611f85614156565b9050602002016020810190611f9a919061395b565b73ffffffffffffffffffffffffffffffffffffffff166108fc839081150290604051600060405180830381858888f19350505050158015611fdf573d6000803e3d6000fd5b5080611fea81614185565b915050611f22565b6000611fff3384846124bb565b60405173ffffffffffffffffffffffffffffffffffffffff8416903480156108fc02916000818181858888f19350505050158015610e6c573d6000803e3d6000fd5b6000808685146120ad576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f544f4b454e5f4e4f545f53414d455f4c454e47544800000000000000000000006044820152606401610a4c565b868314612116576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f4554485f4e4f545f53414d455f4c454e475448000000000000000000000000006044820152606401610a4c565b60005b8781101561225c5786868281811061213357612133614156565b9050602002013560001461217e5761217e338a8a8481811061215757612157614156565b905060200201602081019061216c919061395b565b898985818110611f6757611f67614156565b84848281811061219057612190614156565b9050602002013560001461224a578888828181106121b0576121b0614156565b90506020020160208101906121c5919061395b565b73ffffffffffffffffffffffffffffffffffffffff166108fc8686848181106121f0576121f0614156565b905060200201359081150290604051600060405180830381858888f19350505050158015612222573d6000803e3d6000fd5b5084848281811061223557612235614156565b905060200201358261224791906142c3565b91505b8061225481614185565b915050612119565b508034146122c6576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f494e56414c49445f4d53475f56414c55450000000000000000000000000000006044820152606401610a4c565b506001979650505050505050565b60045473ffffffffffffffffffffffffffffffffffffffff163314612355576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600b60248201527f4e4f545f414c4c4f5745440000000000000000000000000000000000000000006044820152606401610a4c565b6005546040517fff1e03e900000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff83811660048301529091169063ff1e03e990602401610aa9565b73ffffffffffffffffffffffffffffffffffffffff8316158015906123e7575073ffffffffffffffffffffffffffffffffffffffff821615155b61244d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f494e56414c49445f5a45524f5f414444524553530000000000000000000000006044820152606401610a4c565b73ffffffffffffffffffffffffffffffffffffffff83811660008181526002602090815260408083209487168084529482529182902085905590518481527f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925910160405180910390a3505050565b73ffffffffffffffffffffffffffffffffffffffff8216612538576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f494e56414c49445f5a45524f5f414444524553530000000000000000000000006044820152606401610a4c565b73ffffffffffffffffffffffffffffffffffffffff82163014156125b8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f494e56414c49445f544849535f414444524553530000000000000000000000006044820152606401610a4c565b73ffffffffffffffffffffffffffffffffffffffff831660009081526001602052604090205481811015612648576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f4e4f545f454e4f5547485f544f4b454e530000000000000000000000000000006044820152606401610a4c565b6126528282614328565b73ffffffffffffffffffffffffffffffffffffffff80861660009081526001602052604080822093909355908516815290812080548492906126959084906142c3565b925050819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040516126fb91815260200190565b60405180910390a350505050565b3373ffffffffffffffffffffffffffffffffffffffff841614801590612745575073ffffffffffffffffffffffffffffffffffffffff83163014155b1561284a5773ffffffffffffffffffffffffffffffffffffffff831660009081526002602090815260408083203384529091529020547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8114612848578181101561280c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f4e4f545f415554484f495a45445f414c4c4f57414e43450000000000000000006044820152606401610a4c565b6128168282614328565b73ffffffffffffffffffffffffffffffffffffffff851660009081526002602090815260408083203384529091529020555b505b6112208383836124bb565b61285f8282613607565b73ffffffffffffffffffffffffffffffffffffffff8216600090815260066020526040902080546001909101544281101561290e5773ffffffffffffffffffffffffffffffffffffffff8416600090815260066020526040902042908190559150670de0b6b3a76400006128f3847f0000000000000000000000000000000000000000000000000000000000000000614119565b6128fd9190614105565b61290790836142c3565b9050612958565b670de0b6b3a7640000612941847f0000000000000000000000000000000000000000000000000000000000000000614119565b61294b9190614105565b61295590826142c3565b90505b73ffffffffffffffffffffffffffffffffffffffff841660008181526006602090815260409182902060010184905581518581529081018490529081018590527f84e29dfb21faa8f81567f23e0deadf87489d59618e472a5ee03e027cbc516e909060600160405180910390a250505050565b600085815260076020526040902054339060ff1615612a46576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600f60248201527f414c52454144595f434c41494d454400000000000000000000000000000000006044820152606401610a4c565b73ffffffffffffffffffffffffffffffffffffffff81166000908152600660205260409020600101544210612ad7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f535542534352495054494f4e5f455850495245440000000000000000000000006044820152606401610a4c565b6040517f7a7f1e4200000000000000000000000000000000000000000000000000000000815260048101879052853560248201526000907f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1690637a7f1e42906044016101606040518083038186803b158015612b6857600080fd5b505afa158015612b7c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612ba09190614382565b602081015190915073ffffffffffffffffffffffffffffffffffffffff16301415612c27576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600f60248201527f464c4545545f49535f59414b555a4100000000000000000000000000000000006044820152606401610a4c565b8173ffffffffffffffffffffffffffffffffffffffff168160c0015173ffffffffffffffffffffffffffffffffffffffff161480612c7e575060c081015173ffffffffffffffffffffffffffffffffffffffff1630145b612ce4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f4449445f4e4f545f54415247455445445f594f555f4e4f525f59414b555a41006044820152606401610a4c565b73ffffffffffffffffffffffffffffffffffffffff821660009081526006602052604090205460e0820151612d41907f00000000000000000000000000000000000000000000000000000000000000009064ffffffffff16614328565b11612da8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f464c4545545f4e4f545f434f56455245440000000000000000000000000000006044820152606401610a4c565b7f00000000000000000000000000000000000000000000000000000000000000008160e0015164ffffffffff16612ddf91906142c3565b4210612e47576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f544f4f5f4c4154455f544f5f434c41494d0000000000000000000000000000006044820152606401610a4c565b6000816060015163ffffffff1611612ebb576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600860248201527f4e4f5f464c4545540000000000000000000000000000000000000000000000006044820152606401610a4c565b6040517f1e7c86ea000000000000000000000000000000000000000000000000000000008152600481018590526000907f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1690631e7c86ea906024016101006040518083038186803b158015612f4557600080fd5b505afa158015612f59573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612f7d919061445c565b90506000612f8a866136a9565b90506000612f9b8260000151613744565b90506000612710612fcc7f000000000000000000000000000000000000000000000000000000000000000084614119565b612fd69190614105565b905080846060015163ffffffff161161304b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f4e4f545f454e4f5547485f5350414345534849505300000000000000000000006044820152606401610a4c565b80846060015163ffffffff166130619190614328565b8963ffffffff1611156130d0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f4e4545445f544f5f4c454156455f454e4f5547485f444546454e5345000000006044820152606401610a4c565b84610120015180156130e457508461014001515b61314a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f4e4f545f4143544956455f564943544f525900000000000000000000000000006044820152606401610a4c565b60008b81526007602052604090205461010090047effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff16806131dd5760006131938c602001356136a9565b905060006131a48260000151613744565b9050856020015161ffff16826040015161ffff16826131c39190614119565b6131cd9190614105565b6131d89060016142c3565b925050505b808a63ffffffff1610613227575060008b815260076020526040812080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016600117905561325b565b61323763ffffffff8b1682614328565b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1690505b80600760008e815260200190815260200160002060000160016101000a8154817effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff02191690837effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1602179055508b8b60c001358c602001358d60800160208101906132e49190614522565b8e60a00160208101906132f7919061395b565b8f60600135604051602001613356959493929190948552602085019390935290151560f81b604084015260601b7fffffffffffffffffffffffffffffffffffffffff000000000000000000000000166041830152605582015260750190565b604051602081830303815290604052805190602001208c600001358d60e0016020810190613384919061395b565b8e610100016020810190613398919061395b565b6040805160208101959095528401929092527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606091821b81168285015291901b1660748201526088016040516020818303038152906040528051906020012060001c14613462576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f494e56414c49445f464c4545545f444154415f4f525f534543524554000000006044820152606401610a4c565b6040517f112e6851000000000000000000000000000000000000000000000000000000008152600481018a905263ffffffff8b166024820152604481018990527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff169063112e685190606401600060405180830381600087803b1580156134fd57600080fd5b505af1158015613511573d6000803e3d6000fd5b505060408051602081018c90529081018c905230606090811b7fffffffffffffffffffffffffffffffffffffffff000000000000000000000000169082018190526074820152600092506088019050604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0818403018152828252805160209182012080845263ffffffff8f16848301529183018590529092508d0135908e9073ffffffffffffffffffffffffffffffffffffffff8b16907fd595445e01dfe4702f0b9704620ff922721c1f357ef471206103254c667a30f59060600160405180910390a450505050505050505050505050565b8060008082825461361891906142c3565b909155505073ffffffffffffffffffffffffffffffffffffffff8216600090815260016020526040812080548392906136529084906142c3565b909155505060405181815273ffffffffffffffffffffffffffffffffffffffff8316906000907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9060200160405180910390a35050565b6040805160608082018352600080835260208084018290528385019190915283517f00000000000000000000000000000000000000000000000000000000000000008183015280850186905284518082038601815292019093528051920191909120613714816137ab565b61ffff168252613723816137d9565b61ffff16602083015261373581613801565b61ffff16604083015250919050565b6000610e106137777f000000000000000000000000000000000000000000000000000000000000000061ffff8516614119565b6137819190614105565b610aef907f00000000000000000000000000000000000000000000000000000000000000006142c3565b6000610aef82600c7f0708083409600a8c0bb80ce40e100e100e100e101068151819c81e7823282ee061380e565b60006137e682601461387f565b6137f59060ff1661019061453f565b610aef90610fa0614569565b60006137e682601c61387f565b60008061381b858561387f565b90508261382982600261458f565b6138349060016145b8565b60ff166020811061384757613847614156565b1a8361385483600261458f565b60ff166020811061386757613867614156565b61387591901a61010061453f565b610f2d9190614569565b60008061388e84846040613919565b9050600061389d6002836145dd565b905060006138ac6002846145ff565b905060007f01223334444555555666666677777777888888889999999aaaaaabbbbcccddef60ff8416602081106138e5576138e5614156565b1a905060ff82166139035760048160ff16901c945050505050610aef565b61390e6010826145ff565b945050505050610aef565b600061392e60ff80841690851686901c614621565b949350505050565b73ffffffffffffffffffffffffffffffffffffffff8116811461395857600080fd5b50565b60006020828403121561396d57600080fd5b813561397881613936565b9392505050565b600060208083528351808285015260005b818110156139ac57858101830151858201604001528201613990565b818111156139be576000604083870101525b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016929092016040019392505050565b60008060408385031215613a0557600080fd5b8235613a1081613936565b946020939093013593505050565b60008083601f840112613a3057600080fd5b50813567ffffffffffffffff811115613a4857600080fd5b6020830191508360208260051b8501011115613a6357600080fd5b9250929050565b600080600060408486031215613a7f57600080fd5b833567ffffffffffffffff811115613a9657600080fd5b613aa286828701613a1e565b909790965060209590950135949350505050565b600080600060608486031215613acb57600080fd5b8335613ad681613936565b92506020840135613ae681613936565b929592945050506040919091013590565b60008083601f840112613b0957600080fd5b50813567ffffffffffffffff811115613b2157600080fd5b602083019150836020828501011115613a6357600080fd5b60008060008060608587031215613b4f57600080fd5b8435613b5a81613936565b935060208501359250604085013567ffffffffffffffff811115613b7d57600080fd5b613b8987828801613af7565b95989497509550505050565b600080600080600060808688031215613bad57600080fd5b8535613bb881613936565b94506020860135613bc881613936565b935060408601359250606086013567ffffffffffffffff811115613beb57600080fd5b613bf788828901613af7565b969995985093965092949392505050565b60008060408385031215613c1b57600080fd5b50508035926020909101359150565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051610160810167ffffffffffffffff81118282101715613c7d57613c7d613c2a565b60405290565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff81118282101715613cca57613cca613c2a565b604052919050565b60008060008060808587031215613ce857600080fd5b843567ffffffffffffffff80821115613d0057600080fd5b818701915087601f830112613d1457600080fd5b8135602082821115613d2857613d28613c2a565b8160051b9250613d39818401613c83565b828152928401810192818101908b851115613d5357600080fd5b948201945b84861015613d7157853582529482019490820190613d58565b9b918a01359a505060408901359860600135975095505050505050565b63ffffffff8116811461395857600080fd5b600080600080600080600080888a03610200811215613dbe57600080fd5b893598506101207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe082011215613df357600080fd5b50602089019650610140890135613e0981613d8e565b9550610160890135945061018089013593506101a089013592506101c089013591506101e0890135613e3a81613936565b809150509295985092959890939650565b600060208284031215613e5d57600080fd5b5035919050565b60008060008060008587036101c0811215613e7e57600080fd5b8635613e8981613936565b95506020870135613e9981613936565b94506040870135613ea981613936565b93506060870135613eb981613936565b92506101407fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8082011215613eec57600080fd5b506080860190509295509295909350565b600080600080600080600060e0888a031215613f1857600080fd5b8735613f2381613936565b96506020880135613f3381613936565b95506040880135945060608801359350608088013560ff81168114613f5757600080fd5b9699959850939692959460a0840135945060c09093013592915050565b60008060408385031215613f8757600080fd5b8235613f9281613936565b91506020830135613fa281613936565b809150509250929050565b60008060008060408587031215613fc357600080fd5b843567ffffffffffffffff80821115613fdb57600080fd5b613fe788838901613a1e565b9096509450602087013591508082111561400057600080fd5b50613b8987828801613a1e565b6000806000806000806060878903121561402657600080fd5b863567ffffffffffffffff8082111561403e57600080fd5b61404a8a838b01613a1e565b9098509650602089013591508082111561406357600080fd5b61406f8a838b01613a1e565b9096509450604089013591508082111561408857600080fd5b5061409589828a01613a1e565b979a9699509497509295939492505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600082614114576141146140a7565b500490565b6000817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0483118215151615614151576141516140d6565b500290565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8214156141b7576141b76140d6565b5060010190565b8183528181602085013750600060208284010152600060207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116840101905092915050565b73ffffffffffffffffffffffffffffffffffffffff85168152836020820152606060408201526000610fef6060830184866141be565b801515811461395857600080fd5b80516142568161423d565b919050565b60006020828403121561426d57600080fd5b81516139788161423d565b600073ffffffffffffffffffffffffffffffffffffffff8088168352808716602084015250846040830152608060608301526142b86080830184866141be565b979650505050505050565b600082198211156142d6576142d66140d6565b500190565b606080825284519082018190526000906020906080840190828801845b82811015614314578151845292840192908401906001016142f8565b505050908301949094525060400152919050565b60008282101561433a5761433a6140d6565b500390565b805161425681613936565b805164ffffffffff8116811461425657600080fd5b805161425681613d8e565b805167ffffffffffffffff8116811461425657600080fd5b6000610160828403121561439557600080fd5b61439d613c59565b6143a68361424b565b81526143b46020840161433f565b60208201526143c56040840161434a565b60408201526143d66060840161435f565b60608201526143e76080840161436a565b60808201526143f860a0840161436a565b60a082015261440960c0840161433f565b60c082015261441a60e0840161434a565b60e082015261010061442d81850161435f565b9082015261012061443f84820161424b565b9082015261014061445184820161424b565b908201529392505050565b600061010080838503121561447057600080fd5b6040519081019067ffffffffffffffff8211818310171561449357614493613c2a565b81604052835191506144a482613936565b8181526144b36020850161434a565b60208201526144c46040850161434a565b60408201526144d56060850161435f565b60608201526144e66080850161435f565b60808201526144f760a0850161434a565b60a082015261450860c0850161424b565b60c082015260e084015160e0820152809250505092915050565b60006020828403121561453457600080fd5b81356139788161423d565b600061ffff80831681851681830481118215151615614560576145606140d6565b02949350505050565b600061ffff808316818516808303821115614586576145866140d6565b01949350505050565b600060ff821660ff84168160ff04811182151516156145b0576145b06140d6565b029392505050565b600060ff821660ff84168060ff038211156145d5576145d56140d6565b019392505050565b600060ff8316806145f0576145f06140a7565b8060ff84160491505092915050565b600060ff831680614612576146126140a7565b8060ff84160691505092915050565b600082614630576146306140a7565b50069056fea26469706673582212203212c4f518f09f62e5a9fea9a8b0d6d14eff1b4da64e5990627d0f04a987487a64736f6c63430008090033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "allowance(address,address)": {
        "details": "Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."
      },
      "approve(address,uint256)": {
        "details": "Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."
      },
      "totalSupply()": {
        "details": "Returns the amount of tokens in existence."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 11042,
        "contract": "src/yakuza/Yakuza.sol:Yakuza",
        "label": "_totalSupply",
        "offset": 0,
        "slot": "0",
        "type": "t_uint256"
      },
      {
        "astId": 11046,
        "contract": "src/yakuza/Yakuza.sol:Yakuza",
        "label": "_balances",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 11052,
        "contract": "src/yakuza/Yakuza.sol:Yakuza",
        "label": "_allowances",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_address,t_mapping(t_address,t_uint256))"
      },
      {
        "astId": 11876,
        "contract": "src/yakuza/Yakuza.sol:Yakuza",
        "label": "_nonces",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 21144,
        "contract": "src/yakuza/Yakuza.sol:Yakuza",
        "label": "rewardReceiver",
        "offset": 0,
        "slot": "4",
        "type": "t_address"
      },
      {
        "astId": 21147,
        "contract": "src/yakuza/Yakuza.sol:Yakuza",
        "label": "generator",
        "offset": 0,
        "slot": "5",
        "type": "t_contract(RewardsGenerator)13602"
      },
      {
        "astId": 21157,
        "contract": "src/yakuza/Yakuza.sol:Yakuza",
        "label": "subscriptions",
        "offset": 0,
        "slot": "6",
        "type": "t_mapping(t_address,t_struct(Subscription)21152_storage)"
      },
      {
        "astId": 21167,
        "contract": "src/yakuza/Yakuza.sol:Yakuza",
        "label": "claims",
        "offset": 0,
        "slot": "7",
        "type": "t_mapping(t_uint256,t_struct(Claim)21162_storage)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_contract(RewardsGenerator)13602": {
        "encoding": "inplace",
        "label": "contract RewardsGenerator",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_mapping(t_address,t_uint256))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_uint256)"
      },
      "t_mapping(t_address,t_struct(Subscription)21152_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct Yakuza.Subscription)",
        "numberOfBytes": "32",
        "value": "t_struct(Subscription)21152_storage"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_struct(Claim)21162_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct Yakuza.Claim)",
        "numberOfBytes": "32",
        "value": "t_struct(Claim)21162_storage"
      },
      "t_struct(Claim)21162_storage": {
        "encoding": "inplace",
        "label": "struct Yakuza.Claim",
        "members": [
          {
            "astId": 21159,
            "contract": "src/yakuza/Yakuza.sol:Yakuza",
            "label": "claimed",
            "offset": 0,
            "slot": "0",
            "type": "t_bool"
          },
          {
            "astId": 21161,
            "contract": "src/yakuza/Yakuza.sol:Yakuza",
            "label": "amountLeft",
            "offset": 1,
            "slot": "0",
            "type": "t_uint248"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(Subscription)21152_storage": {
        "encoding": "inplace",
        "label": "struct Yakuza.Subscription",
        "members": [
          {
            "astId": 21149,
            "contract": "src/yakuza/Yakuza.sol:Yakuza",
            "label": "startTime",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 21151,
            "contract": "src/yakuza/Yakuza.sol:Yakuza",
            "label": "endTime",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint248": {
        "encoding": "inplace",
        "label": "uint248",
        "numberOfBytes": "31"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}