{
  "address": "0x5216d4e3EA09F305b8F7786288Efa2B810bDb8b9",
  "abi": [
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "contract StakingToken",
              "name": "stakingToken",
              "type": "address"
            },
            {
              "internalType": "contract IFreePlayToken",
              "name": "freeStakingToken",
              "type": "address"
            },
            {
              "internalType": "contract AllianceRegistry",
              "name": "allianceRegistry",
              "type": "address"
            },
            {
              "internalType": "bytes32",
              "name": "genesis",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "resolveWindow",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "timePerDistance",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "exitDuration",
              "type": "uint256"
            },
            {
              "internalType": "uint32",
              "name": "acquireNumSpaceships",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "productionSpeedUp",
              "type": "uint32"
            },
            {
              "internalType": "uint256",
              "name": "frontrunningDelay",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "productionCapAsDuration",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "upkeepProductionDecreaseRatePer10000th",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "fleetSizeFactor6",
              "type": "uint256"
            },
            {
              "internalType": "uint32",
              "name": "initialSpaceExpansion",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "expansionDelta",
              "type": "uint32"
            },
            {
              "internalType": "uint256",
              "name": "giftTaxPer10000",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "stakeRange",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "stakeMultiplier10000th",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "bootstrapSessionEndTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "infinityStartTime",
              "type": "uint256"
            }
          ],
          "internalType": "struct OuterSpaceFacetBase.Config",
          "name": "config",
          "type": "tuple"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "ApprovalForAll",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "block",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "timestamp",
          "type": "uint256"
        }
      ],
      "name": "BlockTime",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "location",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "stake",
          "type": "uint256"
        }
      ],
      "name": "ExitComplete",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "fleet",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "fleetOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "destinationOwner",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "destination",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "gift",
          "type": "bool"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "won",
          "type": "bool"
        },
        {
          "components": [
            {
              "internalType": "uint32",
              "name": "newNumspaceships",
              "type": "uint32"
            },
            {
              "internalType": "int40",
              "name": "newTravelingUpkeep",
              "type": "int40"
            },
            {
              "internalType": "uint32",
              "name": "newOverflow",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "numSpaceshipsAtArrival",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "taxLoss",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "fleetLoss",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "planetLoss",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "inFlightFleetLoss",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "inFlightPlanetLoss",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "accumulatedDefenseAdded",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "accumulatedAttackAdded",
              "type": "uint32"
            }
          ],
          "indexed": false,
          "internalType": "struct ImportingOuterSpaceEvents.ArrivalData",
          "name": "data",
          "type": "tuple"
        }
      ],
      "name": "FleetArrived",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "fleetId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "from",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "to",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "arrivalTimeWanted",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "gift",
          "type": "bool"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "specific",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "secret",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "fleetSender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        }
      ],
      "name": "FleetRevealed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "fleetSender",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "fleetOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "from",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "fleet",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "quantity",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "newNumSpaceships",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "int40",
          "name": "newTravelingUpkeep",
          "type": "int40"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "newOverflow",
          "type": "uint32"
        }
      ],
      "name": "FleetSent",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "newGeneratorAdmin",
          "type": "address"
        }
      ],
      "name": "GeneratorAdminChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "newGenerator",
          "type": "address"
        }
      ],
      "name": "GeneratorChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "genesis",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "resolveWindow",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "timePerDistance",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "exitDuration",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "acquireNumSpaceships",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "productionSpeedUp",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "frontrunningDelay",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "productionCapAsDuration",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "upkeepProductionDecreaseRatePer10000th",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "fleetSizeFactor6",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "initialSpaceExpansion",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "expansionDelta",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "giftTaxPer10000",
          "type": "uint256"
        }
      ],
      "name": "Initialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "location",
          "type": "uint256"
        }
      ],
      "name": "PlanetExit",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "location",
          "type": "uint256"
        }
      ],
      "name": "PlanetReset",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "acquirer",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "location",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "numSpaceships",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "int40",
          "name": "travelingUpkeep",
          "type": "int40"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "overflow",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "stake",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "freegift",
          "type": "bool"
        }
      ],
      "name": "PlanetStake",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "location",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "newNumspaceships",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "int40",
          "name": "newTravelingUpkeep",
          "type": "int40"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "newOverflow",
          "type": "uint32"
        }
      ],
      "name": "PlanetTransfer",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "location",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "giver",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "rewardId",
          "type": "uint256"
        }
      ],
      "name": "RewardSetup",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "location",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "rewardId",
          "type": "uint256"
        }
      ],
      "name": "RewardToWithdraw",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newStake",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "freegift",
          "type": "bool"
        }
      ],
      "name": "StakeToWithdraw",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "location",
          "type": "uint256"
        }
      ],
      "name": "Transfer",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "origin",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "fleet",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "newNumspaceships",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "int40",
          "name": "newTravelingUpkeep",
          "type": "int40"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "newOverflow",
          "type": "uint32"
        }
      ],
      "name": "TravelingUpkeepRefund",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[]",
          "name": "locations",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "acquireMultipleViaFreeTokenTransferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[]",
          "name": "locations",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256",
          "name": "amountToMint",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "tokenAmount",
          "type": "uint256"
        }
      ],
      "name": "acquireMultipleViaNativeTokenAndStakingToken",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[]",
          "name": "locations",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "acquireMultipleViaTransferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "location",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "acquireViaFreeTokenTransferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "location",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amountToMint",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "tokenAmount",
          "type": "uint256"
        }
      ],
      "name": "acquireViaNativeTokenAndStakingToken",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "location",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "acquireViaTransferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "balanceToWithdraw",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "location",
          "type": "uint256"
        }
      ],
      "name": "exitFor",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "uint256[]",
          "name": "locations",
          "type": "uint256[]"
        }
      ],
      "name": "exitMultipleFor",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "uint256[]",
          "name": "locations",
          "type": "uint256[]"
        }
      ],
      "name": "fetchAndWithdrawFor",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "forAddress",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "onTokenPaidFor",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "onTokenTransfer",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "withdrawFor",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "contractName": "OuterSpaceStakingFacet",
  "sourceName": "src/outerspace/facets/OuterSpaceStakingFacet.sol",
  "bytecode": "0x6103006040523480156200001257600080fd5b5060405162004c2238038062004c228339810160408190526200003591620001ff565b80600060048260a001516200004b919062000333565b60a08301519091506200006082600462000365565b63ffffffff1614620000b85760405162461bcd60e51b815260206004820152601d60248201527f54494d455f5045525f444953545f4e4f545f444956495349424c455f34000000604482015260640160405180910390fd5b81516001600160a01b0390811660809081526020840151821660a052604084015190911660c0908152606084015160e09081529184015161010090815263ffffffff93841661012090815291850151610140908152928501518416610160908152908501518416610180908152918501516101a0908152928501516101c0908152908501516101e09081529185015161020090815292850151841661022090815290850151909316610240908152908401516102609081529184015161028052918301516102a052908201516102c05201516102e05250620003a0565b60405161028081016001600160401b0381118282101715620001c757634e487b7160e01b600052604160045260246000fd5b60405290565b80516001600160a01b0381168114620001e557600080fd5b919050565b805163ffffffff81168114620001e557600080fd5b600061028082840312156200021357600080fd5b6200021d62000195565b6200022883620001cd565b81526200023860208401620001cd565b60208201526200024b60408401620001cd565b6040820152606083015160608201526080830151608082015260a083015160a082015260c083015160c08201526200028660e08401620001ea565b60e08201526101006200029b818501620001ea565b9082015261012083810151908201526101408084015190820152610160808401519082015261018080840151908201526101a0620002db818501620001ea565b908201526101c0620002ef848201620001ea565b908201526101e08381015190820152610200808401519082015261022080840151908201526102408084015190820152610260928301519281019290925250919050565b600063ffffffff808416806200035957634e487b7160e01b600052601260045260246000fd5b92169190910492915050565b600063ffffffff808316818516818304811182151516156200039757634e487b7160e01b600052601160045260246000fd5b02949350505050565b60805160a05160c05160e05161010051610120516101405161016051610180516101a0516101c0516101e05161020051610220516102405161026051610280516102a0516102c0516102e0516146a0620005826000396000818161125201526132a001526000818161120a015281816112310152818161324a01526132740152600061112f015260008181611150015261119c01526000505060008181612cae01528181612d9301528181612e800152612f6b015260005050600081816138c3015281816138f60152818161397701526139aa01526000818161223401528181612385015261283e0152600081816120e3015281816127cd015261370b015260005050600081816120970152818161218a01528181612262015281816122e00152612431015260008181612670015281816126bb01528181612754015281816127920152613749015260006132dc01526000505060005050600081816102e2015281816119f101528181611c4e0152611fa90152600050506000818161044d01528181610531015281816108d701528181610a1d015261351e01526000818161061401528181610772015281816108340152818161091d01528181610a6301528181610e2801528181610fae0152818161107a015261163301526146a06000f3fe6080604052600436106100d25760003560e01c8063a4c0ed361161007f578063b9a1e84611610059578063b9a1e84614610201578063c956083814610221578063e2e9b07914610272578063f7e111e71461029257600080fd5b8063a4c0ed36146101a1578063afc82370146101c1578063b4c27385146101e157600080fd5b8063861399e7116100b0578063861399e7146101395780639b6be0651461014c5780639eca672c1461018157600080fd5b80630f05b7f6146100d75780632f646f95146100f95780637ba423fb14610119575b600080fd5b3480156100e357600080fd5b506100f76100f2366004613e4d565b6102a5565b005b34801561010557600080fd5b506100f7610114366004613e92565b6104d1565b34801561012557600080fd5b506100f7610134366004613e92565b6105b4565b6100f7610147366004613eb4565b610643565b34801561015857600080fd5b5061016c610167366004613f70565b6108bc565b60405190151581526020015b60405180910390f35b34801561018d57600080fd5b506100f761019c366004613fe3565b6109ce565b3480156101ad57600080fd5b5061016c6101bc366004614000565b610a02565b3480156101cd57600080fd5b506100f76101dc36600461405c565b610c2b565b3480156101ed57600080fd5b506100f76101fc366004613e4d565b610cf4565b34801561020d57600080fd5b506100f761021c366004614088565b610e57565b34801561022d57600080fd5b5061026461023c366004613fe3565b73ffffffffffffffffffffffffffffffffffffffff1660009081526002602052604090205490565b604051908152602001610178565b34801561027e57600080fd5b506100f761028d366004614088565b610f51565b6100f76102a0366004614110565b610f5c565b336000805b845181101561038c576000655af3107a400061033461032f8885815181106102d4576102d461413c565b6020026020010151604080517f00000000000000000000000000000000000000000000000000000000000000006020820152908101829052600090606001604051602081830303815290604052805190602001209050919050565b6110a9565b63ffffffff16610344919061419a565b905061036c848288858151811061035d5761035d61413c565b60200260200101516001611208565b61037681846141d7565b9250508080610384906141ef565b9150506102aa565b508083146103fb576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f494e56414c49445f414d4f554e5400000000000000000000000000000000000060448201526064015b60405180910390fd5b6040517f23b872dd00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8381166004830152306024830152604482018590527f000000000000000000000000000000000000000000000000000000000000000016906323b872dd906064015b602060405180830381600087803b15801561049257600080fd5b505af11580156104a6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104ca9190614228565b5050505050565b336104df8183856001611208565b6040517f23b872dd00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8281166004830152306024830152604482018490527f000000000000000000000000000000000000000000000000000000000000000016906323b872dd906064015b602060405180830381600087803b15801561057657600080fd5b505af115801561058a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105ae9190614228565b50505050565b336105c28183856000611208565b6040517f23b872dd00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8281166004830152306024830152604482018490527f000000000000000000000000000000000000000000000000000000000000000016906323b872dd9060640161055c565b336000805b85518110156106ca576000655af3107a400061067261032f8985815181106102d4576102d461413c565b63ffffffff16610682919061419a565b90506106aa848289858151811061069b5761069b61413c565b60200260200101516000611208565b6106b481846141d7565b92505080806106c2906141ef565b915050610648565b50806106d684866141d7565b1461073d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f494e56414c49445f414d4f554e5400000000000000000000000000000000000060448201526064016103f2565b6040517f40c10f19000000000000000000000000000000000000000000000000000000008152306004820152602481018590527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16906340c10f199034906044016000604051808303818588803b1580156107cc57600080fd5b505af11580156107e0573d6000803e3d6000fd5b50506040517f23b872dd00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8681166004830152306024830152604482018890527f00000000000000000000000000000000000000000000000000000000000000001693506323b872dd92506064019050602060405180830381600087803b15801561087c57600080fd5b505af1158015610890573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108b49190614228565b505050505050565b6000803373ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000161415610905575060016109a4565b3373ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016146109a4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600d60248201527f494e56414c49445f45524332300000000000000000000000000000000000000060448201526064016103f2565b60006109b28486018661424a565b90506109c087878385611208565b506001979650505050505050565b73ffffffffffffffffffffffffffffffffffffffff81166000908152600260205260409020546109fe8282611585565b5050565b6000803373ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000161415610a4b57506001610aea565b3373ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001614610aea576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600d60248201527f494e56414c49445f45524332300000000000000000000000000000000000000060448201526064016103f2565b6040831115610bfd57600080610b0285870187614263565b915091506000805b8251811015610b8b576000655af3107a4000610b3461032f8685815181106102d4576102d461413c565b63ffffffff16610b44919061419a565b9050610b6b8582868581518110610b5d57610b5d61413c565b602002602001015189611208565b610b7581846141d7565b9250508080610b83906141ef565b915050610b0a565b50808814610bf5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f494e56414c49445f414d4f554e5400000000000000000000000000000000000060448201526064016103f2565b505050610c1f565b600080610c0c8587018761405c565b91509150610c1c82888386611208565b50505b50600195945050505050565b3373ffffffffffffffffffffffffffffffffffffffff83168114610ce55773ffffffffffffffffffffffffffffffffffffffff80841660009081526003602090815260408083209385168352929052205460ff16610ce5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f4e4f545f415554484f52495a45445f544f5f53454e440000000000000000000060448201526064016103f2565b610cef838361176b565b505050565b336000805b8451811015610d6c576000655af3107a4000610d2361032f8885815181106102d4576102d461413c565b63ffffffff16610d33919061419a565b9050610d4c848288858151811061069b5761069b61413c565b610d5681846141d7565b9250508080610d64906141ef565b915050610cf9565b50808314610dd6576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f494e56414c49445f414d4f554e5400000000000000000000000000000000000060448201526064016103f2565b6040517f23b872dd00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8381166004830152306024830152604482018590527f000000000000000000000000000000000000000000000000000000000000000016906323b872dd90606401610478565b3373ffffffffffffffffffffffffffffffffffffffff84168114610f115773ffffffffffffffffffffffffffffffffffffffff80851660009081526003602090815260408083209385168352929052205460ff16610f11576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f4e4f545f415554484f52495a45445f544f5f53454e440000000000000000000060448201526064016103f2565b8160005b818110156108b457610f3f86868684818110610f3357610f3361413c565b9050602002013561176b565b80610f49816141ef565b915050610f15565b610cef838383611a53565b33610f7381610f6b84866141d7565b866000611208565b8215611022576040517f40c10f19000000000000000000000000000000000000000000000000000000008152306004820152602481018490527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16906340c10f199034906044016000604051808303818588803b15801561100857600080fd5b505af115801561101c573d6000803e3d6000fd5b50505050505b81156105ae576040517f23b872dd00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8281166004830152306024830152604482018490527f000000000000000000000000000000000000000000000000000000000000000016906323b872dd90606401610478565b60006110b482611de5565b61111a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f504c414e45545f4e4f545f45584953545300000000000000000000000000000060448201526064016103f2565b600061112783600c611e01565b905060ff81167f00000000000000000000000000000000000000000000000000000000000000007f000000000000000000000000000000000000000000000000000000000000000061117a8360026142b3565b6111859060016142dd565b61ffff16602081106111995761119961413c565b1a7f00000000000000000000000000000000000000000000000000000000000000006111c68460026142b3565b61ffff16602081106111da576111da61413c565b6111e891901a6101006142b3565b6111f291906142dd565b61ffff16611200919061419a565b949350505050565b7f0000000000000000000000000000000000000000000000000000000000000000156112e957427f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000008183108061127f5750808310155b6112e5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600660248201527f504155534544000000000000000000000000000000000000000000000000000060448201526064016103f2565b5050505b60008281526020819052604081206040805160e081018252825473ffffffffffffffffffffffffffffffffffffffff8116825264ffffffffff74010000000000000000000000000000000000000000820481166020840152790100000000000000000000000000000000000000000000000000909104811692820192909252600183015463ffffffff8082166060840152640100000000820490931660808301526901000000000000000000810460040b60a08301526e010000000000000000000000000000900490911660c08201529091506000906113c99085611e9d565b9050655af3107a40006113e08261014001516110a9565b63ffffffff166113f0919061419a565b8514611458576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f494e56414c49445f5354414b455f414d4f554e5400000000000000000000000060448201526064016103f2565b61146181612005565b61146b86826124ed565b6114778282600061289f565b61148084612bba565b821561149c576000848152600b602052604090204290556114ac565b6000848152600b60205260408120555b604080514381524260208201527f438e507c246c311193c77528e3de231eec8ce4727cce091a1dbbecf85b427893910160405180910390a1838673ffffffffffffffffffffffffffffffffffffffff167f9b17abd3d9e9f2eb79e7b7c875e68b77a80c7379ba64ec6ac0d1c254d303269b836060015184608001518560e001518a8960405161156e95949392919063ffffffff958616815260049490940b60208501529190931660408301526060820192909252901515608082015260a00190565b60405180910390a36108b48161012001518661309a565b73ffffffffffffffffffffffffffffffffffffffff821660008181526002602090815260408083208390558051858152918201929092527f05eefb5f2a67125e8c65550a4ffa0f542f75624e866ef58fb72bfb5475403092910160405180910390a26040517fa9059cbb00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8381166004830152602482018390527f0000000000000000000000000000000000000000000000000000000000000000169063a9059cbb90604401602060405180830381600087803b15801561167757600080fd5b505af115801561168b573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116af9190614228565b611715576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600f60248201527f4641494c45445f5452414e53464552000000000000000000000000000000000060448201526064016103f2565b604080516000808252602082015273ffffffffffffffffffffffffffffffffffffffff8416917f05eefb5f2a67125e8c65550a4ffa0f542f75624e866ef58fb72bfb547540309291015b60405180910390a25050565b600081815260208190526040812060018101549091906117909063ffffffff16613197565b509050806117fa576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f4e4f545f4143544956450000000000000000000000000000000000000000000060448201526064016103f2565b815473ffffffffffffffffffffffffffffffffffffffff85811691161461187d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600960248201527f4e4f545f4f574e4552000000000000000000000000000000000000000000000060448201526064016103f2565b8154790100000000000000000000000000000000000000000000000000900464ffffffffff161561190a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600f60248201527f45584954494e475f414c5245414459000000000000000000000000000000000060448201526064016103f2565b81547fffff0000000000ffffffffffffffffffffffffffffffffffffffffffffffffff167901000000000000000000000000000000000000000000000000004264ffffffffff8116919091029190911783556040805143815260208101929092527f438e507c246c311193c77528e3de231eec8ce4727cce091a1dbbecf85b427893910160405180910390a1604051839073ffffffffffffffffffffffffffffffffffffffff8616907fb9182e4e152947f1e6691fa0ee6f68f21f607fed825945c270e69995acad805f90600090a36105ae84655af3107a4000611a3e61032f87604080517f00000000000000000000000000000000000000000000000000000000000000006020820152908101829052600090606001604051602081830303815290604052805190602001209050919050565b63ffffffff16611a4e919061419a565b6131b6565b60008060005b83811015611d61576000611a90868684818110611a7857611a7861413c565b90506020020135600090815260208190526040902090565b8054909150611ac290790100000000000000000000000000000000000000000000000000900464ffffffffff16613231565b15611d4e57805473ffffffffffffffffffffffffffffffffffffffff888116911614611b4a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600960248201527f4e4f545f4f574e4552000000000000000000000000000000000000000000000060448201526064016103f2565b858583818110611b5c57611b5c61413c565b90506020020135600073ffffffffffffffffffffffffffffffffffffffff168873ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef60405160405180910390a46000600b6000888886818110611bd657611bd661413c565b9050602002013581526020019081526020016000205490506000811115611cb1578154611ca09073ffffffffffffffffffffffffffffffffffffffff16888886818110611c2557611c2561413c565b90506020020135611c9b8a8a88818110611c4157611c4161413c565b90506020020135604080517f00000000000000000000000000000000000000000000000000000000000000006020820152908101829052600090606001604051602081830303815290604052805190602001209050919050565b61330f565b611caa90856141d7565b9350611cec565b8154611cdf9073ffffffffffffffffffffffffffffffffffffffff16888886818110611c2557611c2561413c565b611ce990866141d7565b94505b5080547fffff0000000000000000000000000000000000000000000000000000000000001681556001810180547fffffffffffffffffffffffffffff0000000000000000000000000000000000001664010000000064ffffffffff4216021790555b5080611d59816141ef565b915050611a59565b5073ffffffffffffffffffffffffffffffffffffffff8516600090815260026020526040812054611d939084906141d7565b9050611d9f8682611585565b73ffffffffffffffffffffffffffffffffffffffff86166000908152600a6020526040812054611dd09084906141d7565b9050611ddc878261346d565b50505050505050565b6000611df4826034601061364f565b60ff166001149050919050565b600080611e108484604061364f565b90506000611e1f600283614332565b90506000611e2e600284614354565b905060007f01223334444555555666666677777777888888889999999aaaaaabbbbcccddef60ff841660208110611e6757611e6761413c565b1a905060ff8216611e855760048160ff16901c945050505050611e97565b611e90601082614354565b9450505050505b92915050565b6040805161018081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e08101829052610100810182905261012081018290526101408101829052610160810191909152600080611f0e8560600151613197565b85855260808088015164ffffffffff908116602088015283151560408089019190915263ffffffff80851660608a015260a0808c015160040b948a0194909452908a01805183169389019390935291511660c0808801919091528801511660e0860152865173ffffffffffffffffffffffffffffffffffffffff9081166101008701528751166101208601529092509050611ff684604080517f00000000000000000000000000000000000000000000000000000000000000006020820152908101829052600090606001604051602081830303815290604052805190602001209050919050565b61014084015250909392505050565b60a081015164ffffffffff1615612056576120238160a00151613231565b1561205657600060c082018190526060820181905260808201819052610120820181905260e08201819052604090910152565b6000816020015164ffffffffff164261206f9190614376565b90506000612081836101400151613664565b90506000610e1061ffff83166120bd63ffffffff7f0000000000000000000000000000000000000000000000000000000000000000168661419a565b6120c7919061419a565b6120d1919061438d565b606085015190915063ffffffff1660007f00000000000000000000000000000000000000000000000000000000000000001561240757600061211285613701565b905060008760400151612126576000612128565b815b90508084111561220e5760e08801516107089063ffffffff161561217a57828960e0015163ffffffff1661070861215f919061419a565b612169919061438d565b905061070881101561217a57506107085b6000610e10826121b063ffffffff7f0000000000000000000000000000000000000000000000000000000000000000168c61419a565b6121ba919061419a565b6121c4919061438d565b9050806121cf575060015b6121d98387614376565b8111156121ed576121ea8387614376565b90505b8960400151156121fb578094505b6122058187614376565b95505050612370565b8760400151156123705760008590506000896080015160040b13156123365760006127107f000000000000000000000000000000000000000000000000000000000000000061228761ffff8b1663ffffffff7f00000000000000000000000000000000000000000000000000000000000000001661419a565b612291919061419a565b61229b919061438d565b60808b01516122b39064ffffffffff16610e1061419a565b6122bd919061438d565b90508881106122ce57819450612328565b610e1061ffff891661230663ffffffff7f0000000000000000000000000000000000000000000000000000000000000000168461419a565b612310919061419a565b61231a919061438d565b945081851115612328578194505b6123328583614376565b9150505b60006123428684614376565b905080821115612366576123568183614376565b61236090866141d7565b94508091505b61220582876141d7565b876040015115612400576000836127106123aa7f00000000000000000000000000000000000000000000000000000000000000008961419a565b6123b4919061438d565b6123be91906141d7565b905060008160040b8a6080015160040b6123d891906143a1565b90506123e383614415565b8112156123f6576123f383614415565b90505b60040b60808a0152505b505061248f565b8560400151156124225761241b83836141d7565b915061248f565b6000610e1061245763ffffffff7f0000000000000000000000000000000000000000000000000000000000000000168861419a565b6124639061070861419a565b61246d919061438d565b905082811115612480575060009161248d565b61248a8184614376565b92505b505b638000000082106124b2576124a96001638000000061444e565b63ffffffff1691505b63ffffffff8216606087015260408601511580156124d85750606086015163ffffffff16155b156108b4576000610120870152505050505050565b806040015115612559576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f5354494c4c5f414354495645000000000000000000000000000000000000000060448201526064016103f2565b6000816060015163ffffffff16600014156125875761257c82610140015161376e565b61ffff169050612621565b8273ffffffffffffffffffffffffffffffffffffffff1682610100015173ffffffffffffffffffffffffffffffffffffffff1614612621576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600860248201527f4f4343555049454400000000000000000000000000000000000000000000000060448201526064016103f2565b6000612631836101400151613664565b9050600061263e82613701565b73ffffffffffffffffffffffffffffffffffffffff8616610120860152905063ffffffff8316156127905760006126b67f000000000000000000000000000000000000000000000000000000000000000063ffffffff168563ffffffff166127106126ad896101400151613805565b61ffff1661389c565b5090507f000000000000000000000000000000000000000000000000000000000000000063ffffffff168163ffffffff161061274e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600f60248201527f4641494c45445f4341505455524544000000000000000000000000000000000060448201526064016103f2565b612778817f000000000000000000000000000000000000000000000000000000000000000061444e565b63ffffffff16606086015250600060e0850152612831565b7f0000000000000000000000000000000000000000000000000000000000000000846060018181516127c29190614473565b63ffffffff169052507f000000000000000000000000000000000000000000000000000000000000000015612831578063ffffffff16846060015163ffffffff16111561282957808460600151612819919061444e565b63ffffffff1660e0850152612831565b600060e08501525b60608401516127106128697f000000000000000000000000000000000000000000000000000000000000000063ffffffff851661419a565b612873919061438d565b61287c90614492565b61288691906144d1565b60030b6080850152505060016040909201919091525050565b60008260a0015164ffffffffff161180156128c3575060c082015164ffffffffff16155b156128d1576128d182613a3d565b81610120015173ffffffffffffffffffffffffffffffffffffffff1682610100015173ffffffffffffffffffffffffffffffffffffffff1614612a365761012082015183547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff9091169081178455156129a55782547fffffffffffffff0000000000ffffffffffffffffffffffffffffffffffffffff16740100000000000000000000000000000000000000004264ffffffffff16021783556129cc565b82547fffffffffffffff0000000000ffffffffffffffffffffffffffffffffffffffff1683555b816000015182610120015173ffffffffffffffffffffffffffffffffffffffff1683610100015173ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef60405160405180910390a45b8015612a675782547fffff0000000000ffffffffffffffffffffffffffffffffffffffffffffffffff168355612ad8565b8160a0015164ffffffffff168260c0015164ffffffffff1614612ad85760c0820151835464ffffffffff909116790100000000000000000000000000000000000000000000000000027fffff0000000000ffffffffffffffffffffffffffffffffffffffffffffffffff9091161783555b612aea82604001518360600151613bc8565b60019093018054608084015160e0909401514264ffffffffff908116640100000000027fffffffffffffffffffffffffffffffffffffffffffffff0000000000ffffffff63ffffffff9384166e01000000000000000000000000000002167fffffffffffffffffffffffffffff00000000ffffffffff0000000000ffffffff929097166901000000000000000000027fffffffffffffffffffffffffffffffffffff0000000000ffffffffff00000000909416979092169690961791909117949094169290921792909217905550565b604080516080808201835260055463ffffffff80821684526401000000008204811660208501526801000000000000000082048116948401949094526c0100000000000000000000000090049092166060820152906fffffffffffffffffffffffffffffffff8316600f0b9083901d600080831215612d1a57835163ffffffff16612c4484614415565b1315612cac576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f4e4f545f524541434841424c455f5945545f4d494e580000000000000000000060448201526064016103f2565b7f000000000000000000000000000000000000000000000000000000000000000060030b612cd984614415565b612ce39190614536565b925063ffffffff831315612cf95763ffffffff92505b835163ffffffff16831315612d15575063ffffffff8216835260015b612df9565b836020015163ffffffff16831315612d8e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f4e4f545f524541434841424c455f5945545f4d4158580000000000000000000060448201526064016103f2565b612dbb7f000000000000000000000000000000000000000000000000000000000000000060030b84614536565b925063ffffffff831315612dd15763ffffffff92505b8263ffffffff16846020015163ffffffff161015612df9575063ffffffff8216602084015260015b6000821215612ef257604084015163ffffffff16612e1683614415565b1315612e7e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f4e4f545f524541434841424c455f5945545f4d494e590000000000000000000060448201526064016103f2565b7f000000000000000000000000000000000000000000000000000000000000000060030b612eab83614415565b612eb59190614536565b915063ffffffff821315612ecb5763ffffffff91505b81846040015163ffffffff161215612eed575063ffffffff8116604084015260015b612fcb565b836060015163ffffffff16821315612f66576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f4e4f545f524541434841424c455f5945545f4d4158590000000000000000000060448201526064016103f2565b612f937f000000000000000000000000000000000000000000000000000000000000000060030b83614536565b915063ffffffff821315612fa95763ffffffff91505b81846060015163ffffffff161215612fcb575063ffffffff8116606084015260015b80156104ca5783516005805460208701516040880151606089015163ffffffff9081166c01000000000000000000000000027fffffffffffffffffffffffffffffffff00000000ffffffffffffffffffffffff9282166801000000000000000002929092167fffffffffffffffffffffffffffffffff0000000000000000ffffffffffffffff938216640100000000027fffffffffffffffffffffffffffffffffffffffffffffffff000000000000000090951691909616179290921716929092179190911790555050505050565b6109fe6130c57f27ec6af4a6510eb9b7e0cc7f39415b7f15e430e53eb0cd3997e7c7e0cf680f6e5490565b60405173ffffffffffffffffffffffffffffffffffffffff85166024820152604481018490527ff5d82b6b00000000000000000000000000000000000000000000000000000000906064015b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff000000000000000000000000000000000000000000000000000000009093169290921790915262017700613bee565b63800000008181168114906000906131af90846145aa565b9050915091565b6109fe6131e17f27ec6af4a6510eb9b7e0cc7f39415b7f15e430e53eb0cd3997e7c7e0cf680f6e5490565b60405173ffffffffffffffffffffffffffffffffffffffff85166024820152604481018490527fabe7f1ab0000000000000000000000000000000000000000000000000000000090606401613111565b600064ffffffffff821661324757506000919050565b427f00000000000000000000000000000000000000000000000000000000000000001580159061329757507f00000000000000000000000000000000000000000000000000000000000000008110155b80156132c957507f00000000000000000000000000000000000000000000000000000000000000008364ffffffffff16105b156132d75750600192915050565b6133087f000000000000000000000000000000000000000000000000000000000000000064ffffffffff85166141d7565b1092915050565b6000655af3107a4000613321836110a9565b63ffffffff16613331919061419a565b604080514381524260208201529192507f438e507c246c311193c77528e3de231eec8ce4727cce091a1dbbecf85b427893910160405180910390a1828473ffffffffffffffffffffffffffffffffffffffff167f1c363b29828a892b7cddafe9583ef52e0d5aca0ea7011bda6ccf039e1781f738836040516133b591815260200190565b60405180910390a360008381526007602052604090205480156134655773ffffffffffffffffffffffffffffffffffffffff85166000818152600860209081526040808320858452825280832080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001660011790558783526007909152808220829055518392879290917f74f110a1e0cd4892234c7ba49df9f8a354cd8d29b272f7557c9b8c3c38a653369190a45b509392505050565b73ffffffffffffffffffffffffffffffffffffffff82166000818152600a602090815260408083209290925581518481526001918101919091527f05eefb5f2a67125e8c65550a4ffa0f542f75624e866ef58fb72bfb5475403092910160405180910390a26040517fa9059cbb00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8381166004830152602482018390527f0000000000000000000000000000000000000000000000000000000000000000169063a9059cbb90604401602060405180830381600087803b15801561356257600080fd5b505af1158015613576573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061359a9190614228565b613600576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600f60248201527f4641494c45445f5452414e53464552000000000000000000000000000000000060448201526064016103f2565b60408051600081526001602082015273ffffffffffffffffffffffffffffffffffffffff8416917f05eefb5f2a67125e8c65550a4ffa0f542f75624e866ef58fb72bfb5475403092910161175f565b600061120060ff80841690851686901c6145cd565b600061366f82611de5565b6136d5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f504c414e45545f4e4f545f45584953545300000000000000000000000000000060448201526064016103f2565b611e9782600c7f0708083409600a8c0bb80ce40e100e100e100e101068151819c81e7823282ee0613ceb565b6000610e106137347f000000000000000000000000000000000000000000000000000000000000000061ffff851661419a565b61373e919061438d565b611e979063ffffffff7f0000000000000000000000000000000000000000000000000000000000000000166141d7565b600061377982611de5565b6137df576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f504c414e45545f4e4f545f45584953545300000000000000000000000000000060448201526064016103f2565b6137ea82602c611e01565b6137f99060ff16610bb86142b3565b611e9790613a986142dd565b600061381082611de5565b613876576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f504c414e45545f4e4f545f45584953545300000000000000000000000000000060448201526064016103f2565b61388182601c611e01565b6138909060ff166101906142b3565b611e9790610fa06142dd565b6000808515806138aa575084155b156138ba57506000905080613a34565b6000856138e7887f000000000000000000000000000000000000000000000000000000000000000061419a565b6138f1919061438d565b61391e7f0000000000000000000000000000000000000000000000000000000000000000620f4240614376565b61392891906141d7565b613932908861419a565b90506000620f424085613945888561419a565b61394f919061438d565b613959919061438d565b90508087111561396e57879350809250613a31565b60008861399b897f000000000000000000000000000000000000000000000000000000000000000061419a565b6139a5919061438d565b6139d27f0000000000000000000000000000000000000000000000000000000000000000620f4240614376565b6139dc91906141d7565b6139e6908961419a565b90506000620f4240886139f9898561419a565b613a03919061438d565b613a0d919061438d565b63ffffffff169050898110613a2a57613a2760018b614376565b90505b9450879350505b50505b94509492505050565b6000613a58826101000151836000015184610140015161330f565b82516000908152600b60205260409020549091508015613b245761010083015173ffffffffffffffffffffffffffffffffffffffff166000908152600a6020526040812054613aa89084906141d7565b6101008501805173ffffffffffffffffffffffffffffffffffffffff9081166000908152600a6020908152604091829020859055925181518581526001948101949094529394509216917f05eefb5f2a67125e8c65550a4ffa0f542f75624e866ef58fb72bfb547540309291015b60405180910390a250505050565b61010083015173ffffffffffffffffffffffffffffffffffffffff16600090815260026020526040812054613b5a9084906141d7565b6101008501805173ffffffffffffffffffffffffffffffffffffffff9081166000908152600260209081526040808320869055935184518681529182019290925293945016917f05eefb5f2a67125e8c65550a4ffa0f542f75624e866ef58fb72bfb54754030929101613b16565b60008183613bd7576000613bdd565b63800000005b613be79190614473565b9392505050565b73ffffffffffffffffffffffffffffffffffffffff831615610cef578273ffffffffffffffffffffffffffffffffffffffff168183604051613c3091906145e1565b60006040518083038160008787f1925050503d8060008114613c6e576040519150601f19603f3d011682016040523d82523d6000602084013e613c73565b606091505b505050603f81613c83919061438d565b5a11610cef576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f4e4f545f454e4f5547485f4741535f464f525f494e4e45525f43414c4c00000060448201526064016103f2565b600080613cf88585611e01565b905082613d0682600261461c565b613d11906001614645565b60ff1660208110613d2457613d2461413c565b1a83613d3183600261461c565b60ff1660208110613d4457613d4461413c565b613d5291901a6101006142b3565b613d5c91906142dd565b95945050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f830112613da557600080fd5b8135602067ffffffffffffffff80831115613dc257613dc2613d65565b8260051b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0603f83011681018181108482111715613e0557613e05613d65565b604052938452858101830193838101925087851115613e2357600080fd5b83870191505b84821015613e4257813583529183019190830190613e29565b979650505050505050565b60008060408385031215613e6057600080fd5b823567ffffffffffffffff811115613e7757600080fd5b613e8385828601613d94565b95602094909401359450505050565b60008060408385031215613ea557600080fd5b50508035926020909101359150565b600080600060608486031215613ec957600080fd5b833567ffffffffffffffff811115613ee057600080fd5b613eec86828701613d94565b9660208601359650604090950135949350505050565b73ffffffffffffffffffffffffffffffffffffffff81168114613f2457600080fd5b50565b60008083601f840112613f3957600080fd5b50813567ffffffffffffffff811115613f5157600080fd5b602083019150836020828501011115613f6957600080fd5b9250929050565b600080600080600060808688031215613f8857600080fd5b8535613f9381613f02565b94506020860135613fa381613f02565b935060408601359250606086013567ffffffffffffffff811115613fc657600080fd5b613fd288828901613f27565b969995985093965092949392505050565b600060208284031215613ff557600080fd5b8135613be781613f02565b6000806000806060858703121561401657600080fd5b843561402181613f02565b935060208501359250604085013567ffffffffffffffff81111561404457600080fd5b61405087828801613f27565b95989497509550505050565b6000806040838503121561406f57600080fd5b823561407a81613f02565b946020939093013593505050565b60008060006040848603121561409d57600080fd5b83356140a881613f02565b9250602084013567ffffffffffffffff808211156140c557600080fd5b818601915086601f8301126140d957600080fd5b8135818111156140e857600080fd5b8760208260051b85010111156140fd57600080fd5b6020830194508093505050509250925092565b60008060006060848603121561412557600080fd5b505081359360208301359350604090920135919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff04831182151516156141d2576141d261416b565b500290565b600082198211156141ea576141ea61416b565b500190565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8214156142215761422161416b565b5060010190565b60006020828403121561423a57600080fd5b81518015158114613be757600080fd5b60006020828403121561425c57600080fd5b5035919050565b6000806040838503121561427657600080fd5b823561428181613f02565b9150602083013567ffffffffffffffff81111561429d57600080fd5b6142a985828601613d94565b9150509250929050565b600061ffff808316818516818304811182151516156142d4576142d461416b565b02949350505050565b600061ffff8083168185168083038211156142fa576142fa61416b565b01949350505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b600060ff83168061434557614345614303565b8060ff84160491505092915050565b600060ff83168061436757614367614303565b8060ff84160691505092915050565b6000828210156143885761438861416b565b500390565b60008261439c5761439c614303565b500490565b6000808312837f8000000000000000000000000000000000000000000000000000000000000000018312811516156143db576143db61416b565b837f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01831381161561440f5761440f61416b565b50500390565b60007f80000000000000000000000000000000000000000000000000000000000000008214156144475761444761416b565b5060000390565b600063ffffffff8381169083168181101561446b5761446b61416b565b039392505050565b600063ffffffff8083168185168083038211156142fa576142fa61416b565b60008160030b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffff800000008114156144c8576144c861416b565b60000392915050565b60008160030b8360030b60008112817fffffffffffffffffffffffffffffffffffffffffffffffffffffffff80000000018312811516156145145761451461416b565b81637fffffff01831381161561452c5761452c61416b565b5090039392505050565b6000808212827f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff038413811516156145705761457061416b565b827f80000000000000000000000000000000000000000000000000000000000000000384128116156145a4576145a461416b565b50500190565b600063ffffffff808416806145c1576145c1614303565b92169190910692915050565b6000826145dc576145dc614303565b500690565b6000825160005b8181101561460257602081860181015185830152016145e8565b81811115614611576000828501525b509190910192915050565b600060ff821660ff84168160ff048111821515161561463d5761463d61416b565b029392505050565b600060ff821660ff84168060ff038211156146625761466261416b565b01939250505056fea264697066735822122031c4369840ac2c4a261ce0a0f6627b5af7cd6e7b971f22d05b05e2618c8b924164736f6c63430008090033",
  "deployedBytecode": "0x6080604052600436106100d25760003560e01c8063a4c0ed361161007f578063b9a1e84611610059578063b9a1e84614610201578063c956083814610221578063e2e9b07914610272578063f7e111e71461029257600080fd5b8063a4c0ed36146101a1578063afc82370146101c1578063b4c27385146101e157600080fd5b8063861399e7116100b0578063861399e7146101395780639b6be0651461014c5780639eca672c1461018157600080fd5b80630f05b7f6146100d75780632f646f95146100f95780637ba423fb14610119575b600080fd5b3480156100e357600080fd5b506100f76100f2366004613e4d565b6102a5565b005b34801561010557600080fd5b506100f7610114366004613e92565b6104d1565b34801561012557600080fd5b506100f7610134366004613e92565b6105b4565b6100f7610147366004613eb4565b610643565b34801561015857600080fd5b5061016c610167366004613f70565b6108bc565b60405190151581526020015b60405180910390f35b34801561018d57600080fd5b506100f761019c366004613fe3565b6109ce565b3480156101ad57600080fd5b5061016c6101bc366004614000565b610a02565b3480156101cd57600080fd5b506100f76101dc36600461405c565b610c2b565b3480156101ed57600080fd5b506100f76101fc366004613e4d565b610cf4565b34801561020d57600080fd5b506100f761021c366004614088565b610e57565b34801561022d57600080fd5b5061026461023c366004613fe3565b73ffffffffffffffffffffffffffffffffffffffff1660009081526002602052604090205490565b604051908152602001610178565b34801561027e57600080fd5b506100f761028d366004614088565b610f51565b6100f76102a0366004614110565b610f5c565b336000805b845181101561038c576000655af3107a400061033461032f8885815181106102d4576102d461413c565b6020026020010151604080517f00000000000000000000000000000000000000000000000000000000000000006020820152908101829052600090606001604051602081830303815290604052805190602001209050919050565b6110a9565b63ffffffff16610344919061419a565b905061036c848288858151811061035d5761035d61413c565b60200260200101516001611208565b61037681846141d7565b9250508080610384906141ef565b9150506102aa565b508083146103fb576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f494e56414c49445f414d4f554e5400000000000000000000000000000000000060448201526064015b60405180910390fd5b6040517f23b872dd00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8381166004830152306024830152604482018590527f000000000000000000000000000000000000000000000000000000000000000016906323b872dd906064015b602060405180830381600087803b15801561049257600080fd5b505af11580156104a6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104ca9190614228565b5050505050565b336104df8183856001611208565b6040517f23b872dd00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8281166004830152306024830152604482018490527f000000000000000000000000000000000000000000000000000000000000000016906323b872dd906064015b602060405180830381600087803b15801561057657600080fd5b505af115801561058a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105ae9190614228565b50505050565b336105c28183856000611208565b6040517f23b872dd00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8281166004830152306024830152604482018490527f000000000000000000000000000000000000000000000000000000000000000016906323b872dd9060640161055c565b336000805b85518110156106ca576000655af3107a400061067261032f8985815181106102d4576102d461413c565b63ffffffff16610682919061419a565b90506106aa848289858151811061069b5761069b61413c565b60200260200101516000611208565b6106b481846141d7565b92505080806106c2906141ef565b915050610648565b50806106d684866141d7565b1461073d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f494e56414c49445f414d4f554e5400000000000000000000000000000000000060448201526064016103f2565b6040517f40c10f19000000000000000000000000000000000000000000000000000000008152306004820152602481018590527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16906340c10f199034906044016000604051808303818588803b1580156107cc57600080fd5b505af11580156107e0573d6000803e3d6000fd5b50506040517f23b872dd00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8681166004830152306024830152604482018890527f00000000000000000000000000000000000000000000000000000000000000001693506323b872dd92506064019050602060405180830381600087803b15801561087c57600080fd5b505af1158015610890573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108b49190614228565b505050505050565b6000803373ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000161415610905575060016109a4565b3373ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016146109a4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600d60248201527f494e56414c49445f45524332300000000000000000000000000000000000000060448201526064016103f2565b60006109b28486018661424a565b90506109c087878385611208565b506001979650505050505050565b73ffffffffffffffffffffffffffffffffffffffff81166000908152600260205260409020546109fe8282611585565b5050565b6000803373ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000161415610a4b57506001610aea565b3373ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001614610aea576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600d60248201527f494e56414c49445f45524332300000000000000000000000000000000000000060448201526064016103f2565b6040831115610bfd57600080610b0285870187614263565b915091506000805b8251811015610b8b576000655af3107a4000610b3461032f8685815181106102d4576102d461413c565b63ffffffff16610b44919061419a565b9050610b6b8582868581518110610b5d57610b5d61413c565b602002602001015189611208565b610b7581846141d7565b9250508080610b83906141ef565b915050610b0a565b50808814610bf5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f494e56414c49445f414d4f554e5400000000000000000000000000000000000060448201526064016103f2565b505050610c1f565b600080610c0c8587018761405c565b91509150610c1c82888386611208565b50505b50600195945050505050565b3373ffffffffffffffffffffffffffffffffffffffff83168114610ce55773ffffffffffffffffffffffffffffffffffffffff80841660009081526003602090815260408083209385168352929052205460ff16610ce5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f4e4f545f415554484f52495a45445f544f5f53454e440000000000000000000060448201526064016103f2565b610cef838361176b565b505050565b336000805b8451811015610d6c576000655af3107a4000610d2361032f8885815181106102d4576102d461413c565b63ffffffff16610d33919061419a565b9050610d4c848288858151811061069b5761069b61413c565b610d5681846141d7565b9250508080610d64906141ef565b915050610cf9565b50808314610dd6576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f494e56414c49445f414d4f554e5400000000000000000000000000000000000060448201526064016103f2565b6040517f23b872dd00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8381166004830152306024830152604482018590527f000000000000000000000000000000000000000000000000000000000000000016906323b872dd90606401610478565b3373ffffffffffffffffffffffffffffffffffffffff84168114610f115773ffffffffffffffffffffffffffffffffffffffff80851660009081526003602090815260408083209385168352929052205460ff16610f11576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f4e4f545f415554484f52495a45445f544f5f53454e440000000000000000000060448201526064016103f2565b8160005b818110156108b457610f3f86868684818110610f3357610f3361413c565b9050602002013561176b565b80610f49816141ef565b915050610f15565b610cef838383611a53565b33610f7381610f6b84866141d7565b866000611208565b8215611022576040517f40c10f19000000000000000000000000000000000000000000000000000000008152306004820152602481018490527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16906340c10f199034906044016000604051808303818588803b15801561100857600080fd5b505af115801561101c573d6000803e3d6000fd5b50505050505b81156105ae576040517f23b872dd00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8281166004830152306024830152604482018490527f000000000000000000000000000000000000000000000000000000000000000016906323b872dd90606401610478565b60006110b482611de5565b61111a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f504c414e45545f4e4f545f45584953545300000000000000000000000000000060448201526064016103f2565b600061112783600c611e01565b905060ff81167f00000000000000000000000000000000000000000000000000000000000000007f000000000000000000000000000000000000000000000000000000000000000061117a8360026142b3565b6111859060016142dd565b61ffff16602081106111995761119961413c565b1a7f00000000000000000000000000000000000000000000000000000000000000006111c68460026142b3565b61ffff16602081106111da576111da61413c565b6111e891901a6101006142b3565b6111f291906142dd565b61ffff16611200919061419a565b949350505050565b7f0000000000000000000000000000000000000000000000000000000000000000156112e957427f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000008183108061127f5750808310155b6112e5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600660248201527f504155534544000000000000000000000000000000000000000000000000000060448201526064016103f2565b5050505b60008281526020819052604081206040805160e081018252825473ffffffffffffffffffffffffffffffffffffffff8116825264ffffffffff74010000000000000000000000000000000000000000820481166020840152790100000000000000000000000000000000000000000000000000909104811692820192909252600183015463ffffffff8082166060840152640100000000820490931660808301526901000000000000000000810460040b60a08301526e010000000000000000000000000000900490911660c08201529091506000906113c99085611e9d565b9050655af3107a40006113e08261014001516110a9565b63ffffffff166113f0919061419a565b8514611458576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f494e56414c49445f5354414b455f414d4f554e5400000000000000000000000060448201526064016103f2565b61146181612005565b61146b86826124ed565b6114778282600061289f565b61148084612bba565b821561149c576000848152600b602052604090204290556114ac565b6000848152600b60205260408120555b604080514381524260208201527f438e507c246c311193c77528e3de231eec8ce4727cce091a1dbbecf85b427893910160405180910390a1838673ffffffffffffffffffffffffffffffffffffffff167f9b17abd3d9e9f2eb79e7b7c875e68b77a80c7379ba64ec6ac0d1c254d303269b836060015184608001518560e001518a8960405161156e95949392919063ffffffff958616815260049490940b60208501529190931660408301526060820192909252901515608082015260a00190565b60405180910390a36108b48161012001518661309a565b73ffffffffffffffffffffffffffffffffffffffff821660008181526002602090815260408083208390558051858152918201929092527f05eefb5f2a67125e8c65550a4ffa0f542f75624e866ef58fb72bfb5475403092910160405180910390a26040517fa9059cbb00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8381166004830152602482018390527f0000000000000000000000000000000000000000000000000000000000000000169063a9059cbb90604401602060405180830381600087803b15801561167757600080fd5b505af115801561168b573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116af9190614228565b611715576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600f60248201527f4641494c45445f5452414e53464552000000000000000000000000000000000060448201526064016103f2565b604080516000808252602082015273ffffffffffffffffffffffffffffffffffffffff8416917f05eefb5f2a67125e8c65550a4ffa0f542f75624e866ef58fb72bfb547540309291015b60405180910390a25050565b600081815260208190526040812060018101549091906117909063ffffffff16613197565b509050806117fa576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f4e4f545f4143544956450000000000000000000000000000000000000000000060448201526064016103f2565b815473ffffffffffffffffffffffffffffffffffffffff85811691161461187d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600960248201527f4e4f545f4f574e4552000000000000000000000000000000000000000000000060448201526064016103f2565b8154790100000000000000000000000000000000000000000000000000900464ffffffffff161561190a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600f60248201527f45584954494e475f414c5245414459000000000000000000000000000000000060448201526064016103f2565b81547fffff0000000000ffffffffffffffffffffffffffffffffffffffffffffffffff167901000000000000000000000000000000000000000000000000004264ffffffffff8116919091029190911783556040805143815260208101929092527f438e507c246c311193c77528e3de231eec8ce4727cce091a1dbbecf85b427893910160405180910390a1604051839073ffffffffffffffffffffffffffffffffffffffff8616907fb9182e4e152947f1e6691fa0ee6f68f21f607fed825945c270e69995acad805f90600090a36105ae84655af3107a4000611a3e61032f87604080517f00000000000000000000000000000000000000000000000000000000000000006020820152908101829052600090606001604051602081830303815290604052805190602001209050919050565b63ffffffff16611a4e919061419a565b6131b6565b60008060005b83811015611d61576000611a90868684818110611a7857611a7861413c565b90506020020135600090815260208190526040902090565b8054909150611ac290790100000000000000000000000000000000000000000000000000900464ffffffffff16613231565b15611d4e57805473ffffffffffffffffffffffffffffffffffffffff888116911614611b4a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600960248201527f4e4f545f4f574e4552000000000000000000000000000000000000000000000060448201526064016103f2565b858583818110611b5c57611b5c61413c565b90506020020135600073ffffffffffffffffffffffffffffffffffffffff168873ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef60405160405180910390a46000600b6000888886818110611bd657611bd661413c565b9050602002013581526020019081526020016000205490506000811115611cb1578154611ca09073ffffffffffffffffffffffffffffffffffffffff16888886818110611c2557611c2561413c565b90506020020135611c9b8a8a88818110611c4157611c4161413c565b90506020020135604080517f00000000000000000000000000000000000000000000000000000000000000006020820152908101829052600090606001604051602081830303815290604052805190602001209050919050565b61330f565b611caa90856141d7565b9350611cec565b8154611cdf9073ffffffffffffffffffffffffffffffffffffffff16888886818110611c2557611c2561413c565b611ce990866141d7565b94505b5080547fffff0000000000000000000000000000000000000000000000000000000000001681556001810180547fffffffffffffffffffffffffffff0000000000000000000000000000000000001664010000000064ffffffffff4216021790555b5080611d59816141ef565b915050611a59565b5073ffffffffffffffffffffffffffffffffffffffff8516600090815260026020526040812054611d939084906141d7565b9050611d9f8682611585565b73ffffffffffffffffffffffffffffffffffffffff86166000908152600a6020526040812054611dd09084906141d7565b9050611ddc878261346d565b50505050505050565b6000611df4826034601061364f565b60ff166001149050919050565b600080611e108484604061364f565b90506000611e1f600283614332565b90506000611e2e600284614354565b905060007f01223334444555555666666677777777888888889999999aaaaaabbbbcccddef60ff841660208110611e6757611e6761413c565b1a905060ff8216611e855760048160ff16901c945050505050611e97565b611e90601082614354565b9450505050505b92915050565b6040805161018081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e08101829052610100810182905261012081018290526101408101829052610160810191909152600080611f0e8560600151613197565b85855260808088015164ffffffffff908116602088015283151560408089019190915263ffffffff80851660608a015260a0808c015160040b948a0194909452908a01805183169389019390935291511660c0808801919091528801511660e0860152865173ffffffffffffffffffffffffffffffffffffffff9081166101008701528751166101208601529092509050611ff684604080517f00000000000000000000000000000000000000000000000000000000000000006020820152908101829052600090606001604051602081830303815290604052805190602001209050919050565b61014084015250909392505050565b60a081015164ffffffffff1615612056576120238160a00151613231565b1561205657600060c082018190526060820181905260808201819052610120820181905260e08201819052604090910152565b6000816020015164ffffffffff164261206f9190614376565b90506000612081836101400151613664565b90506000610e1061ffff83166120bd63ffffffff7f0000000000000000000000000000000000000000000000000000000000000000168661419a565b6120c7919061419a565b6120d1919061438d565b606085015190915063ffffffff1660007f00000000000000000000000000000000000000000000000000000000000000001561240757600061211285613701565b905060008760400151612126576000612128565b815b90508084111561220e5760e08801516107089063ffffffff161561217a57828960e0015163ffffffff1661070861215f919061419a565b612169919061438d565b905061070881101561217a57506107085b6000610e10826121b063ffffffff7f0000000000000000000000000000000000000000000000000000000000000000168c61419a565b6121ba919061419a565b6121c4919061438d565b9050806121cf575060015b6121d98387614376565b8111156121ed576121ea8387614376565b90505b8960400151156121fb578094505b6122058187614376565b95505050612370565b8760400151156123705760008590506000896080015160040b13156123365760006127107f000000000000000000000000000000000000000000000000000000000000000061228761ffff8b1663ffffffff7f00000000000000000000000000000000000000000000000000000000000000001661419a565b612291919061419a565b61229b919061438d565b60808b01516122b39064ffffffffff16610e1061419a565b6122bd919061438d565b90508881106122ce57819450612328565b610e1061ffff891661230663ffffffff7f0000000000000000000000000000000000000000000000000000000000000000168461419a565b612310919061419a565b61231a919061438d565b945081851115612328578194505b6123328583614376565b9150505b60006123428684614376565b905080821115612366576123568183614376565b61236090866141d7565b94508091505b61220582876141d7565b876040015115612400576000836127106123aa7f00000000000000000000000000000000000000000000000000000000000000008961419a565b6123b4919061438d565b6123be91906141d7565b905060008160040b8a6080015160040b6123d891906143a1565b90506123e383614415565b8112156123f6576123f383614415565b90505b60040b60808a0152505b505061248f565b8560400151156124225761241b83836141d7565b915061248f565b6000610e1061245763ffffffff7f0000000000000000000000000000000000000000000000000000000000000000168861419a565b6124639061070861419a565b61246d919061438d565b905082811115612480575060009161248d565b61248a8184614376565b92505b505b638000000082106124b2576124a96001638000000061444e565b63ffffffff1691505b63ffffffff8216606087015260408601511580156124d85750606086015163ffffffff16155b156108b4576000610120870152505050505050565b806040015115612559576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f5354494c4c5f414354495645000000000000000000000000000000000000000060448201526064016103f2565b6000816060015163ffffffff16600014156125875761257c82610140015161376e565b61ffff169050612621565b8273ffffffffffffffffffffffffffffffffffffffff1682610100015173ffffffffffffffffffffffffffffffffffffffff1614612621576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600860248201527f4f4343555049454400000000000000000000000000000000000000000000000060448201526064016103f2565b6000612631836101400151613664565b9050600061263e82613701565b73ffffffffffffffffffffffffffffffffffffffff8616610120860152905063ffffffff8316156127905760006126b67f000000000000000000000000000000000000000000000000000000000000000063ffffffff168563ffffffff166127106126ad896101400151613805565b61ffff1661389c565b5090507f000000000000000000000000000000000000000000000000000000000000000063ffffffff168163ffffffff161061274e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600f60248201527f4641494c45445f4341505455524544000000000000000000000000000000000060448201526064016103f2565b612778817f000000000000000000000000000000000000000000000000000000000000000061444e565b63ffffffff16606086015250600060e0850152612831565b7f0000000000000000000000000000000000000000000000000000000000000000846060018181516127c29190614473565b63ffffffff169052507f000000000000000000000000000000000000000000000000000000000000000015612831578063ffffffff16846060015163ffffffff16111561282957808460600151612819919061444e565b63ffffffff1660e0850152612831565b600060e08501525b60608401516127106128697f000000000000000000000000000000000000000000000000000000000000000063ffffffff851661419a565b612873919061438d565b61287c90614492565b61288691906144d1565b60030b6080850152505060016040909201919091525050565b60008260a0015164ffffffffff161180156128c3575060c082015164ffffffffff16155b156128d1576128d182613a3d565b81610120015173ffffffffffffffffffffffffffffffffffffffff1682610100015173ffffffffffffffffffffffffffffffffffffffff1614612a365761012082015183547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff9091169081178455156129a55782547fffffffffffffff0000000000ffffffffffffffffffffffffffffffffffffffff16740100000000000000000000000000000000000000004264ffffffffff16021783556129cc565b82547fffffffffffffff0000000000ffffffffffffffffffffffffffffffffffffffff1683555b816000015182610120015173ffffffffffffffffffffffffffffffffffffffff1683610100015173ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef60405160405180910390a45b8015612a675782547fffff0000000000ffffffffffffffffffffffffffffffffffffffffffffffffff168355612ad8565b8160a0015164ffffffffff168260c0015164ffffffffff1614612ad85760c0820151835464ffffffffff909116790100000000000000000000000000000000000000000000000000027fffff0000000000ffffffffffffffffffffffffffffffffffffffffffffffffff9091161783555b612aea82604001518360600151613bc8565b60019093018054608084015160e0909401514264ffffffffff908116640100000000027fffffffffffffffffffffffffffffffffffffffffffffff0000000000ffffffff63ffffffff9384166e01000000000000000000000000000002167fffffffffffffffffffffffffffff00000000ffffffffff0000000000ffffffff929097166901000000000000000000027fffffffffffffffffffffffffffffffffffff0000000000ffffffffff00000000909416979092169690961791909117949094169290921792909217905550565b604080516080808201835260055463ffffffff80821684526401000000008204811660208501526801000000000000000082048116948401949094526c0100000000000000000000000090049092166060820152906fffffffffffffffffffffffffffffffff8316600f0b9083901d600080831215612d1a57835163ffffffff16612c4484614415565b1315612cac576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f4e4f545f524541434841424c455f5945545f4d494e580000000000000000000060448201526064016103f2565b7f000000000000000000000000000000000000000000000000000000000000000060030b612cd984614415565b612ce39190614536565b925063ffffffff831315612cf95763ffffffff92505b835163ffffffff16831315612d15575063ffffffff8216835260015b612df9565b836020015163ffffffff16831315612d8e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f4e4f545f524541434841424c455f5945545f4d4158580000000000000000000060448201526064016103f2565b612dbb7f000000000000000000000000000000000000000000000000000000000000000060030b84614536565b925063ffffffff831315612dd15763ffffffff92505b8263ffffffff16846020015163ffffffff161015612df9575063ffffffff8216602084015260015b6000821215612ef257604084015163ffffffff16612e1683614415565b1315612e7e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f4e4f545f524541434841424c455f5945545f4d494e590000000000000000000060448201526064016103f2565b7f000000000000000000000000000000000000000000000000000000000000000060030b612eab83614415565b612eb59190614536565b915063ffffffff821315612ecb5763ffffffff91505b81846040015163ffffffff161215612eed575063ffffffff8116604084015260015b612fcb565b836060015163ffffffff16821315612f66576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f4e4f545f524541434841424c455f5945545f4d4158590000000000000000000060448201526064016103f2565b612f937f000000000000000000000000000000000000000000000000000000000000000060030b83614536565b915063ffffffff821315612fa95763ffffffff91505b81846060015163ffffffff161215612fcb575063ffffffff8116606084015260015b80156104ca5783516005805460208701516040880151606089015163ffffffff9081166c01000000000000000000000000027fffffffffffffffffffffffffffffffff00000000ffffffffffffffffffffffff9282166801000000000000000002929092167fffffffffffffffffffffffffffffffff0000000000000000ffffffffffffffff938216640100000000027fffffffffffffffffffffffffffffffffffffffffffffffff000000000000000090951691909616179290921716929092179190911790555050505050565b6109fe6130c57f27ec6af4a6510eb9b7e0cc7f39415b7f15e430e53eb0cd3997e7c7e0cf680f6e5490565b60405173ffffffffffffffffffffffffffffffffffffffff85166024820152604481018490527ff5d82b6b00000000000000000000000000000000000000000000000000000000906064015b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff000000000000000000000000000000000000000000000000000000009093169290921790915262017700613bee565b63800000008181168114906000906131af90846145aa565b9050915091565b6109fe6131e17f27ec6af4a6510eb9b7e0cc7f39415b7f15e430e53eb0cd3997e7c7e0cf680f6e5490565b60405173ffffffffffffffffffffffffffffffffffffffff85166024820152604481018490527fabe7f1ab0000000000000000000000000000000000000000000000000000000090606401613111565b600064ffffffffff821661324757506000919050565b427f00000000000000000000000000000000000000000000000000000000000000001580159061329757507f00000000000000000000000000000000000000000000000000000000000000008110155b80156132c957507f00000000000000000000000000000000000000000000000000000000000000008364ffffffffff16105b156132d75750600192915050565b6133087f000000000000000000000000000000000000000000000000000000000000000064ffffffffff85166141d7565b1092915050565b6000655af3107a4000613321836110a9565b63ffffffff16613331919061419a565b604080514381524260208201529192507f438e507c246c311193c77528e3de231eec8ce4727cce091a1dbbecf85b427893910160405180910390a1828473ffffffffffffffffffffffffffffffffffffffff167f1c363b29828a892b7cddafe9583ef52e0d5aca0ea7011bda6ccf039e1781f738836040516133b591815260200190565b60405180910390a360008381526007602052604090205480156134655773ffffffffffffffffffffffffffffffffffffffff85166000818152600860209081526040808320858452825280832080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001660011790558783526007909152808220829055518392879290917f74f110a1e0cd4892234c7ba49df9f8a354cd8d29b272f7557c9b8c3c38a653369190a45b509392505050565b73ffffffffffffffffffffffffffffffffffffffff82166000818152600a602090815260408083209290925581518481526001918101919091527f05eefb5f2a67125e8c65550a4ffa0f542f75624e866ef58fb72bfb5475403092910160405180910390a26040517fa9059cbb00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8381166004830152602482018390527f0000000000000000000000000000000000000000000000000000000000000000169063a9059cbb90604401602060405180830381600087803b15801561356257600080fd5b505af1158015613576573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061359a9190614228565b613600576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600f60248201527f4641494c45445f5452414e53464552000000000000000000000000000000000060448201526064016103f2565b60408051600081526001602082015273ffffffffffffffffffffffffffffffffffffffff8416917f05eefb5f2a67125e8c65550a4ffa0f542f75624e866ef58fb72bfb5475403092910161175f565b600061120060ff80841690851686901c6145cd565b600061366f82611de5565b6136d5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f504c414e45545f4e4f545f45584953545300000000000000000000000000000060448201526064016103f2565b611e9782600c7f0708083409600a8c0bb80ce40e100e100e100e101068151819c81e7823282ee0613ceb565b6000610e106137347f000000000000000000000000000000000000000000000000000000000000000061ffff851661419a565b61373e919061438d565b611e979063ffffffff7f0000000000000000000000000000000000000000000000000000000000000000166141d7565b600061377982611de5565b6137df576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f504c414e45545f4e4f545f45584953545300000000000000000000000000000060448201526064016103f2565b6137ea82602c611e01565b6137f99060ff16610bb86142b3565b611e9790613a986142dd565b600061381082611de5565b613876576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f504c414e45545f4e4f545f45584953545300000000000000000000000000000060448201526064016103f2565b61388182601c611e01565b6138909060ff166101906142b3565b611e9790610fa06142dd565b6000808515806138aa575084155b156138ba57506000905080613a34565b6000856138e7887f000000000000000000000000000000000000000000000000000000000000000061419a565b6138f1919061438d565b61391e7f0000000000000000000000000000000000000000000000000000000000000000620f4240614376565b61392891906141d7565b613932908861419a565b90506000620f424085613945888561419a565b61394f919061438d565b613959919061438d565b90508087111561396e57879350809250613a31565b60008861399b897f000000000000000000000000000000000000000000000000000000000000000061419a565b6139a5919061438d565b6139d27f0000000000000000000000000000000000000000000000000000000000000000620f4240614376565b6139dc91906141d7565b6139e6908961419a565b90506000620f4240886139f9898561419a565b613a03919061438d565b613a0d919061438d565b63ffffffff169050898110613a2a57613a2760018b614376565b90505b9450879350505b50505b94509492505050565b6000613a58826101000151836000015184610140015161330f565b82516000908152600b60205260409020549091508015613b245761010083015173ffffffffffffffffffffffffffffffffffffffff166000908152600a6020526040812054613aa89084906141d7565b6101008501805173ffffffffffffffffffffffffffffffffffffffff9081166000908152600a6020908152604091829020859055925181518581526001948101949094529394509216917f05eefb5f2a67125e8c65550a4ffa0f542f75624e866ef58fb72bfb547540309291015b60405180910390a250505050565b61010083015173ffffffffffffffffffffffffffffffffffffffff16600090815260026020526040812054613b5a9084906141d7565b6101008501805173ffffffffffffffffffffffffffffffffffffffff9081166000908152600260209081526040808320869055935184518681529182019290925293945016917f05eefb5f2a67125e8c65550a4ffa0f542f75624e866ef58fb72bfb54754030929101613b16565b60008183613bd7576000613bdd565b63800000005b613be79190614473565b9392505050565b73ffffffffffffffffffffffffffffffffffffffff831615610cef578273ffffffffffffffffffffffffffffffffffffffff168183604051613c3091906145e1565b60006040518083038160008787f1925050503d8060008114613c6e576040519150601f19603f3d011682016040523d82523d6000602084013e613c73565b606091505b505050603f81613c83919061438d565b5a11610cef576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f4e4f545f454e4f5547485f4741535f464f525f494e4e45525f43414c4c00000060448201526064016103f2565b600080613cf88585611e01565b905082613d0682600261461c565b613d11906001614645565b60ff1660208110613d2457613d2461413c565b1a83613d3183600261461c565b60ff1660208110613d4457613d4461413c565b613d5291901a6101006142b3565b613d5c91906142dd565b95945050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f830112613da557600080fd5b8135602067ffffffffffffffff80831115613dc257613dc2613d65565b8260051b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0603f83011681018181108482111715613e0557613e05613d65565b604052938452858101830193838101925087851115613e2357600080fd5b83870191505b84821015613e4257813583529183019190830190613e29565b979650505050505050565b60008060408385031215613e6057600080fd5b823567ffffffffffffffff811115613e7757600080fd5b613e8385828601613d94565b95602094909401359450505050565b60008060408385031215613ea557600080fd5b50508035926020909101359150565b600080600060608486031215613ec957600080fd5b833567ffffffffffffffff811115613ee057600080fd5b613eec86828701613d94565b9660208601359650604090950135949350505050565b73ffffffffffffffffffffffffffffffffffffffff81168114613f2457600080fd5b50565b60008083601f840112613f3957600080fd5b50813567ffffffffffffffff811115613f5157600080fd5b602083019150836020828501011115613f6957600080fd5b9250929050565b600080600080600060808688031215613f8857600080fd5b8535613f9381613f02565b94506020860135613fa381613f02565b935060408601359250606086013567ffffffffffffffff811115613fc657600080fd5b613fd288828901613f27565b969995985093965092949392505050565b600060208284031215613ff557600080fd5b8135613be781613f02565b6000806000806060858703121561401657600080fd5b843561402181613f02565b935060208501359250604085013567ffffffffffffffff81111561404457600080fd5b61405087828801613f27565b95989497509550505050565b6000806040838503121561406f57600080fd5b823561407a81613f02565b946020939093013593505050565b60008060006040848603121561409d57600080fd5b83356140a881613f02565b9250602084013567ffffffffffffffff808211156140c557600080fd5b818601915086601f8301126140d957600080fd5b8135818111156140e857600080fd5b8760208260051b85010111156140fd57600080fd5b6020830194508093505050509250925092565b60008060006060848603121561412557600080fd5b505081359360208301359350604090920135919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff04831182151516156141d2576141d261416b565b500290565b600082198211156141ea576141ea61416b565b500190565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8214156142215761422161416b565b5060010190565b60006020828403121561423a57600080fd5b81518015158114613be757600080fd5b60006020828403121561425c57600080fd5b5035919050565b6000806040838503121561427657600080fd5b823561428181613f02565b9150602083013567ffffffffffffffff81111561429d57600080fd5b6142a985828601613d94565b9150509250929050565b600061ffff808316818516818304811182151516156142d4576142d461416b565b02949350505050565b600061ffff8083168185168083038211156142fa576142fa61416b565b01949350505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b600060ff83168061434557614345614303565b8060ff84160491505092915050565b600060ff83168061436757614367614303565b8060ff84160691505092915050565b6000828210156143885761438861416b565b500390565b60008261439c5761439c614303565b500490565b6000808312837f8000000000000000000000000000000000000000000000000000000000000000018312811516156143db576143db61416b565b837f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01831381161561440f5761440f61416b565b50500390565b60007f80000000000000000000000000000000000000000000000000000000000000008214156144475761444761416b565b5060000390565b600063ffffffff8381169083168181101561446b5761446b61416b565b039392505050565b600063ffffffff8083168185168083038211156142fa576142fa61416b565b60008160030b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffff800000008114156144c8576144c861416b565b60000392915050565b60008160030b8360030b60008112817fffffffffffffffffffffffffffffffffffffffffffffffffffffffff80000000018312811516156145145761451461416b565b81637fffffff01831381161561452c5761452c61416b565b5090039392505050565b6000808212827f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff038413811516156145705761457061416b565b827f80000000000000000000000000000000000000000000000000000000000000000384128116156145a4576145a461416b565b50500190565b600063ffffffff808416806145c1576145c1614303565b92169190910692915050565b6000826145dc576145dc614303565b500690565b6000825160005b8181101561460257602081860181015185830152016145e8565b81811115614611576000828501525b509190910192915050565b600060ff821660ff84168160ff048111821515161561463d5761463d61416b565b029392505050565b600060ff821660ff84168060ff038211156146625761466261416b565b01939250505056fea264697066735822122031c4369840ac2c4a261ce0a0f6627b5af7cd6e7b971f22d05b05e2618c8b924164736f6c63430008090033",
  "linkReferences": {},
  "deployedLinkReferences": {},
  "immutableReferences": {
    "11573": [
      {
        "length": 32,
        "start": 1556
      },
      {
        "length": 32,
        "start": 1906
      },
      {
        "length": 32,
        "start": 2100
      },
      {
        "length": 32,
        "start": 2333
      },
      {
        "length": 32,
        "start": 2659
      },
      {
        "length": 32,
        "start": 3624
      },
      {
        "length": 32,
        "start": 4014
      },
      {
        "length": 32,
        "start": 4218
      },
      {
        "length": 32,
        "start": 5683
      }
    ],
    "11576": [
      {
        "length": 32,
        "start": 1101
      },
      {
        "length": 32,
        "start": 1329
      },
      {
        "length": 32,
        "start": 2263
      },
      {
        "length": 32,
        "start": 2589
      },
      {
        "length": 32,
        "start": 13598
      }
    ],
    "11581": [
      {
        "length": 32,
        "start": 738
      },
      {
        "length": 32,
        "start": 6641
      },
      {
        "length": 32,
        "start": 7246
      },
      {
        "length": 32,
        "start": 8105
      }
    ],
    "11587": [
      {
        "length": 32,
        "start": 13020
      }
    ],
    "11589": [
      {
        "length": 32,
        "start": 9840
      },
      {
        "length": 32,
        "start": 9915
      },
      {
        "length": 32,
        "start": 10068
      },
      {
        "length": 32,
        "start": 10130
      },
      {
        "length": 32,
        "start": 14153
      }
    ],
    "11591": [
      {
        "length": 32,
        "start": 8343
      },
      {
        "length": 32,
        "start": 8586
      },
      {
        "length": 32,
        "start": 8802
      },
      {
        "length": 32,
        "start": 8928
      },
      {
        "length": 32,
        "start": 9265
      }
    ],
    "11595": [
      {
        "length": 32,
        "start": 8419
      },
      {
        "length": 32,
        "start": 10189
      },
      {
        "length": 32,
        "start": 14091
      }
    ],
    "11597": [
      {
        "length": 32,
        "start": 8756
      },
      {
        "length": 32,
        "start": 9093
      },
      {
        "length": 32,
        "start": 10302
      }
    ],
    "11599": [
      {
        "length": 32,
        "start": 14531
      },
      {
        "length": 32,
        "start": 14582
      },
      {
        "length": 32,
        "start": 14711
      },
      {
        "length": 32,
        "start": 14762
      }
    ],
    "11603": [
      {
        "length": 32,
        "start": 11438
      },
      {
        "length": 32,
        "start": 11667
      },
      {
        "length": 32,
        "start": 11904
      },
      {
        "length": 32,
        "start": 12139
      }
    ],
    "11607": [
      {
        "length": 32,
        "start": 4432
      },
      {
        "length": 32,
        "start": 4508
      }
    ],
    "11609": [
      {
        "length": 32,
        "start": 4399
      }
    ],
    "11611": [
      {
        "length": 32,
        "start": 4618
      },
      {
        "length": 32,
        "start": 4657
      },
      {
        "length": 32,
        "start": 12874
      },
      {
        "length": 32,
        "start": 12916
      }
    ],
    "11613": [
      {
        "length": 32,
        "start": 4690
      },
      {
        "length": 32,
        "start": 12960
      }
    ]
  },
  "inputSourceName": "project/src/outerspace/facets/OuterSpaceStakingFacet.sol",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "evm": {
    "gasEstimates": {
      "creation": {
        "codeDepositCost": "3616000",
        "executionCost": "infinite",
        "totalCost": "infinite"
      },
      "external": {
        "acquireMultipleViaFreeTokenTransferFrom(uint256[],uint256)": "infinite",
        "acquireMultipleViaNativeTokenAndStakingToken(uint256[],uint256,uint256)": "infinite",
        "acquireMultipleViaTransferFrom(uint256[],uint256)": "infinite",
        "acquireViaFreeTokenTransferFrom(uint256,uint256)": "infinite",
        "acquireViaNativeTokenAndStakingToken(uint256,uint256,uint256)": "infinite",
        "acquireViaTransferFrom(uint256,uint256)": "infinite",
        "balanceToWithdraw(address)": "2551",
        "exitFor(address,uint256)": "infinite",
        "exitMultipleFor(address,uint256[])": "infinite",
        "fetchAndWithdrawFor(address,uint256[])": "infinite",
        "onTokenPaidFor(address,address,uint256,bytes)": "infinite",
        "onTokenTransfer(address,uint256,bytes)": "infinite",
        "withdrawFor(address)": "infinite"
      }
    }
  },
  "metadata": "{\"compiler\":{\"version\":\"0.8.9+commit.e5eed63a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"components\":[{\"internalType\":\"contract StakingToken\",\"name\":\"stakingToken\",\"type\":\"address\"},{\"internalType\":\"contract IFreePlayToken\",\"name\":\"freeStakingToken\",\"type\":\"address\"},{\"internalType\":\"contract AllianceRegistry\",\"name\":\"allianceRegistry\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"genesis\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"resolveWindow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timePerDistance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"exitDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"acquireNumSpaceships\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"productionSpeedUp\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"frontrunningDelay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"productionCapAsDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"upkeepProductionDecreaseRatePer10000th\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fleetSizeFactor6\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"initialSpaceExpansion\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"expansionDelta\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"giftTaxPer10000\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"stakeRange\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"stakeMultiplier10000th\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bootstrapSessionEndTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"infinityStartTime\",\"type\":\"uint256\"}],\"internalType\":\"struct OuterSpaceFacetBase.Config\",\"name\":\"config\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"BlockTime\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"location\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"}],\"name\":\"ExitComplete\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fleet\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fleetOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"destinationOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"destination\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"gift\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"won\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"newNumspaceships\",\"type\":\"uint32\"},{\"internalType\":\"int40\",\"name\":\"newTravelingUpkeep\",\"type\":\"int40\"},{\"internalType\":\"uint32\",\"name\":\"newOverflow\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"numSpaceshipsAtArrival\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"taxLoss\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"fleetLoss\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"planetLoss\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"inFlightFleetLoss\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"inFlightPlanetLoss\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"accumulatedDefenseAdded\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"accumulatedAttackAdded\",\"type\":\"uint32\"}],\"indexed\":false,\"internalType\":\"struct ImportingOuterSpaceEvents.ArrivalData\",\"name\":\"data\",\"type\":\"tuple\"}],\"name\":\"FleetArrived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fleetId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"arrivalTimeWanted\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"gift\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"specific\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"secret\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fleetSender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"FleetRevealed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fleetSender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fleetOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fleet\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"quantity\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"newNumSpaceships\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"int40\",\"name\":\"newTravelingUpkeep\",\"type\":\"int40\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"newOverflow\",\"type\":\"uint32\"}],\"name\":\"FleetSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newGeneratorAdmin\",\"type\":\"address\"}],\"name\":\"GeneratorAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newGenerator\",\"type\":\"address\"}],\"name\":\"GeneratorChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"genesis\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"resolveWindow\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timePerDistance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"exitDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"acquireNumSpaceships\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"productionSpeedUp\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"frontrunningDelay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"productionCapAsDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"upkeepProductionDecreaseRatePer10000th\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fleetSizeFactor6\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"initialSpaceExpansion\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"expansionDelta\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"giftTaxPer10000\",\"type\":\"uint256\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"location\",\"type\":\"uint256\"}],\"name\":\"PlanetExit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"location\",\"type\":\"uint256\"}],\"name\":\"PlanetReset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"acquirer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"location\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"numSpaceships\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"int40\",\"name\":\"travelingUpkeep\",\"type\":\"int40\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"overflow\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"freegift\",\"type\":\"bool\"}],\"name\":\"PlanetStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"location\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"newNumspaceships\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"int40\",\"name\":\"newTravelingUpkeep\",\"type\":\"int40\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"newOverflow\",\"type\":\"uint32\"}],\"name\":\"PlanetTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"location\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"giver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardId\",\"type\":\"uint256\"}],\"name\":\"RewardSetup\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"location\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rewardId\",\"type\":\"uint256\"}],\"name\":\"RewardToWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newStake\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"freegift\",\"type\":\"bool\"}],\"name\":\"StakeToWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"location\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"origin\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fleet\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"newNumspaceships\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"int40\",\"name\":\"newTravelingUpkeep\",\"type\":\"int40\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"newOverflow\",\"type\":\"uint32\"}],\"name\":\"TravelingUpkeepRefund\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"locations\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"acquireMultipleViaFreeTokenTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"locations\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"amountToMint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"acquireMultipleViaNativeTokenAndStakingToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"locations\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"acquireMultipleViaTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"location\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"acquireViaFreeTokenTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"location\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountToMint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"acquireViaNativeTokenAndStakingToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"location\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"acquireViaTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceToWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"location\",\"type\":\"uint256\"}],\"name\":\"exitFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"locations\",\"type\":\"uint256[]\"}],\"name\":\"exitMultipleFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"locations\",\"type\":\"uint256[]\"}],\"name\":\"fetchAndWithdrawFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"forAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onTokenPaidFor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onTokenTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"withdrawFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"project/src/outerspace/facets/OuterSpaceStakingFacet.sol\":\"OuterSpaceStakingFacet\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":999999},\"remappings\":[\"project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@4.3.2/\",\"project/:@rocketh/proxy/=npm/@rocketh/proxy@0.18.4/\",\"project/:hardhat/=npm/hardhat@3.1.7/\"]},\"sources\":{\"npm/@openzeppelin/contracts@4.3.2/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x027b891937d20ccf213fdb9c31531574256de774bda99d3a70ecef6e1913ed2a\",\"license\":\"MIT\"},\"npm/@openzeppelin/contracts@4.3.2/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3336baae5cf23e94274d75336e2d412193be508504aee185e61dc7d58cd05c8a\",\"license\":\"MIT\"},\"npm/@openzeppelin/contracts@4.3.2/utils/cryptography/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s;\\n        uint8 v;\\n        assembly {\\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            v := add(shr(255, vs), 27)\\n        }\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\",\"keccak256\":\"0xbc991a1cf357ce19480831a40792c814238a3b5458134703682abd8aa39719fb\",\"license\":\"MIT\"},\"npm/@rocketh/proxy@0.18.4/solc_0_8/ERC1967/Proxied.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract Proxied {\\n    /// @notice to be used by initialisation / postUpgrade function so that only the proxy's admin can execute them\\n    /// It also allows these functions to be called inside a contructor\\n    /// even if the contract is meant to be used without proxy\\n    modifier proxied() {\\n        address proxyAdminAddress = _proxyAdmin();\\n        // With hardhat-deploy proxies\\n        // the proxyAdminAddress is zero only for the implementation contract\\n        // if the implementation contract want to be used as a standalone/immutable contract\\n        // it simply has to execute the `proxied` function\\n        // This ensure the proxyAdminAddress is never zero post deployment\\n        // And allow you to keep the same code for both proxied contract and immutable contract\\n        if (proxyAdminAddress == address(0)) {\\n            // ensure can not be called twice when used outside of proxy : no admin\\n            // solhint-disable-next-line security/no-inline-assembly\\n            assembly {\\n                sstore(\\n                    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103,\\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n                )\\n            }\\n        } else {\\n            require(msg.sender == proxyAdminAddress);\\n        }\\n        _;\\n    }\\n\\n    modifier onlyProxyAdmin() {\\n        require(msg.sender == _proxyAdmin(), \\\"NOT_AUTHORIZED\\\");\\n        _;\\n    }\\n\\n    function _proxyAdmin() internal view returns (address ownerAddress) {\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            ownerAddress := sload(0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xaaceeafeeaf0d200ca3942d8bf14c1c4f787a77f79cc87c08bb668e65acdee29\",\"license\":\"MIT\"},\"npm/hardhat@3.1.7/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nlibrary console {\\n    address constant CONSOLE_ADDRESS =\\n        0x000000000000000000636F6e736F6c652e6c6f67;\\n\\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            pop(\\n                staticcall(\\n                    gas(),\\n                    consoleAddress,\\n                    add(payload, 32),\\n                    mload(payload),\\n                    0,\\n                    0\\n                )\\n            )\\n        }\\n    }\\n\\n    function _castToPure(\\n      function(bytes memory) internal view fnIn\\n    ) internal pure returns (function(bytes memory) pure fnOut) {\\n        assembly {\\n            fnOut := fnIn\\n        }\\n    }\\n\\n    function _sendLogPayload(bytes memory payload) internal pure {\\n        _castToPure(_sendLogPayloadImplementation)(payload);\\n    }\\n\\n    function log() internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n    function logInt(int256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n    }\\n\\n    function logUint(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint256 p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n}\\n\",\"keccak256\":\"0x7434453e6d3b7d0e5d0eb7846ffdbc27f0ccf3b163591263739b628074dc103a\",\"license\":\"MIT\"},\"project/src/alliances/AllianceRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity 0.8.9;\\n\\nimport \\\"@rocketh/proxy/solc_0_8/ERC1967/Proxied.sol\\\";\\nimport \\\"../interfaces/IAlliance.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\n// import \\\"hardhat/console.sol\\\";\\n\\ncontract AllianceRegistry is Proxied {\\n    using ECDSA for bytes32;\\n\\n    uint8 internal constant MAX_NUM_ALLIANCES = 4;\\n\\n    mapping(address => mapping(IAlliance => uint256)) internal _allianceNonces;\\n    struct AllianceRow {\\n        IAlliance alliance;\\n        uint96 joinTime;\\n    }\\n    struct Alliances {\\n        AllianceRow alliance0;\\n        AllianceRow alliance1;\\n        AllianceRow alliance2;\\n        AllianceRow alliance3;\\n    }\\n    mapping(address => Alliances) internal _alliances;\\n\\n    event AllianceLink(\\n        IAlliance indexed alliance,\\n        address indexed player,\\n        bool joining\\n    );\\n\\n    function getAllianceDataAtSlot(\\n        address player,\\n        uint8 slot\\n    )\\n        external\\n        view\\n        returns (IAlliance alliance, uint96 joinTime, uint256 nonce)\\n    {\\n        Alliances storage alliances = _alliances[player];\\n        if (slot == 0) {\\n            alliance = alliances.alliance0.alliance;\\n            joinTime = alliances.alliance0.joinTime;\\n        } else if (slot == 1) {\\n            alliance = alliances.alliance1.alliance;\\n            joinTime = alliances.alliance1.joinTime;\\n        } else if (slot == 2) {\\n            alliance = alliances.alliance2.alliance;\\n            joinTime = alliances.alliance2.joinTime;\\n        } else if (slot == 3) {\\n            alliance = alliances.alliance3.alliance;\\n            joinTime = alliances.alliance3.joinTime;\\n        }\\n\\n        nonce = _allianceNonces[player][alliance];\\n    }\\n\\n    function getAllianceData(\\n        address player,\\n        IAlliance alliance\\n    ) public view returns (uint96 joinTime, uint256 nonce) {\\n        nonce = _allianceNonces[player][alliance];\\n\\n        Alliances storage alliances = _alliances[player];\\n        if (alliances.alliance0.alliance == alliance) {\\n            joinTime = alliances.alliance0.joinTime;\\n        } else if (alliances.alliance1.alliance == alliance) {\\n            joinTime = alliances.alliance1.joinTime;\\n        } else if (alliances.alliance2.alliance == alliance) {\\n            joinTime = alliances.alliance2.joinTime;\\n        } else if (alliances.alliance3.alliance == alliance) {\\n            joinTime = alliances.alliance3.joinTime;\\n        }\\n    }\\n\\n    function havePlayersAnAllianceInCommon(\\n        address player1,\\n        address player2,\\n        uint256 timestamp\\n    ) external view returns (IAlliance alliance, uint96 joinTime) {\\n        Alliances storage p1Alliances = _alliances[player1];\\n        Alliances storage p2Alliances = _alliances[player2];\\n\\n        AllianceRow[4] memory player1Alliances;\\n        AllianceRow[4] memory player2Alliances;\\n        uint256 num1 = 0;\\n        uint256 num2 = 0;\\n\\n        for (uint256 i = 0; i < 4; i++) {\\n            if (i == num1) {\\n                AllianceRow memory allianceRow;\\n                if (i == 0) {\\n                    allianceRow = p1Alliances.alliance0;\\n                } else if (i == 1) {\\n                    allianceRow = p1Alliances.alliance1;\\n                } else if (i == 2) {\\n                    allianceRow = p1Alliances.alliance2;\\n                } else if (i == 3) {\\n                    allianceRow = p1Alliances.alliance3;\\n                }\\n                if (address(allianceRow.alliance) == address(0)) {\\n                    // console.log(\\\"p1 exhausted\\\");\\n                    return (alliance, joinTime); // the alliance leave ensure that there is no gap // TODO\\n                }\\n                player1Alliances[num1++] = allianceRow;\\n            }\\n            for (uint256 j = 0; j < 4; j++) {\\n                if (j == num2) {\\n                    AllianceRow memory allianceRow;\\n                    if (j == 0) {\\n                        allianceRow = p2Alliances.alliance0;\\n                    } else if (j == 1) {\\n                        allianceRow = p2Alliances.alliance1;\\n                    } else if (j == 2) {\\n                        allianceRow = p2Alliances.alliance2;\\n                    } else if (j == 3) {\\n                        allianceRow = p2Alliances.alliance3;\\n                    }\\n                    if (address(allianceRow.alliance) == address(0)) {\\n                        // console.log(\\\"p2 exhausted\\\");\\n                        // return (alliance, joinTime); // the alliance leave ensure that there is no gap // TODO\\n                        break;\\n                    }\\n                    player2Alliances[num2++] = allianceRow;\\n                }\\n\\n                if (\\n                    player1Alliances[i].alliance == player2Alliances[j].alliance\\n                ) {\\n                    if (\\n                        player1Alliances[i].joinTime >=\\n                        player2Alliances[j].joinTime\\n                    ) {\\n                        if (player1Alliances[i].joinTime < timestamp) {\\n                            return (\\n                                player1Alliances[i].alliance,\\n                                player1Alliances[i].joinTime\\n                            );\\n                        } else {\\n                            // TODO check greater ?\\n                            alliance = player1Alliances[i].alliance;\\n                            joinTime = player1Alliances[i].joinTime;\\n                        }\\n                    } else {\\n                        if (player2Alliances[j].joinTime < timestamp) {\\n                            return (\\n                                player2Alliances[j].alliance,\\n                                player2Alliances[j].joinTime\\n                            );\\n                        } else {\\n                            // TODO check greater ?\\n                            alliance = player2Alliances[j].alliance;\\n                            joinTime = player2Alliances[j].joinTime;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        // console.log(address(alliance));\\n        // console.log(joinTime);\\n    }\\n\\n    // -----------------------------------------------------------------------------------------------------\\n    // FROM PLAYER\\n    // -----------------------------------------------------------------------------------------------------\\n\\n    function joinAlliance(\\n        IAlliance alliance,\\n        bytes calldata data\\n    ) external returns (bool joined) {\\n        Alliances storage alliances = _alliances[msg.sender];\\n        uint256 slot = 0;\\n        if (address(alliances.alliance0.alliance) != address(0)) {\\n            slot++;\\n        }\\n        if (address(alliances.alliance1.alliance) != address(0)) {\\n            slot++;\\n        }\\n        if (address(alliances.alliance2.alliance) != address(0)) {\\n            slot++;\\n        }\\n        require(\\n            address(alliances.alliance3.alliance) == address(0),\\n            \\\"MAX_NUM_ALLIANCES_REACHED\\\"\\n        );\\n\\n        joined = alliance.requestToJoin(msg.sender, data);\\n        if (joined) {\\n            if (slot == 0) {\\n                alliances.alliance0.alliance = alliance;\\n                alliances.alliance0.joinTime = uint96(block.timestamp);\\n            } else if (slot == 1) {\\n                alliances.alliance1.alliance = alliance;\\n                alliances.alliance1.joinTime = uint96(block.timestamp);\\n            } else if (slot == 2) {\\n                alliances.alliance2.alliance = alliance;\\n                alliances.alliance2.joinTime = uint96(block.timestamp);\\n            } else if (slot == 3) {\\n                alliances.alliance3.alliance = alliance;\\n                alliances.alliance3.joinTime = uint96(block.timestamp);\\n            }\\n\\n            emit AllianceLink(alliance, msg.sender, true);\\n        }\\n    }\\n\\n    function leaveAlliance(IAlliance alliance) external {\\n        _leaveAlliance(msg.sender, alliance);\\n        try alliance.playerHasLeft(msg.sender) {} catch {}\\n        // TODO ensure callback not failed due to low gas (1/64 rule)\\n    }\\n\\n    // -----------------------------------------------------------------------------------------------------\\n    // FROM ALLIANCE\\n    // -----------------------------------------------------------------------------------------------------\\n\\n    function addPlayerToAlliance(\\n        address player,\\n        uint32 nonce,\\n        bytes calldata signature\\n    ) external {\\n        _addPlayerToAlliance(player, nonce, signature);\\n    }\\n\\n    struct PlayerSubmission {\\n        address addr;\\n        uint32 nonce;\\n        bytes signature;\\n    }\\n\\n    function addMultiplePlayersToAlliance(\\n        PlayerSubmission[] calldata playerSubmissions\\n    ) external {\\n        for (uint256 i = 0; i < playerSubmissions.length; i++) {\\n            _addPlayerToAlliance(\\n                playerSubmissions[i].addr,\\n                playerSubmissions[i].nonce,\\n                playerSubmissions[i].signature\\n            );\\n        }\\n    }\\n\\n    function ejectPlayerFromAlliance(address player) external {\\n        _leaveAlliance(player, IAlliance(msg.sender));\\n    }\\n\\n    // -----------------------------------------------------------------------------------------------------\\n    // INTERNAL\\n    // -----------------------------------------------------------------------------------------------------\\n\\n    function _addPlayerToAlliance(\\n        address player,\\n        uint32 nonce,\\n        bytes calldata signature\\n    ) internal {\\n        IAlliance alliance = IAlliance(msg.sender);\\n\\n        Alliances storage alliances = _alliances[player];\\n        uint256 slot = 0;\\n        if (address(alliances.alliance0.alliance) != address(0)) {\\n            require(alliances.alliance0.alliance != alliance, \\\"ALREADY_JOINED\\\");\\n            slot++;\\n        }\\n        if (address(alliances.alliance1.alliance) != address(0)) {\\n            require(alliances.alliance1.alliance != alliance, \\\"ALREADY_JOINED\\\");\\n            slot++;\\n        }\\n        if (address(alliances.alliance2.alliance) != address(0)) {\\n            require(alliances.alliance2.alliance != alliance, \\\"ALREADY_JOINED\\\");\\n            slot++;\\n        }\\n        require(alliances.alliance3.alliance != alliance, \\\"ALREADY_JOINED\\\");\\n        require(\\n            address(alliances.alliance3.alliance) == address(0),\\n            \\\"MAX_NUM_ALLIANCES_REACHED\\\"\\n        );\\n\\n        uint256 currentNonce = _allianceNonces[player][alliance];\\n        require(currentNonce == nonce, \\\"INVALID_NONCE\\\");\\n\\n        bytes memory message;\\n        if (nonce == 0) {\\n            message = abi.encodePacked(\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n56\\\",\\n                \\\"Join Alliance 0x0000000000000000000000000000000000000000\\\"\\n            );\\n            _writeUintAsHex(message, 28 + 55, uint160(msg.sender));\\n        } else {\\n            message = abi.encodePacked(\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n76\\\",\\n                \\\"Join Alliance 0x0000000000000000000000000000000000000000 (nonce:          0)\\\"\\n            );\\n            _writeUintAsHex(message, 28 + 55, uint160(msg.sender));\\n            _writeUintAsDecimal(message, 28 + 74, nonce);\\n        }\\n\\n        // console.log(string(message));\\n\\n        bytes32 digest = keccak256(message);\\n\\n        address signer = digest.recover(signature);\\n        require(player == signer, \\\"INVALID_SIGNATURE\\\");\\n\\n        if (slot == 0) {\\n            alliances.alliance0.alliance = alliance;\\n            alliances.alliance0.joinTime = uint96(block.timestamp);\\n        } else if (slot == 1) {\\n            alliances.alliance1.alliance = alliance;\\n            alliances.alliance1.joinTime = uint96(block.timestamp);\\n        } else if (slot == 2) {\\n            alliances.alliance2.alliance = alliance;\\n            alliances.alliance2.joinTime = uint96(block.timestamp);\\n        } else if (slot == 3) {\\n            alliances.alliance3.alliance = alliance;\\n            alliances.alliance3.joinTime = uint96(block.timestamp);\\n        }\\n        _allianceNonces[player][alliance] = nonce + 1;\\n\\n        emit AllianceLink(alliance, player, true);\\n\\n        _checkERC1155AndCallSafeTransfer(\\n            msg.sender,\\n            address(0),\\n            player,\\n            uint256(uint160(address(alliance))),\\n            1\\n        );\\n        emit TransferSingle(\\n            msg.sender,\\n            address(0),\\n            player,\\n            uint256(uint160(address(alliance))),\\n            1\\n        );\\n    }\\n\\n    bytes internal constant hexAlphabet = \\\"0123456789abcdef\\\";\\n    bytes internal constant decimalAlphabet = \\\"0123456789\\\";\\n\\n    function _writeUintAsHex(\\n        bytes memory data,\\n        uint256 endPos,\\n        uint256 num\\n    ) internal pure {\\n        while (num != 0) {\\n            data[endPos--] = bytes1(hexAlphabet[num % 16]);\\n            num /= 16;\\n        }\\n    }\\n\\n    function _writeUintAsDecimal(\\n        bytes memory data,\\n        uint256 endPos,\\n        uint256 num\\n    ) internal pure {\\n        while (num != 0) {\\n            data[endPos--] = bytes1(decimalAlphabet[num % 10]);\\n            num /= 10;\\n        }\\n    }\\n\\n    function _leaveAlliance(address player, IAlliance alliance) internal {\\n        Alliances storage alliances = _alliances[player];\\n\\n        IAlliance lastSlotAlliance;\\n        uint96 lastSlotJoinTime;\\n\\n        require(\\n            address(alliances.alliance0.alliance) != address(0),\\n            \\\"NOT_PART_OF_ANY_ALLIANCE\\\"\\n        );\\n\\n        if (address(alliances.alliance1.alliance) == address(0)) {\\n            lastSlotAlliance = alliances.alliance0.alliance;\\n            lastSlotJoinTime = alliances.alliance0.joinTime;\\n            alliances.alliance0.alliance = IAlliance(address(0));\\n            alliances.alliance0.joinTime = 0;\\n        } else {\\n            if (address(alliances.alliance2.alliance) == address(0)) {\\n                lastSlotAlliance = alliances.alliance1.alliance;\\n                lastSlotJoinTime = alliances.alliance1.joinTime;\\n                alliances.alliance1.alliance = IAlliance(address(0));\\n                alliances.alliance1.joinTime = 0;\\n            } else {\\n                if (address(alliances.alliance3.alliance) == address(0)) {\\n                    lastSlotAlliance = alliances.alliance2.alliance;\\n                    lastSlotJoinTime = alliances.alliance2.joinTime;\\n                    alliances.alliance2.alliance = IAlliance(address(0));\\n                    alliances.alliance2.joinTime = 0;\\n                } else {\\n                    lastSlotAlliance = alliances.alliance3.alliance;\\n                    lastSlotJoinTime = alliances.alliance3.joinTime;\\n                    alliances.alliance3.alliance = IAlliance(address(0));\\n                    alliances.alliance3.joinTime = 0;\\n                }\\n            }\\n        }\\n\\n        if (alliance != lastSlotAlliance) {\\n            if (alliances.alliance0.alliance == alliance) {\\n                alliances.alliance0.alliance = lastSlotAlliance;\\n                alliances.alliance0.joinTime = lastSlotJoinTime;\\n            } else if (alliances.alliance1.alliance == alliance) {\\n                alliances.alliance1.alliance = lastSlotAlliance;\\n                alliances.alliance1.joinTime = lastSlotJoinTime;\\n            } else if (alliances.alliance2.alliance == alliance) {\\n                alliances.alliance2.alliance = lastSlotAlliance;\\n                alliances.alliance2.joinTime = lastSlotJoinTime;\\n            } else {\\n                revert(\\\"NOT_PART_OF_THE_ALLIANCE\\\");\\n            }\\n        }\\n\\n        emit AllianceLink(alliance, player, false);\\n        emit TransferSingle(\\n            msg.sender,\\n            player,\\n            address(0),\\n            uint256(uint160(address(alliance))),\\n            1\\n        );\\n    }\\n\\n    function _msgSender() internal view returns (address) {\\n        return msg.sender; // TODO metatx\\n    }\\n\\n    // ---------------------------------------------------------------------\\n    // Support For ERC-1155\\n    // ---------------------------------------------------------------------\\n\\n    event TransferSingle(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 id,\\n        uint256 value\\n    );\\n\\n    function balanceOf(\\n        address owner,\\n        uint256 id\\n    ) external view returns (uint256 balance) {\\n        require(id == uint160(id), \\\"INVALID_ID\\\");\\n        (uint96 joinTime, ) = getAllianceData(\\n            owner,\\n            IAlliance(address(uint160(id)))\\n        );\\n        if (joinTime > 0) {\\n            return 1;\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    function balanceOfBatch(\\n        address[] calldata owners,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory balances) {\\n        balances = new uint256[](owners.length);\\n        for (uint256 i = 0; i < owners.length; i++) {\\n            require(ids[i] == uint160(ids[i]), \\\"INVALID_ID\\\");\\n            (uint96 joinTime, ) = getAllianceData(\\n                owners[i],\\n                IAlliance(address(uint160(ids[i])))\\n            );\\n            if (joinTime > 0) {\\n                balances[i] = 1;\\n            } else {\\n                balances[i] = 0;\\n            }\\n        }\\n    }\\n\\n    function isApprovedForAll(address, address) external pure returns (bool) {\\n        return false;\\n    }\\n\\n    function supportsInterface(\\n        bytes4 interfaceID\\n    ) external pure returns (bool) {\\n        return interfaceID == 0xd9b67a26 || interfaceID == 0x01ffc9a7;\\n    }\\n\\n    function _checkERC1155AndCallSafeTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 value\\n    ) internal returns (bool) {\\n        if (!Address.isContract(to)) {\\n            return true;\\n        }\\n\\n        return\\n            ERC1155TokenReceiver(to).onERC1155Received(\\n                operator,\\n                from,\\n                id,\\n                value,\\n                \\\"\\\"\\n            ) == 0xf23a6e61;\\n    }\\n}\\n\\ninterface ERC1155TokenReceiver {\\n    function onERC1155Received(\\n        address _operator,\\n        address _from,\\n        uint256 _id,\\n        uint256 _value,\\n        bytes calldata _data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xd411ad02158f1706333ca83f3fa516d7121a9115ad1a6ca52d994590813aea1e\",\"license\":\"AGPL-3.0\"},\"project/src/conquest_token/IFreePlayToken.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IFreePlayToken is IERC20 {\\n    function mintViaNativeToken(address to, uint256 amount) external payable;\\n\\n    function mintViaNativeTokenPlusSendExtraNativeTokens(\\n        address payable to,\\n        uint256 amount\\n    ) external payable;\\n\\n    function mintMultipleViaNativeTokenPlusSendExtraNativeTokens(\\n        address payable[] calldata tos,\\n        uint256[] calldata amounts,\\n        uint256[] calldata nativeTokenAmounts\\n    ) external payable;\\n\\n    function mint(address from, address to, uint256 amount) external;\\n\\n    function burn(address from, address to, uint256 amount) external;\\n\\n    struct BurnFrom {\\n        address from;\\n        uint256 amount;\\n    }\\n\\n    function burnMultiple(BurnFrom[] calldata list, address to) external;\\n}\\n\",\"keccak256\":\"0x7e57b760f948008ccd605d1f9ea3cb78ba93ff2f004aecc8ea1a0c62b44743f5\",\"license\":\"AGPL-3.0\"},\"project/src/interfaces/IAlliance.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity 0.8.9;\\n\\ninterface IAlliance {\\n    function requestToJoin(\\n        address player,\\n        bytes calldata data\\n    ) external returns (bool);\\n\\n    function playerHasLeft(address player) external;\\n}\\n\",\"keccak256\":\"0xa1aace8c912a6b3975a7ed398fec5101f69e0e2f4bc679797f28f8cc2583a142\",\"license\":\"AGPL-3.0\"},\"project/src/libraries/Extraction.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity 0.8.9;\\n\\n// TODO remove\\nimport \\\"hardhat/console.sol\\\";\\n\\nlibrary Extraction {\\n    function value(\\n        bytes32 data,\\n        uint8 leastSignificantBit,\\n        uint8 size\\n    ) internal pure returns (uint256) {\\n        return uint256((data >> leastSignificantBit)) % 2 ** size;\\n    }\\n\\n    function value8Mod(\\n        bytes32 data,\\n        uint8 leastSignificantBit,\\n        uint8 mod\\n    ) internal pure returns (uint8) {\\n        return uint8(uint256((data >> leastSignificantBit)) % mod);\\n    }\\n\\n    function value8(\\n        bytes32 data,\\n        uint8 leastSignificantBit\\n    ) internal pure returns (uint8) {\\n        return uint8(uint256((data >> leastSignificantBit)) % 2 ** 8);\\n    }\\n\\n    // 1+1+2+3+4+6+7+8+8+7+6+4+3+2+1+1 // aproximation of normal distribution with mean=7.5 and standard deviation=3 for 16 values\\n    bytes32 constant n_m7_5_sd3 =\\n        0x01223334444555555666666677777777888888889999999AAAAAABBBBCCCDDEF;\\n\\n    function normal8(\\n        bytes32 data,\\n        uint8 leastSignificantBit\\n    ) internal pure returns (uint8) {\\n        uint8 index = value8Mod(data, leastSignificantBit, 64);\\n        uint8 first = index / 2;\\n        uint8 second = index % 2;\\n        uint8 slot = uint8(n_m7_5_sd3[first]);\\n        if (second == 0) {\\n            return slot >> 4;\\n        } else {\\n            return slot % 16;\\n        }\\n    }\\n\\n    function normal16(\\n        bytes32 data,\\n        uint8 leastSignificantBit,\\n        bytes32 selection\\n    ) internal pure returns (uint16) {\\n        uint8 index = normal8(data, leastSignificantBit);\\n        return\\n            uint16(uint8(selection[index * 2])) * 2 ** 8 +\\n            uint16(uint8(selection[index * 2 + 1]));\\n    }\\n}\\n\",\"keccak256\":\"0xa085afbd9f80d718726b3ed26a6e2ff7e723ce491f17465358b599cbd9717803\",\"license\":\"AGPL-3.0\"},\"project/src/libraries/Math.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity 0.8.9;\\n\\nlibrary Math {\\n    function mul(\\n        uint256 a,\\n        uint256 b,\\n        string memory overflowError\\n    ) internal pure returns (uint256 c) {\\n        require(b == 0 || a == 0 || ((c = a * b) / b) == a, overflowError);\\n    }\\n\\n    function add(\\n        uint256 a,\\n        uint256 b,\\n        string memory overflowError\\n    ) internal pure returns (uint256 c) {\\n        require((c = a + b) >= a, overflowError);\\n    }\\n\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory underflowError\\n    ) internal pure returns (uint256 c) {\\n        require((c = a - b) <= a, underflowError);\\n    }\\n\\n    function mul18(\\n        uint256 a18,\\n        uint256 b18,\\n        string memory overflowError\\n    ) internal pure returns (uint256) {\\n        return mul(a18, b18, overflowError) / 10 ** 18;\\n    }\\n\\n    function div18(\\n        uint256 a18,\\n        uint256 b18,\\n        string memory overflowError\\n    ) internal pure returns (uint256) {\\n        return mul(a18, 10 ** 18, overflowError) / b18;\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a <= b ? a : b;\\n    }\\n\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    function smin(int256 a, int256 b) internal pure returns (int256) {\\n        return a <= b ? a : b;\\n    }\\n\\n    function smax(int256 a, int256 b) internal pure returns (int256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    function sqrt(uint256 a) internal pure returns (uint256 c) {\\n        uint256 tmp = (a + 1) / 2;\\n        c = a;\\n        while (tmp < c) {\\n            c = tmp;\\n            tmp = ((a / tmp) + tmp) / 2;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf8266c1a8854f2f13096ba7c0afa5e3adc13d8108360a76fa4b5d0e1b4307256\",\"license\":\"AGPL-3.0\"},\"project/src/outerspace/base/ImportingOuterSpaceConstants.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.9;\\n\\ncontract ImportingOuterSpaceConstants {\\n    uint256 internal constant DECIMALS_18 = 1e18;\\n    uint256 internal constant DECIMALS_14 = 1e14;\\n    uint32 internal constant ACTIVE_MASK = 2 ** 31;\\n    int256 internal constant UINT32_MAX = 2 ** 32 - 1;\\n    int256 internal constant UINT32_MIN = -2147483648;\\n}\\n\",\"keccak256\":\"0x5fd420aea8c58aff61257c446d9b3ed5febd2b8e9e2a750d444507b90d7b0a39\",\"license\":\"AGPL-3.0\"},\"project/src/outerspace/base/UsingOuterSpaceDataLayout.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.9;\\n\\nimport \\\"../types/ImportingOuterSpaceTypes.sol\\\";\\n\\ncontract UsingOuterSpaceDataLayout is ImportingOuterSpaceTypes {\\n    mapping(uint256 => Planet) internal _planets;\\n    mapping(uint256 => Fleet) internal _fleets;\\n\\n    mapping(address => uint256) internal _stakeReadyToBeWithdrawn;\\n\\n    mapping(address => mapping(address => bool)) internal _operators;\\n\\n    // Note: make it namespaces per user, currently it is possible (though unlikely) for 2 users to share a slot if one attack another and quickly send away spaceships\\n    mapping(uint256 => mapping(uint256 => InFlight)) internal _inFlight;\\n\\n    Discovered internal _discovered;\\n    // rewards\\n    mapping(address => uint256) internal _prevRewardIds;\\n    mapping(uint256 => uint256) internal _rewards;\\n    mapping(address => mapping(uint256 => bool)) internal _rewardsToWithdraw;\\n\\n    // This adds 20,000 gas to all resolution\\n    mapping(uint256 => mapping(address => mapping(uint256 => AccumulatedAttack)))\\n        internal _attacks;\\n\\n    mapping(address => uint256) internal _freeStakeReadyToBeWithdrawn;\\n    mapping(uint256 => uint256) internal _planetFlagged;\\n}\\n\",\"keccak256\":\"0x4b817bda0bd5569085da584ffba3f0880241f360c81e1729129dd286aca70d57\",\"license\":\"AGPL-3.0\"},\"project/src/outerspace/events/ImportingOuterSpaceEvents.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.9;\\n\\ninterface ImportingOuterSpaceEvents {\\n    event BlockTime(uint256 block, uint256 timestamp);\\n    event PlanetStake(\\n        address indexed acquirer,\\n        uint256 indexed location,\\n        uint32 numSpaceships,\\n        int40 travelingUpkeep,\\n        uint32 overflow,\\n        uint256 stake,\\n        bool freegift\\n    );\\n    event FleetSent(\\n        address indexed fleetSender,\\n        address indexed fleetOwner,\\n        uint256 indexed from,\\n        address operator,\\n        uint256 fleet,\\n        uint32 quantity,\\n        uint32 newNumSpaceships,\\n        int40 newTravelingUpkeep,\\n        uint32 newOverflow\\n    );\\n\\n    event FleetRevealed(\\n        uint256 indexed fleetId,\\n        uint256 indexed from,\\n        uint256 indexed to,\\n        uint256 arrivalTimeWanted,\\n        bool gift,\\n        address specific,\\n        bytes32 secret,\\n        address fleetSender,\\n        address operator\\n    );\\n\\n    struct ArrivalData {\\n        uint32 newNumspaceships;\\n        int40 newTravelingUpkeep;\\n        uint32 newOverflow;\\n        uint32 numSpaceshipsAtArrival;\\n        uint32 taxLoss;\\n        uint32 fleetLoss;\\n        uint32 planetLoss;\\n        uint32 inFlightFleetLoss;\\n        uint32 inFlightPlanetLoss;\\n        uint32 accumulatedDefenseAdded;\\n        uint32 accumulatedAttackAdded;\\n    }\\n\\n    event FleetArrived(\\n        uint256 indexed fleet,\\n        address indexed fleetOwner,\\n        address indexed destinationOwner,\\n        uint256 destination,\\n        bool gift,\\n        bool won,\\n        ArrivalData data\\n    );\\n\\n    event TravelingUpkeepRefund(\\n        uint256 indexed origin,\\n        uint256 indexed fleet,\\n        uint32 newNumspaceships,\\n        int40 newTravelingUpkeep,\\n        uint32 newOverflow\\n    );\\n\\n    event PlanetTransfer(\\n        address indexed previousOwner,\\n        address indexed newOwner,\\n        uint256 indexed location,\\n        uint32 newNumspaceships,\\n        int40 newTravelingUpkeep,\\n        uint32 newOverflow\\n    );\\n\\n    event PlanetReset(uint256 indexed location);\\n\\n    event PlanetExit(address indexed owner, uint256 indexed location);\\n\\n    event ExitComplete(\\n        address indexed owner,\\n        uint256 indexed location,\\n        uint256 stake\\n    );\\n\\n    event RewardSetup(\\n        uint256 indexed location,\\n        address indexed giver,\\n        uint256 rewardId\\n    );\\n    event RewardToWithdraw(\\n        address indexed owner,\\n        uint256 indexed location,\\n        uint256 indexed rewardId\\n    );\\n\\n    event StakeToWithdraw(\\n        address indexed owner,\\n        uint256 newStake,\\n        bool freegift\\n    );\\n\\n    event Initialized(\\n        bytes32 genesis,\\n        uint256 resolveWindow,\\n        uint256 timePerDistance,\\n        uint256 exitDuration,\\n        uint32 acquireNumSpaceships,\\n        uint32 productionSpeedUp,\\n        uint256 frontrunningDelay,\\n        uint256 productionCapAsDuration,\\n        uint256 upkeepProductionDecreaseRatePer10000th,\\n        uint256 fleetSizeFactor6,\\n        uint32 initialSpaceExpansion,\\n        uint32 expansionDelta,\\n        uint256 giftTaxPer10000\\n    );\\n\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 indexed location\\n    );\\n\\n    event GeneratorChanged(address newGenerator);\\n    event GeneratorAdminChanged(address newGeneratorAdmin);\\n}\\n\",\"keccak256\":\"0x22893e578bea12f7a69d276f3a6330919cd1534a07dcf330613c3641ba844fad\",\"license\":\"AGPL-3.0\"},\"project/src/outerspace/facets/OuterSpaceFacetBase.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.9;\\n\\nimport \\\"../types/ImportingOuterSpaceTypes.sol\\\";\\nimport \\\"../base/ImportingOuterSpaceConstants.sol\\\";\\nimport \\\"../events/ImportingOuterSpaceEvents.sol\\\";\\nimport \\\"../base/UsingOuterSpaceDataLayout.sol\\\";\\n\\nimport \\\"../../libraries/Extraction.sol\\\";\\nimport \\\"../../libraries/Math.sol\\\";\\n\\nimport \\\"../../interfaces/IAlliance.sol\\\";\\nimport \\\"../../alliances/AllianceRegistry.sol\\\";\\n\\nimport \\\"../../conquest_token/IFreePlayToken.sol\\\";\\n\\ninterface StakingToken is IERC20 {\\n    function mint(address to, uint256 amount) external payable;\\n}\\n\\ncontract OuterSpaceFacetBase is\\n    ImportingOuterSpaceTypes,\\n    ImportingOuterSpaceConstants,\\n    ImportingOuterSpaceEvents,\\n    UsingOuterSpaceDataLayout\\n{\\n    using Extraction for bytes32;\\n\\n    StakingToken internal immutable _stakingToken;\\n    IFreePlayToken internal immutable _freeStakingToken;\\n    AllianceRegistry internal immutable _allianceRegistry;\\n\\n    bytes32 internal immutable _genesis;\\n    uint256 internal immutable _resolveWindow;\\n    uint256 internal immutable _timePerDistance;\\n    uint256 internal immutable _exitDuration;\\n    uint32 internal immutable _acquireNumSpaceships; // TODO use uint256\\n    uint32 internal immutable _productionSpeedUp; // TODO use uint256\\n    uint256 internal immutable _frontrunningDelay;\\n    uint256 internal immutable _productionCapAsDuration;\\n    uint256 internal immutable _upkeepProductionDecreaseRatePer10000th;\\n    uint256 internal immutable _fleetSizeFactor6;\\n    uint32 internal immutable _initialSpaceExpansion; // = 16;\\n    uint32 internal immutable _expansionDelta; // = 8;  // TODO use uint256\\n    uint256 internal immutable _giftTaxPer10000; // = 2500;\\n    // // 4,5,5,10,10,15,15, 20, 20, 30,30,40,40,80,80,100\\n    // bytes32 constant stakeRange = 0x000400050005000A000A000F000F00140014001E001E00280028005000500064;\\n    // 6, 8, 10, 12, 14, 16, 18, 20, 20, 22, 24, 32, 40, 48, 56, 72\\n    // bytes32 internal constant stakeRange = 0x00060008000A000C000E00100012001400140016001800200028003000380048;\\n    bytes32 internal immutable _stakeRange;\\n    uint256 internal immutable _stakeMultiplier10000th;\\n    uint256 internal immutable _bootstrapSessionEndTime;\\n    uint256 internal immutable _infinityStartTime;\\n\\n    struct Config {\\n        StakingToken stakingToken;\\n        IFreePlayToken freeStakingToken;\\n        AllianceRegistry allianceRegistry;\\n        bytes32 genesis;\\n        uint256 resolveWindow;\\n        uint256 timePerDistance;\\n        uint256 exitDuration;\\n        uint32 acquireNumSpaceships;\\n        uint32 productionSpeedUp;\\n        uint256 frontrunningDelay;\\n        uint256 productionCapAsDuration;\\n        uint256 upkeepProductionDecreaseRatePer10000th;\\n        uint256 fleetSizeFactor6;\\n        uint32 initialSpaceExpansion;\\n        uint32 expansionDelta;\\n        uint256 giftTaxPer10000;\\n        bytes32 stakeRange;\\n        uint256 stakeMultiplier10000th;\\n        uint256 bootstrapSessionEndTime;\\n        uint256 infinityStartTime;\\n    }\\n\\n    constructor(Config memory config) {\\n        uint32 t = uint32(config.timePerDistance) / 4; // the coordinates space is 4 times bigger\\n        require(\\n            t * 4 == config.timePerDistance,\\n            \\\"TIME_PER_DIST_NOT_DIVISIBLE_4\\\"\\n        );\\n\\n        _stakingToken = config.stakingToken;\\n        _freeStakingToken = config.freeStakingToken;\\n        _allianceRegistry = config.allianceRegistry;\\n\\n        _genesis = config.genesis;\\n        _resolveWindow = config.resolveWindow;\\n        _timePerDistance = t;\\n        _exitDuration = config.exitDuration;\\n        _acquireNumSpaceships = config.acquireNumSpaceships;\\n        _productionSpeedUp = config.productionSpeedUp;\\n        _frontrunningDelay = config.frontrunningDelay;\\n        _productionCapAsDuration = config.productionCapAsDuration;\\n        _upkeepProductionDecreaseRatePer10000th = config\\n            .upkeepProductionDecreaseRatePer10000th;\\n        _fleetSizeFactor6 = config.fleetSizeFactor6;\\n        _initialSpaceExpansion = config.initialSpaceExpansion;\\n        _expansionDelta = config.expansionDelta;\\n        _giftTaxPer10000 = config.giftTaxPer10000;\\n        _stakeRange = config.stakeRange;\\n        _stakeMultiplier10000th = config.stakeMultiplier10000th;\\n        _bootstrapSessionEndTime = config.bootstrapSessionEndTime;\\n        _infinityStartTime = config.infinityStartTime;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------------------------------\\n    // PLANET STATE\\n    // ---------------------------------------------------------------------------------------------------------------\\n\\n    struct PlanetUpdateState {\\n        uint256 location;\\n        uint40 lastUpdated;\\n        bool active; // modified\\n        uint32 numSpaceships; // modified\\n        int40 travelingUpkeep; // modified\\n        uint40 exitStartTime;\\n        uint40 newExitStartTime; // modified\\n        uint32 overflow; // modified\\n        address owner;\\n        address newOwner; // modified\\n        bytes32 data;\\n        uint24 futureExtraProduction;\\n    }\\n\\n    function _createPlanetUpdateState(\\n        Planet memory planet,\\n        uint256 location\\n    ) internal view returns (PlanetUpdateState memory planetUpdate) {\\n        (bool active, uint32 currentNumSpaceships) = _activeNumSpaceships(\\n            planet.numSpaceships\\n        );\\n        planetUpdate.location = location;\\n        planetUpdate.lastUpdated = planet.lastUpdated;\\n        planetUpdate.active = active;\\n        planetUpdate.numSpaceships = currentNumSpaceships;\\n        planetUpdate.travelingUpkeep = planet.travelingUpkeep;\\n        planetUpdate.exitStartTime = planet.exitStartTime;\\n        planetUpdate.newExitStartTime = planet.exitStartTime;\\n        planetUpdate.overflow = planet.overflow;\\n        planetUpdate.owner = planet.owner;\\n        planetUpdate.newOwner = planet.owner;\\n        planetUpdate.data = _planetData(location);\\n    }\\n\\n    // solhint-disable-next-line code-complexity\\n    function _computePlanetUpdateForTimeElapsed(\\n        PlanetUpdateState memory planetUpdate\\n    ) internal view {\\n        if (planetUpdate.exitStartTime != 0) {\\n            if (_hasJustExited(planetUpdate.exitStartTime)) {\\n                planetUpdate.newExitStartTime = 0;\\n                planetUpdate.numSpaceships = 0;\\n                planetUpdate.travelingUpkeep = 0;\\n                planetUpdate.newOwner = address(0);\\n                planetUpdate.overflow = 0;\\n                planetUpdate.active = false; // event is emitted at the endof each write function\\n                // lastUpdated is set at the end directly on storage\\n                return;\\n            }\\n        }\\n\\n        uint256 timePassed = block.timestamp - planetUpdate.lastUpdated;\\n        uint16 production = _production(planetUpdate.data);\\n        uint256 amountProducedTheWholeTime = (timePassed *\\n            uint256(_productionSpeedUp) *\\n            uint256(production)) / 1 hours;\\n\\n        uint256 newNumSpaceships = planetUpdate.numSpaceships;\\n        uint256 extraUpkeepPaid = 0;\\n        if (_productionCapAsDuration > 0) {\\n            uint256 capWhenActive = _capWhenActive(production);\\n            uint256 cap = planetUpdate.active ? capWhenActive : 0;\\n\\n            if (newNumSpaceships > cap) {\\n                uint256 decreaseRate = 1800;\\n                if (planetUpdate.overflow > 0) {\\n                    decreaseRate =\\n                        (uint256(planetUpdate.overflow) * 1800) / capWhenActive;\\n                    if (decreaseRate < 1800) {\\n                        decreaseRate = 1800;\\n                    }\\n                }\\n\\n                uint256 decrease = (timePassed *\\n                    uint256(_productionSpeedUp) *\\n                    decreaseRate) / 1 hours;\\n                if (decrease == 0) {\\n                    // NOTE: To ensure a player cannot simply ping the planet continuously to avoid the decrease\\n                    decrease = 1;\\n                }\\n                if (decrease > newNumSpaceships - cap) {\\n                    decrease = newNumSpaceships - cap;\\n                }\\n\\n                if (planetUpdate.active) {\\n                    extraUpkeepPaid = decrease;\\n                }\\n                newNumSpaceships -= decrease;\\n            } else {\\n                if (planetUpdate.active) {\\n                    uint256 increase = amountProducedTheWholeTime;\\n                    if (planetUpdate.travelingUpkeep > 0) {\\n                        uint256 timeBeforeUpkeepBackToZero = (uint256(\\n                            uint40(planetUpdate.travelingUpkeep)\\n                        ) * 1 hours) /\\n                            ((uint256(_productionSpeedUp) *\\n                                uint256(production) *\\n                                _upkeepProductionDecreaseRatePer10000th) /\\n                                10000); // 10,000 should be extracted as to not reach div by zero (like \\\"1 hours\\\")\\n                        if (timeBeforeUpkeepBackToZero >= timePassed) {\\n                            extraUpkeepPaid = increase;\\n                        } else {\\n                            extraUpkeepPaid =\\n                                (timeBeforeUpkeepBackToZero *\\n                                    uint256(_productionSpeedUp) *\\n                                    uint256(production)) / 1 hours;\\n                            if (extraUpkeepPaid > increase) {\\n                                extraUpkeepPaid = increase; // TODO remove ? should not be possible\\n                            }\\n                        }\\n                        increase -= extraUpkeepPaid;\\n                    }\\n\\n                    uint256 maxIncrease = cap - newNumSpaceships;\\n                    if (increase > maxIncrease) {\\n                        extraUpkeepPaid += increase - maxIncrease;\\n                        increase = maxIncrease;\\n                    }\\n                    newNumSpaceships += increase;\\n                    // solhint-disable-next-line no-empty-blocks\\n                } else {\\n                    // not effect currently, when inactive, cap == 0, meaning zero spaceship here\\n                    // NOTE: we could do the following assuming we act on upkeepRepaid when inactive, we do not do that currently\\n                    //  extraUpkeepPaid = amountProducedTheWholeTime - upkeepRepaid;\\n                }\\n            }\\n\\n            if (planetUpdate.active) {\\n                uint256 upkeepRepaid = ((amountProducedTheWholeTime *\\n                    _upkeepProductionDecreaseRatePer10000th) / 10000) +\\n                    extraUpkeepPaid;\\n                int256 newTravelingUpkeep = int256(\\n                    planetUpdate.travelingUpkeep\\n                ) - int40(uint40(upkeepRepaid));\\n\\n                if (newTravelingUpkeep < -int256(cap)) {\\n                    newTravelingUpkeep = -int256(cap);\\n                }\\n                planetUpdate.travelingUpkeep = int40(newTravelingUpkeep);\\n            }\\n        } else {\\n            // TODO We are not using this branch, and in that branch there is no upkeep or overflow to consider\\n            if (planetUpdate.active) {\\n                newNumSpaceships += amountProducedTheWholeTime;\\n            } else {\\n                // NOTE no need to overflow here  as there is no production cap, so no incentive to regroup spaceships\\n                uint256 decrease = (timePassed *\\n                    uint256(_productionSpeedUp) *\\n                    1800) / 1 hours;\\n                if (decrease > newNumSpaceships) {\\n                    decrease = newNumSpaceships;\\n                    newNumSpaceships = 0;\\n                } else {\\n                    newNumSpaceships -= decrease;\\n                }\\n            }\\n        }\\n\\n        if (newNumSpaceships >= ACTIVE_MASK) {\\n            newNumSpaceships = ACTIVE_MASK - 1;\\n        }\\n        planetUpdate.numSpaceships = uint32(newNumSpaceships);\\n\\n        if (!planetUpdate.active && planetUpdate.numSpaceships == 0) {\\n            planetUpdate.newOwner = address(0);\\n        }\\n    }\\n\\n    function _setPlanet(\\n        Planet storage planet,\\n        PlanetUpdateState memory planetUpdate,\\n        bool exitInterupted\\n    ) internal {\\n        if (\\n            planetUpdate.exitStartTime > 0 && planetUpdate.newExitStartTime == 0\\n        ) {\\n            // NOTE: planetUpdate.newExitStartTime is only set to zero when exit is actually complete (not interupted)\\n            //  interuption is handled by exitInterupted\\n            // exit has completed, newExitStartTime is not set to zero for interuption,\\n            // interuption is taken care below (owner changes)\\n            _handleExitComplete(planetUpdate);\\n        }\\n        if (planetUpdate.owner != planetUpdate.newOwner) {\\n            planet.owner = planetUpdate.newOwner;\\n            if (planetUpdate.newOwner != address(0)) {\\n                planet.ownershipStartTime = uint40(block.timestamp);\\n            } else {\\n                planet.ownershipStartTime = 0;\\n            }\\n            emit Transfer(\\n                planetUpdate.owner,\\n                planetUpdate.newOwner,\\n                planetUpdate.location\\n            );\\n        }\\n\\n        if (exitInterupted) {\\n            // if (planetUpdate.newExitStartTime == 0 && planetUpdate.exitStartTime > 0) {\\n            // exit interupted // TODO event ?\\n            // }\\n            planet.exitStartTime = 0;\\n        } else if (\\n            planetUpdate.newExitStartTime != planetUpdate.exitStartTime\\n        ) {\\n            planet.exitStartTime = planetUpdate.newExitStartTime;\\n        }\\n\\n        planet.numSpaceships = _setActiveNumSpaceships(\\n            planetUpdate.active,\\n            planetUpdate.numSpaceships\\n        );\\n        planet.travelingUpkeep = planetUpdate.travelingUpkeep;\\n\\n        planet.overflow = planetUpdate.overflow;\\n        planet.lastUpdated = uint40(block.timestamp);\\n    }\\n\\n    // ---------------------------------------------------------------------------------------------------------------\\n    // STAKING / PRODUCTION CAPTURE\\n    // ---------------------------------------------------------------------------------------------------------------\\n\\n    function _acquire(\\n        address player,\\n        uint256 stake,\\n        uint256 location,\\n        bool freegift\\n    ) internal whenNotPaused {\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Initialise State Update\\n        // -----------------------------------------------------------------------------------------------------------\\n        Planet storage planet = _getPlanet(location);\\n        PlanetUpdateState memory planetUpdate = _createPlanetUpdateState(\\n            planet,\\n            location\\n        );\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // check requirements\\n        // -----------------------------------------------------------------------------------------------------------\\n        require(\\n            stake == uint256(_stake(planetUpdate.data)) * (DECIMALS_14),\\n            \\\"INVALID_STAKE_AMOUNT\\\"\\n        );\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Compute Basic Planet Updates\\n        // -----------------------------------------------------------------------------------------------------------\\n        _computePlanetUpdateForTimeElapsed(planetUpdate);\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Staking logic...\\n        // -----------------------------------------------------------------------------------------------------------\\n        _computePlanetUpdateForStaking(player, planetUpdate);\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Write New State\\n        // -----------------------------------------------------------------------------------------------------------\\n        _setPlanet(planet, planetUpdate, false);\\n        // _setAccountFromPlanetUpdate(planetUpdate);\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Update Space Discovery\\n        // -----------------------------------------------------------------------------------------------------------\\n        _setDiscoveryAfterStaking(location);\\n\\n        if (freegift) {\\n            _planetFlagged[location] = block.timestamp;\\n        } else {\\n            _planetFlagged[location] = 0; // staked with normal tokens\\n        }\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Emit Event\\n        // -----------------------------------------------------------------------------------------------------------\\n        emit BlockTime(block.number, block.timestamp);\\n        emit PlanetStake(\\n            player,\\n            location,\\n            planetUpdate.numSpaceships,\\n            planetUpdate.travelingUpkeep,\\n            planetUpdate.overflow,\\n            stake,\\n            freegift\\n        );\\n        _notifyGeneratorAdd(planetUpdate.newOwner, stake);\\n    }\\n\\n    function _computePlanetUpdateForStaking(\\n        address player,\\n        PlanetUpdateState memory planetUpdate\\n    ) internal view {\\n        require(!planetUpdate.active, \\\"STILL_ACTIVE\\\");\\n\\n        uint32 defense;\\n        // NOTE : natives are back automatically once spaceships reaches zero (here we know we are not active)\\n        // TODO consider making natives come back over time => would need to compute the time numSpaceship became zero\\n        if (planetUpdate.numSpaceships == 0) {\\n            defense = _natives(planetUpdate.data);\\n        } else {\\n            // Do not allow staking over occupied planets, they are going to zero at some point though\\n            require(planetUpdate.owner == player, \\\"OCCUPIED\\\");\\n        }\\n\\n        uint16 production = _production(planetUpdate.data);\\n        uint32 cap = uint32(_capWhenActive(production));\\n\\n        // We need to  ensure a player staking on a planet it previously exited work here\\n        planetUpdate.newOwner = player;\\n        if (defense != 0) {\\n            (uint32 attackerLoss, ) = _computeFight(\\n                uint256(_acquireNumSpaceships),\\n                defense,\\n                10000,\\n                _defense(planetUpdate.data)\\n            );\\n            // attacker alwasy win as defense (and stats.native) is restricted to 3500\\n            // (attackerLoss: 0, defenderLoss: 0) would mean defense was zero\\n            require(attackerLoss < _acquireNumSpaceships, \\\"FAILED_CAPTURED\\\");\\n            planetUpdate.numSpaceships = _acquireNumSpaceships - attackerLoss;\\n\\n            // NOTE cannot be overflow here as staking provide a number of spaceships below that\\n            planetUpdate.overflow = 0;\\n        } else {\\n            planetUpdate.numSpaceships += _acquireNumSpaceships;\\n            if (_productionCapAsDuration > 0) {\\n                if (planetUpdate.numSpaceships > cap) {\\n                    planetUpdate.overflow = planetUpdate.numSpaceships - cap;\\n                } else {\\n                    planetUpdate.overflow = 0;\\n                }\\n            }\\n        }\\n\\n        // NOTE when staking on a planet, we set an allowance for traveling upkeep\\n        planetUpdate.travelingUpkeep =\\n            -int32(\\n                uint32(\\n                    (uint256(cap) * _upkeepProductionDecreaseRatePer10000th) /\\n                        10000\\n                )\\n            ) - int32(planetUpdate.numSpaceships);\\n        planetUpdate.active = true;\\n    }\\n\\n    // solhint-disable-next-line code-complexity\\n    function _setDiscoveryAfterStaking(uint256 location) internal {\\n        Discovered memory discovered = _discovered;\\n\\n        int256 x = int256(\\n            int128(int256(location & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\\n        );\\n        int256 y = int256(int128(int256(location >> 128)));\\n\\n        bool changes = false;\\n        if (x < 0) {\\n            require(\\n                -x <= int256(uint256(discovered.minX)),\\n                \\\"NOT_REACHABLE_YET_MINX\\\"\\n            );\\n            x = -x + int32(_expansionDelta);\\n            if (x > UINT32_MAX) {\\n                x = UINT32_MAX;\\n            }\\n            if (int256(uint256(discovered.minX)) < x) {\\n                discovered.minX = uint32(uint256(x));\\n                changes = true;\\n            }\\n        } else {\\n            require(\\n                x <= int256(uint256(discovered.maxX)),\\n                \\\"NOT_REACHABLE_YET_MAXX\\\"\\n            );\\n            x = x + int32(_expansionDelta);\\n            if (x > UINT32_MAX) {\\n                x = UINT32_MAX;\\n            }\\n            if (discovered.maxX < uint32(uint256(x))) {\\n                discovered.maxX = uint32(uint256(x));\\n                changes = true;\\n            }\\n        }\\n\\n        if (y < 0) {\\n            require(\\n                -y <= int256(uint256(discovered.minY)),\\n                \\\"NOT_REACHABLE_YET_MINY\\\"\\n            );\\n            y = -y + int32(_expansionDelta);\\n            if (y > UINT32_MAX) {\\n                y = UINT32_MAX;\\n            }\\n            if (int256(uint256(discovered.minY)) < y) {\\n                discovered.minY = uint32(uint256(y));\\n                changes = true;\\n            }\\n        } else {\\n            require(\\n                y <= int256(uint256(discovered.maxY)),\\n                \\\"NOT_REACHABLE_YET_MAXY\\\"\\n            );\\n            y = y + int32(_expansionDelta);\\n            if (y > UINT32_MAX) {\\n                y = UINT32_MAX;\\n            }\\n            if (int256(uint256(discovered.maxY)) < y) {\\n                discovered.maxY = uint32(uint256(y));\\n                changes = true;\\n            }\\n        }\\n        if (changes) {\\n            _discovered = discovered;\\n        }\\n    }\\n\\n    // ---------------------------------------------------------------------------------------------------------------\\n    // EXITS / WITHDRAWALS\\n    // ---------------------------------------------------------------------------------------------------------------\\n\\n    function _handleExitComplete(\\n        PlanetUpdateState memory planetUpdate\\n    ) internal {\\n        uint256 stake = _completeExit(\\n            planetUpdate.owner,\\n            planetUpdate.location,\\n            planetUpdate.data\\n        );\\n\\n        // Note we could Transfer to zero and Transfer from zero ?\\n\\n        // optional so we can use it in the batch withdraw,\\n\\n        uint256 flagTime = _planetFlagged[planetUpdate.location];\\n        if (flagTime > 0) {\\n            // TODO reactivate once we siwtch to a fixed FreePlayToken\\n            // if (planetUpdate.exitStartTime >= flagTime + (6 days / _productionSpeedUp)) {\\n            //     _freeStakingToken.burn(address(this), address(this), stake);\\n            //     uint256 newStake = _stakeReadyToBeWithdrawn[planetUpdate.owner] + stake;\\n            //     _stakeReadyToBeWithdrawn[planetUpdate.owner] = newStake;\\n            //     emit StakeToWithdraw(planetUpdate.owner, newStake, false);\\n            // } else {\\n            uint256 newStake = _freeStakeReadyToBeWithdrawn[\\n                planetUpdate.owner\\n            ] + stake;\\n            _freeStakeReadyToBeWithdrawn[planetUpdate.owner] = newStake;\\n            emit StakeToWithdraw(planetUpdate.owner, newStake, true);\\n            // }\\n        } else {\\n            uint256 newStake = _stakeReadyToBeWithdrawn[planetUpdate.owner] +\\n                stake;\\n            _stakeReadyToBeWithdrawn[planetUpdate.owner] = newStake;\\n            emit StakeToWithdraw(planetUpdate.owner, newStake, false);\\n        }\\n    }\\n\\n    function _completeExit(\\n        address owner,\\n        uint256 location,\\n        bytes32 data\\n    ) internal returns (uint256 stake) {\\n        stake = uint256(_stake(data)) * (DECIMALS_14);\\n        emit BlockTime(block.number, block.timestamp);\\n        emit ExitComplete(owner, location, stake);\\n\\n        // --------------------------------------------------------\\n        // Extra Reward was added\\n        // --------------------------------------------------------\\n        uint256 rewardId = _rewards[location];\\n        if (rewardId != 0) {\\n            // rewardId would contains the package. maybe this could be handled by an external contract\\n            _rewardsToWithdraw[owner][rewardId] = true;\\n            _rewards[location] = 0; // reset\\n            // if you had reward to a planet in he process of exiting,\\n            // you are adding the reward to the player exiting unless _setPlanetAfterExit is called first\\n            emit RewardToWithdraw(owner, location, rewardId);\\n        }\\n        // --------------------------------------------------------\\n    }\\n\\n    function _unsafe_exit_for(address owner, uint256 location) internal {\\n        Planet storage planet = _getPlanet(location);\\n        (bool active, ) = _activeNumSpaceships(planet.numSpaceships);\\n        require(active, \\\"NOT_ACTIVE\\\");\\n        require(owner == planet.owner, \\\"NOT_OWNER\\\");\\n        require(planet.exitStartTime == 0, \\\"EXITING_ALREADY\\\");\\n\\n        planet.exitStartTime = uint40(block.timestamp);\\n        emit BlockTime(block.number, block.timestamp);\\n        emit PlanetExit(owner, location);\\n\\n        // stake is removed as soon as we start exist\\n        // If the exit is interupted, it is given to the player interupting\\n        _notifyGeneratorRemove(\\n            owner,\\n            uint256(_stake(_planetData(location))) * (DECIMALS_14)\\n        );\\n    }\\n\\n    function _fetchAndWithdrawFor(\\n        address owner,\\n        uint256[] calldata locations\\n    ) internal {\\n        uint256 addedStake = 0;\\n        uint256 freeAddedStake = 0;\\n        for (uint256 i = 0; i < locations.length; i++) {\\n            Planet storage planet = _getPlanet(locations[i]);\\n            if (_hasJustExited(planet.exitStartTime)) {\\n                require(owner == planet.owner, \\\"NOT_OWNER\\\");\\n                emit Transfer(owner, address(0), locations[i]);\\n\\n                uint256 flagTime = _planetFlagged[locations[i]];\\n                if (flagTime > 0) {\\n                    // TODO reactivate once we siwtch to a fixed FreePlayToken\\n                    // if (planet.exitStartTime >= flagTime + (6 days / _productionSpeedUp)) {\\n                    //     uint256 extra = _completeExit(planet.owner, locations[i], _planetData(locations[i]));\\n                    //     addedStake += extra;\\n                    //     _freeStakingToken.burn(address(this), address(this), extra);\\n                    // } else {\\n                    freeAddedStake += _completeExit(\\n                        planet.owner,\\n                        locations[i],\\n                        _planetData(locations[i])\\n                    );\\n                    // }\\n                } else {\\n                    addedStake += _completeExit(\\n                        planet.owner,\\n                        locations[i],\\n                        _planetData(locations[i])\\n                    );\\n                }\\n\\n                planet.owner = address(0);\\n                planet.ownershipStartTime = 0;\\n                planet.exitStartTime = 0;\\n                planet.numSpaceships = 0;\\n                planet.overflow = 0;\\n                planet.travelingUpkeep = 0;\\n                planet.lastUpdated = uint40(block.timestamp);\\n            }\\n        }\\n        uint256 newStake = _stakeReadyToBeWithdrawn[owner] + addedStake;\\n        _unsafe_withdrawAll(owner, newStake);\\n\\n        uint256 newFreeStake = _freeStakeReadyToBeWithdrawn[owner] +\\n            freeAddedStake;\\n        _free_unsafe_withdrawAll(owner, newFreeStake);\\n    }\\n\\n    function _unsafe_withdrawAll(address owner, uint256 amount) internal {\\n        _stakeReadyToBeWithdrawn[owner] = 0;\\n        emit StakeToWithdraw(owner, amount, false);\\n        require(_stakingToken.transfer(owner, amount), \\\"FAILED_TRANSFER\\\");\\n        emit StakeToWithdraw(owner, 0, false);\\n    }\\n\\n    function _free_unsafe_withdrawAll(address owner, uint256 amount) internal {\\n        _freeStakeReadyToBeWithdrawn[owner] = 0;\\n        emit StakeToWithdraw(owner, amount, true);\\n        require(_freeStakingToken.transfer(owner, amount), \\\"FAILED_TRANSFER\\\");\\n        emit StakeToWithdraw(owner, 0, true);\\n    }\\n\\n    function _hasJustExited(uint40 exitTime) internal view returns (bool) {\\n        if (exitTime == 0) {\\n            return false;\\n        }\\n        uint256 timestamp = block.timestamp;\\n        if (\\n            _bootstrapSessionEndTime > 0 &&\\n            timestamp >= _bootstrapSessionEndTime &&\\n            exitTime < _infinityStartTime\\n        ) {\\n            return true;\\n        }\\n\\n        return timestamp > exitTime + _exitDuration;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------------------------------\\n    // REWARDS\\n    // ---------------------------------------------------------------------------------------------------------------\\n\\n    function _addReward(uint256 location, address sponsor) internal {\\n        uint256 rewardId = _rewards[location];\\n        require(rewardId == 0, \\\"REWARD_ALREADY_AT_THIS_LOCATION\\\");\\n        // TODO ?\\n        // Planet storage planet = _getPlanet(location);\\n        // require(planet.lastUpdated == 0, \\\"PLANET_ALREADY_COLONIZED\\\");\\n        rewardId = ++_prevRewardIds[sponsor];\\n        _rewards[location] = (uint256(uint160(sponsor)) << 96) + rewardId;\\n        emit RewardSetup(location, sponsor, rewardId);\\n    }\\n\\n    // ---------------------------------------------------------------------------------------------------------------\\n    // FLEET SENDING\\n    // ---------------------------------------------------------------------------------------------------------------\\n\\n    function _unsafe_sendFor(\\n        uint256 fleetId,\\n        address operator,\\n        FleetLaunch memory launch\\n    ) internal whenNotPaused {\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Initialise State Update\\n        // -----------------------------------------------------------------------------------------------------------\\n        Planet storage planet = _getPlanet(launch.from);\\n        PlanetUpdateState memory planetUpdate = _createPlanetUpdateState(\\n            planet,\\n            launch.from\\n        );\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // check requirements\\n        // -----------------------------------------------------------------------------------------------------------\\n\\n        require(launch.quantity < 2 ** 30, \\\"TOO_MANY_SPACESHIPS\\\"); // only 2^30 because the first 2 bits = resolution\\n        require(launch.quantity > 0, \\\"NO_SPACESHIPS\\\");\\n        require(planet.exitStartTime == 0, \\\"PLANET_EXIT\\\");\\n        require(launch.fleetSender == planet.owner, \\\"NOT_OWNER\\\");\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Compute Basic Planet Updates\\n        // -----------------------------------------------------------------------------------------------------------\\n        _computePlanetUpdateForTimeElapsed(planetUpdate);\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Requirements post Planet Updates\\n        // -----------------------------------------------------------------------------------------------------------\\n\\n        require(\\n            planetUpdate.numSpaceships >= launch.quantity,\\n            \\\"SPACESHIPS_NOT_ENOUGH\\\"\\n        );\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Sending logic...\\n        // -----------------------------------------------------------------------------------------------------------\\n        _computePlanetUpdateForFleetLaunch(planetUpdate, launch.quantity);\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Write New State\\n        // -----------------------------------------------------------------------------------------------------------\\n        _setPlanet(planet, planetUpdate, false);\\n        // _setAccountFromPlanetUpdate(planetUpdate);\\n\\n        _setFleetFlyingSlot(launch.from, launch.quantity);\\n\\n        require(_fleets[fleetId].quantity == 0, \\\"FLEET_EXISTS\\\");\\n        _fleets[fleetId] = Fleet({\\n            launchTime: uint40(block.timestamp),\\n            owner: launch.fleetOwner,\\n            quantity: launch.quantity,\\n            futureExtraProduction: planetUpdate.futureExtraProduction,\\n            defender: address(0),\\n            arrivalTime: 0,\\n            defenderLoss: 0,\\n            victory: false,\\n            planetActive: false\\n        });\\n\\n        emit BlockTime(block.number, block.timestamp);\\n        emit FleetSent(\\n            launch.fleetSender,\\n            launch.fleetOwner,\\n            launch.from,\\n            operator,\\n            fleetId,\\n            launch.quantity,\\n            planetUpdate.numSpaceships,\\n            planetUpdate.travelingUpkeep,\\n            planetUpdate.overflow\\n        );\\n    }\\n\\n    function _computePlanetUpdateForFleetLaunch(\\n        PlanetUpdateState memory planetUpdate,\\n        uint32 quantity\\n    ) internal view {\\n        planetUpdate.numSpaceships -= quantity;\\n        if (_productionCapAsDuration > 0) {\\n            if (planetUpdate.active) {\\n                // NOTE we do not update travelingUpkeep on Inactive planets\\n                //  these get reset on staking\\n\\n                uint16 production = _production(planetUpdate.data);\\n                uint256 cap = _capWhenActive(production);\\n                if (planetUpdate.numSpaceships < cap) {\\n                    uint256 futureExtraProduction = cap -\\n                        planetUpdate.numSpaceships;\\n                    if (futureExtraProduction > quantity) {\\n                        futureExtraProduction = quantity;\\n                    }\\n                    int256 newTravelingUpkeep = int256(\\n                        planetUpdate.travelingUpkeep\\n                    ) + int256(futureExtraProduction);\\n                    if (newTravelingUpkeep > int256(cap)) {\\n                        newTravelingUpkeep = int256(cap);\\n                    }\\n                    planetUpdate.travelingUpkeep = int40(newTravelingUpkeep);\\n                    planetUpdate.futureExtraProduction = uint24(\\n                        futureExtraProduction\\n                    ); // cap is always smaller than uint24\\n                }\\n            }\\n\\n            if (planetUpdate.overflow > quantity) {\\n                planetUpdate.overflow -= quantity;\\n            } else {\\n                planetUpdate.overflow = 0;\\n            }\\n        }\\n    }\\n\\n    function _setFleetFlyingSlot(uint256 from, uint32 quantity) internal {\\n        // -----------------------------------------------------------------------------------------------------------\\n        // record flying fleets (to prevent front-running, see resolution)\\n        // -----------------------------------------------------------------------------------------------------------\\n        uint256 timeSlot = block.timestamp / (_frontrunningDelay / 2);\\n        uint32 flying = _inFlight[from][timeSlot].flying;\\n        unchecked {\\n            flying = flying + quantity;\\n        }\\n        require(flying >= quantity, \\\"ORBIT_OVERFLOW\\\"); // unlikely to ever happen,\\n        // would need a huge amount of spaceships to be received and each in turn being sent\\n        // TOEXPLORE could also cap, that would result in some fleet being able to escape.\\n        _inFlight[from][timeSlot].flying = flying;\\n        // -----------------------------------------------------------------------------------------------------------\\n    }\\n\\n    // ---------------------------------------------------------------------------------------------------------------\\n    // FLEET RESOLUTION, ATTACK / REINFORCEMENT\\n    // ---------------------------------------------------------------------------------------------------------------\\n    struct ResolutionState {\\n        address fleetOwner;\\n        uint40 fleetLaunchTime;\\n        uint32 originalQuantity;\\n        uint32 fleetQuantity;\\n        bytes32 fromData;\\n        uint32 inFlightFleetLoss;\\n        uint32 inFlightPlanetLoss;\\n        bool gifting;\\n        bool taxed;\\n        bool victory;\\n        uint32 attackerLoss;\\n        uint32 defenderLoss;\\n        uint32 orbitDefense1;\\n        uint32 orbitDefenseDestroyed1;\\n        uint32 orbitDefense2;\\n        uint32 orbitDefenseDestroyed2;\\n        uint40 arrivalTime;\\n        uint32 accumulatedDefenseAdded;\\n        uint32 accumulatedAttackAdded;\\n        uint16 attackPower;\\n        uint24 futureExtraProduction;\\n    }\\n\\n    function _resolveFleet(\\n        uint256 fleetId,\\n        FleetResolution calldata resolution\\n    ) internal {\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Initialise State Update\\n        // -----------------------------------------------------------------------------------------------------------\\n        Planet storage toPlanet = _getPlanet(resolution.to);\\n        PlanetUpdateState memory toPlanetUpdate = _createPlanetUpdateState(\\n            toPlanet,\\n            resolution.to\\n        );\\n        ResolutionState memory rState = _createResolutionState(\\n            _fleets[fleetId],\\n            resolution.from\\n        );\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // check requirements\\n        // -----------------------------------------------------------------------------------------------------------\\n\\n        require(\\n            rState.fleetQuantity > 0,\\n            rState.fleetOwner != address(0)\\n                ? \\\"FLEET_RESOLVED_ALREADY\\\"\\n                : \\\"FLEET_DO_NOT_EXIST\\\"\\n        );\\n        _requireCorrectDistance(\\n            resolution.distance,\\n            resolution.from,\\n            resolution.to,\\n            rState.fromData,\\n            toPlanetUpdate.data\\n        );\\n        _requireCorrectTimeAndUpdateArrivalTime(\\n            resolution.distance,\\n            resolution.arrivalTimeWanted,\\n            rState.fleetLaunchTime,\\n            rState.fromData,\\n            rState\\n        );\\n\\n        if (_bootstrapSessionEndTime > 0) {\\n            uint256 timestamp = block.timestamp;\\n\\n            if (timestamp >= _bootstrapSessionEndTime) {\\n                require(\\n                    rState.fleetLaunchTime >= _infinityStartTime,\\n                    \\\"FLEET_LAUNCHED_IN_BOOTSTRAP\\\"\\n                );\\n            }\\n        }\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Compute Basic Planet Updates\\n        // -----------------------------------------------------------------------------------------------------------\\n        _computePlanetUpdateForTimeElapsed(toPlanetUpdate);\\n\\n        address ownerAtArrival = toPlanetUpdate.newOwner; // this can be owner == address(0)\\n\\n        uint32 numSpaceshipsAtArrival = toPlanetUpdate.numSpaceships;\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Traveling logic...\\n        // -----------------------------------------------------------------------------------------------------------\\n\\n        _computeInFlightLossForFleet(rState, resolution);\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Resolution logic...\\n        // -----------------------------------------------------------------------------------------------------------\\n\\n        _updateFleetForGifting(rState, resolution, toPlanetUpdate.newOwner);\\n\\n        _computeResolutionResult(rState, toPlanetUpdate);\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Write New State\\n        // -----------------------------------------------------------------------------------------------------------\\n\\n        _recordInOrbitLossAfterAttack(rState, toPlanetUpdate);\\n\\n        _recordOrbitLossAccountingForFleetOrigin(rState, resolution);\\n\\n        _setTravelingUpkeepFromOrigin(fleetId, rState, resolution.from);\\n\\n        _setPlanet(toPlanet, toPlanetUpdate, rState.victory);\\n\\n        _setAccumulatedAttack(rState, toPlanetUpdate);\\n\\n        _fleets[fleetId].quantity = (1 << 31) | _fleets[fleetId].quantity;\\n        _fleets[fleetId].defender = ownerAtArrival;\\n        _fleets[fleetId].defenderLoss = rState.defenderLoss;\\n        _fleets[fleetId].arrivalTime = uint40(block.timestamp);\\n        _fleets[fleetId].planetActive = toPlanetUpdate.active;\\n        _fleets[fleetId].victory = rState.victory;\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Events\\n        // -----------------------------------------------------------------------------------------------------------\\n        _emitFleetArrived(\\n            fleetId,\\n            rState,\\n            ownerAtArrival,\\n            resolution,\\n            _arrivalData(rState, toPlanetUpdate, numSpaceshipsAtArrival)\\n        );\\n\\n        if (toPlanetUpdate.active && rState.victory) {\\n            // if active and the fleet was victorious we need to handle stake change of hands\\n            if (toPlanetUpdate.exitStartTime != 0) {\\n                // exit has been interupted\\n                // we add stake to new owner\\n                _notifyGeneratorAdd(\\n                    toPlanetUpdate.newOwner,\\n                    uint256(_stake(toPlanetUpdate.data)) * (DECIMALS_14)\\n                );\\n            } else {\\n                // there was no exit, so we move the stake\\n                _notifyGeneratorMove(\\n                    toPlanetUpdate.owner,\\n                    toPlanetUpdate.newOwner,\\n                    uint256(_stake(toPlanetUpdate.data)) * (DECIMALS_14)\\n                );\\n            }\\n        }\\n    }\\n\\n    function _arrivalData(\\n        ResolutionState memory rState,\\n        PlanetUpdateState memory toPlanetUpdate,\\n        uint32 numSpaceshipsAtArrival\\n    ) internal pure returns (ArrivalData memory arrivalData) {\\n        arrivalData.newNumspaceships = toPlanetUpdate.numSpaceships;\\n        arrivalData.newTravelingUpkeep = toPlanetUpdate.travelingUpkeep;\\n        arrivalData.newOverflow = toPlanetUpdate.overflow;\\n        arrivalData.numSpaceshipsAtArrival = numSpaceshipsAtArrival;\\n        arrivalData.taxLoss = rState.taxed\\n            ? (rState.originalQuantity - rState.inFlightFleetLoss) -\\n                rState.fleetQuantity\\n            : 0;\\n        arrivalData.fleetLoss = rState.attackerLoss;\\n        arrivalData.planetLoss = rState.defenderLoss;\\n        arrivalData.inFlightFleetLoss = rState.inFlightFleetLoss;\\n        arrivalData.inFlightPlanetLoss = rState.inFlightPlanetLoss;\\n        arrivalData.accumulatedDefenseAdded = rState.accumulatedDefenseAdded;\\n        arrivalData.accumulatedAttackAdded = rState.accumulatedAttackAdded;\\n    }\\n\\n    function _emitFleetArrived(\\n        uint256 fleetId,\\n        ResolutionState memory rState,\\n        address planetOwner,\\n        FleetResolution memory resolution,\\n        ArrivalData memory arrivalData\\n    ) internal {\\n        emit BlockTime(block.number, block.timestamp);\\n        emit FleetRevealed(\\n            fleetId,\\n            resolution.from,\\n            resolution.to,\\n            resolution.arrivalTimeWanted,\\n            resolution.gift,\\n            resolution.specific,\\n            resolution.secret,\\n            resolution.fleetSender,\\n            resolution.operator\\n        );\\n        emit FleetArrived(\\n            fleetId,\\n            rState.fleetOwner,\\n            planetOwner,\\n            resolution.to,\\n            rState.gifting,\\n            rState.victory,\\n            arrivalData\\n        );\\n    }\\n\\n    function _requireCorrectDistance(\\n        uint256 distance,\\n        uint256 from,\\n        uint256 to,\\n        bytes32 fromPlanetData,\\n        bytes32 toPlanetData\\n    ) internal pure {\\n        // check input instead of compute sqrt\\n\\n        (int8 fromSubX, int8 fromSubY) = _subLocation(fromPlanetData);\\n        (int8 toSubX, int8 toSubY) = _subLocation(toPlanetData);\\n        uint256 distanceSquared = uint256(\\n            int256(\\n                // check input instead of compute sqrt\\n                ((int128(int256(to & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) * 4 +\\n                    toSubX) -\\n                    (int128(int256(from & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) *\\n                        4 +\\n                        fromSubX)) **\\n                    2 +\\n                    ((int128(int256(to >> 128)) * 4 + toSubY) -\\n                        (int128(int256(from >> 128)) * 4 + fromSubY)) **\\n                        2\\n            )\\n        );\\n        require(\\n            distance ** 2 <= distanceSquared &&\\n                distanceSquared < (distance + 1) ** 2,\\n            \\\"wrong distance\\\"\\n        );\\n    }\\n\\n    function _requireCorrectTimeAndUpdateArrivalTime(\\n        uint256 distance,\\n        uint256 arrivalTimeWanted,\\n        uint40 launchTime,\\n        bytes32 fromPlanetData,\\n        ResolutionState memory rState\\n    ) internal view {\\n        uint256 minReachTime = launchTime +\\n            (distance * (_timePerDistance * 10000)) / _speed(fromPlanetData);\\n        uint256 reachTime = Math.max(arrivalTimeWanted, minReachTime);\\n        if (arrivalTimeWanted > 0) {\\n            rState.arrivalTime = uint40(arrivalTimeWanted);\\n        } else {\\n            rState.arrivalTime = uint40(minReachTime);\\n        }\\n        require(block.timestamp >= reachTime, \\\"too early\\\");\\n        require(\\n            block.timestamp < reachTime + _resolveWindow,\\n            \\\"too late, your spaceships are lost in space\\\"\\n        );\\n    }\\n\\n    function _computeInFlightLossForFleet(\\n        ResolutionState memory rState,\\n        FleetResolution memory resolution\\n    ) internal view {\\n        // -----------------------------------------------------------------------------------------------------------\\n        // check if fleet was attacked while departing (used to prevent front-running, see fleet sending)\\n        // -----------------------------------------------------------------------------------------------------------\\n        uint256 timeSlot = rState.fleetLaunchTime / (_frontrunningDelay / 2);\\n        uint32 destroyed = _inFlight[resolution.from][timeSlot].destroyed;\\n        uint32 originalQuantity = rState.fleetQuantity;\\n        if (destroyed < rState.fleetQuantity) {\\n            rState.fleetQuantity -= uint32(destroyed);\\n        } else {\\n            rState.fleetQuantity = 0;\\n        }\\n\\n        rState.inFlightFleetLoss = originalQuantity - rState.fleetQuantity;\\n        // -----------------------------------------------------------------------------------------------------------\\n    }\\n\\n    function _updateFleetForGifting(\\n        ResolutionState memory rState,\\n        FleetResolution memory resolution,\\n        address destinationOwner\\n    ) internal view {\\n        (bool gifting, bool taxed) = _computeGifting(\\n            destinationOwner,\\n            resolution,\\n            rState\\n        );\\n        rState.gifting = gifting;\\n        rState.taxed = taxed;\\n    }\\n\\n    // TODO simplify and apply that to attack (when fleetOwner is not fleetSender)\\n    //  if (resolution.gift) { rState.fleetOwner = destinationOwner }\\n    //  then compute tax based on fleetOwner != fleetSender, box for attacks and gift\\n    //  combined attack could even work for non-allies ?\\n    //  in _computeGift calculate the tax for every branch that result in `gifting` being false\\n    //  then in attack, add tax to the quantity of fleet + modify event\\n\\n    // solhint-disable-next-line code-complexity\\n    function _computeGifting(\\n        address destinationOwner,\\n        FleetResolution memory resolution,\\n        ResolutionState memory rState\\n    ) internal view returns (bool gifting, bool taxed) {\\n        if (destinationOwner == address(0)) {\\n            // destination has no owner : this is an attack\\n            return (\\n                false,\\n                _isFleetOwnerTaxed(\\n                    rState.fleetOwner,\\n                    resolution.fleetSender,\\n                    rState.fleetLaunchTime\\n                )\\n            );\\n        }\\n        if (\\n            destinationOwner == rState.fleetOwner &&\\n            destinationOwner == resolution.fleetSender\\n        ) {\\n            // destination is sender is fleet owner: this is a non-taxed gift\\n            return (true, false);\\n        }\\n\\n        if (resolution.gift || destinationOwner == rState.fleetOwner) {\\n            // intent was gift\\n            if (\\n                resolution.specific == address(0) || // anyone\\n                resolution.specific == destinationOwner || // only one address and matching owner\\n                destinationOwner == rState.fleetOwner // owner is fleet owner => gift\\n            ) {\\n                // and it was for anyone or specific destination owner that is the same as the current one\\n                // or it was simply that fleetOwner = destinationOwner\\n\\n                // check tax applies with sender\\n                (, uint96 joinTime) = _allianceRegistry\\n                    .havePlayersAnAllianceInCommon(\\n                        resolution.fleetSender,\\n                        destinationOwner,\\n                        rState.fleetLaunchTime\\n                    );\\n                return (\\n                    true,\\n                    joinTime == 0 || joinTime > rState.fleetLaunchTime\\n                );\\n            }\\n\\n            if (resolution.specific == address(1)) {\\n                // or the specific specify any common alliances (1)\\n\\n                if (rState.fleetOwner == resolution.fleetSender) {\\n                    (, uint96 joinTime) = _allianceRegistry\\n                        .havePlayersAnAllianceInCommon(\\n                            resolution.fleetSender,\\n                            destinationOwner,\\n                            rState.fleetLaunchTime\\n                        );\\n                    return (joinTime > 0, joinTime > rState.fleetLaunchTime);\\n                } else {\\n                    (, uint96 fleetOwnerJoinTime) = _allianceRegistry\\n                        .havePlayersAnAllianceInCommon(\\n                            rState.fleetOwner,\\n                            destinationOwner,\\n                            rState.fleetLaunchTime\\n                        );\\n\\n                    if (fleetOwnerJoinTime == 0) {\\n                        // not in an alliance\\n                        return (\\n                            false,\\n                            _isFleetOwnerTaxed(\\n                                rState.fleetOwner,\\n                                resolution.fleetSender,\\n                                rState.fleetLaunchTime\\n                            )\\n                        );\\n                    }\\n\\n                    // alliance => means gift\\n                    // check if taxed:\\n                    (, uint96 senderJoinTime) = _allianceRegistry\\n                        .havePlayersAnAllianceInCommon(\\n                            resolution.fleetSender,\\n                            destinationOwner,\\n                            rState.fleetLaunchTime\\n                        );\\n\\n                    return (\\n                        true,\\n                        senderJoinTime == 0 ||\\n                            senderJoinTime > rState.fleetLaunchTime\\n                    );\\n                }\\n            }\\n\\n            if (uint160(resolution.specific) > 1) {\\n                // or a specific alliance that matches\\n\\n                (uint96 joinTimeToSpecific, ) = _allianceRegistry\\n                    .getAllianceData(\\n                        destinationOwner,\\n                        IAlliance(resolution.specific)\\n                    );\\n\\n                if (joinTimeToSpecific > 0) {\\n                    (, uint96 joinTime) = _allianceRegistry\\n                        .havePlayersAnAllianceInCommon(\\n                            resolution.fleetSender,\\n                            destinationOwner,\\n                            rState.fleetLaunchTime\\n                        );\\n                    return (\\n                        true,\\n                        joinTime == 0 || joinTime > rState.fleetLaunchTime\\n                    );\\n                }\\n            }\\n        } else {\\n            // intent was attack\\n            if (resolution.specific == address(1)) {\\n                // and the attack was on any non-allies\\n\\n                if (rState.fleetOwner == resolution.fleetSender) {\\n                    // make it a gift if the destination owner is actually an ally\\n                    (, uint96 joinTime) = _allianceRegistry\\n                        .havePlayersAnAllianceInCommon(\\n                            resolution.fleetSender,\\n                            destinationOwner,\\n                            rState.fleetLaunchTime\\n                        );\\n                    return (joinTime > 0, joinTime > rState.fleetLaunchTime);\\n                } else {\\n                    (, uint96 fleetOwnerJoinTime) = _allianceRegistry\\n                        .havePlayersAnAllianceInCommon(\\n                            rState.fleetOwner,\\n                            destinationOwner,\\n                            rState.fleetLaunchTime\\n                        );\\n\\n                    if (fleetOwnerJoinTime == 0) {\\n                        // not in an alliance\\n                        return (\\n                            false,\\n                            _isFleetOwnerTaxed(\\n                                rState.fleetOwner,\\n                                resolution.fleetSender,\\n                                rState.fleetLaunchTime\\n                            )\\n                        );\\n                    }\\n\\n                    // alliance => means gift\\n                    // check if taxed:\\n                    (, uint96 senderJoinTime) = _allianceRegistry\\n                        .havePlayersAnAllianceInCommon(\\n                            resolution.fleetSender,\\n                            destinationOwner,\\n                            rState.fleetLaunchTime\\n                        );\\n\\n                    return (\\n                        true,\\n                        senderJoinTime == 0 ||\\n                            senderJoinTime > rState.fleetLaunchTime\\n                    );\\n                }\\n            }\\n\\n            if (\\n                uint160(resolution.specific) > 1 &&\\n                resolution.specific != destinationOwner\\n            ) {\\n                // but specific not matching current owner\\n\\n                (uint96 joinTimeToSpecific, ) = _allianceRegistry\\n                    .getAllianceData(\\n                        destinationOwner,\\n                        IAlliance(resolution.specific)\\n                    );\\n\\n                // make it a gift if the destination is not matching the specific alliance\\n                // (or owner, in which case since it is not an alliance, it will also not match)\\n                if (joinTimeToSpecific == 0) {\\n                    (, uint96 joinTime) = _allianceRegistry\\n                        .havePlayersAnAllianceInCommon(\\n                            resolution.fleetSender,\\n                            destinationOwner,\\n                            rState.fleetLaunchTime\\n                        );\\n                    return (\\n                        true,\\n                        joinTime == 0 || joinTime > rState.fleetLaunchTime\\n                    );\\n                }\\n            }\\n        }\\n        return (\\n            false,\\n            _isFleetOwnerTaxed(\\n                rState.fleetOwner,\\n                resolution.fleetSender,\\n                rState.fleetLaunchTime\\n            )\\n        );\\n    }\\n\\n    function _isFleetOwnerTaxed(\\n        address fleetOwner,\\n        address fleetSender,\\n        uint40 fleetLaunchTime\\n    ) internal view returns (bool) {\\n        if (fleetOwner == fleetSender) {\\n            return false;\\n        }\\n        (, uint96 joinTime) = _allianceRegistry.havePlayersAnAllianceInCommon(\\n            fleetOwner,\\n            fleetSender,\\n            fleetLaunchTime\\n        );\\n        return joinTime == 0 || joinTime > fleetLaunchTime;\\n    }\\n\\n    function _setTravelingUpkeepFromOrigin(\\n        uint256 fleetID,\\n        ResolutionState memory rState,\\n        uint256 location\\n    ) internal {\\n        // // we have to update the origin\\n        Planet storage fromPlanet = _planets[location];\\n        PlanetUpdateState memory fromPlanetUpdate = _createPlanetUpdateState(\\n            fromPlanet,\\n            location\\n        );\\n        _computePlanetUpdateForTimeElapsed(fromPlanetUpdate);\\n\\n        uint16 production = _production(fromPlanetUpdate.data);\\n        uint256 capWhenActive = _capWhenActive(production);\\n\\n        uint256 refund = rState.futureExtraProduction;\\n        uint256 timePassed = block.timestamp - rState.fleetLaunchTime;\\n        uint256 amountProducedTheWholeTime = (timePassed *\\n            uint256(_productionSpeedUp) *\\n            uint256(production)) / 1 hours;\\n        uint256 consumed = amountProducedTheWholeTime +\\n            (amountProducedTheWholeTime *\\n                _upkeepProductionDecreaseRatePer10000th) /\\n                10000;\\n        if (consumed > refund) {\\n            refund = 0;\\n        } else {\\n            refund -= consumed;\\n        }\\n\\n        int256 newTravelingUpkeep = int256(fromPlanetUpdate.travelingUpkeep) -\\n            int256(refund);\\n        if (newTravelingUpkeep < -int256(capWhenActive)) {\\n            newTravelingUpkeep = -int256(capWhenActive);\\n        }\\n        fromPlanetUpdate.travelingUpkeep = int40(newTravelingUpkeep);\\n\\n        _setPlanet(fromPlanet, fromPlanetUpdate, false);\\n\\n        emit BlockTime(block.number, block.timestamp);\\n        emit TravelingUpkeepRefund(\\n            location,\\n            fleetID,\\n            fromPlanetUpdate.numSpaceships,\\n            fromPlanetUpdate.travelingUpkeep,\\n            fromPlanetUpdate.overflow\\n        );\\n    }\\n\\n    function _setAccumulatedAttack(\\n        ResolutionState memory rState,\\n        PlanetUpdateState memory toPlanetUpdate\\n    ) internal {\\n        if (!rState.taxed) {\\n            AccumulatedAttack storage attack = _attacks[\\n                toPlanetUpdate.location\\n            ][rState.fleetOwner][rState.arrivalTime];\\n\\n            // NOTE: target is required for the case where a different player capture the planet in-between\\n            //  otherwise, that player would be hitted with higher attack than would be fair\\n            //  hmm would it acutally ? the accumulatedDefenseAdded would still be counted\\n            //  Indeed, the only real player affected by _attacks[location][fleetOwner][arrivalTime] is the fleetOwner\\n            //  regardless of who is owner of the planet\\n            // attack.target = toPlanetUpdate.owner;\\n            // we leave this as is as we do not want to change the struct\\n            attack.damageCausedSoFar =\\n                rState.defenderLoss +\\n                rState.inFlightPlanetLoss +\\n                rState.accumulatedDefenseAdded;\\n            attack.numAttackSpent =\\n                rState.attackerLoss +\\n                rState.accumulatedAttackAdded +\\n                // when victorius we consider the full number of spaceship as used\\n                // this way if a combined attack arrive later, it can still count the whole attack and get a refund\\n                (rState.victory ? toPlanetUpdate.numSpaceships : 0);\\n            attack.averageAttackPower = rState.attackPower;\\n        }\\n    }\\n\\n    function _combinedRefund(\\n        ResolutionState memory rState,\\n        PlanetUpdateState memory toPlanetUpdate\\n    ) internal view returns (uint256 accumulationRefund) {\\n        _updateAccumulation(rState, toPlanetUpdate);\\n        if (rState.accumulatedAttackAdded > 0) {\\n            uint16 attack = rState.attackPower;\\n            uint16 defense = _defense(toPlanetUpdate.data);\\n            uint256 numAttack = rState.fleetQuantity +\\n                rState.accumulatedAttackAdded;\\n            (uint32 attackerLoss, ) = _computeFight(\\n                numAttack,\\n                rState.accumulatedDefenseAdded,\\n                attack,\\n                defense\\n            );\\n            if (rState.accumulatedAttackAdded > attackerLoss) {\\n                accumulationRefund =\\n                    rState.accumulatedAttackAdded - attackerLoss;\\n                if (accumulationRefund > rState.accumulatedAttackAdded) {\\n                    rState.accumulatedAttackAdded = 0;\\n                } else {\\n                    rState.accumulatedAttackAdded = uint32(\\n                        uint256(rState.accumulatedAttackAdded) -\\n                            accumulationRefund\\n                    );\\n                }\\n            }\\n        }\\n    }\\n\\n    function _createResolutionState(\\n        Fleet storage fleet,\\n        uint256 from\\n    ) internal view returns (ResolutionState memory rState) {\\n        uint32 q = fleet.quantity >> 31 == 1 ? 0 : fleet.quantity;\\n        rState.fleetOwner = fleet.owner;\\n        rState.fleetLaunchTime = fleet.launchTime;\\n        rState.originalQuantity = q;\\n        rState.fleetQuantity = q;\\n        rState.futureExtraProduction = fleet.futureExtraProduction;\\n        rState.fromData = _planetData(from);\\n        rState.attackPower = _attack(rState.fromData);\\n    }\\n\\n    function _recordOrbitLossAccountingForFleetOrigin(\\n        ResolutionState memory rState,\\n        FleetResolution memory resolution\\n    ) internal {\\n        if (rState.inFlightFleetLoss > 0) {\\n            uint256 timeSlot = rState.fleetLaunchTime /\\n                (_frontrunningDelay / 2);\\n\\n            // NOTE we already computed that destroyed cannot be smaller than inFlightFleetLoss\\n            //  see _computeInFlightLossForFleet\\n            _inFlight[resolution.from][timeSlot].destroyed -= rState\\n                .inFlightFleetLoss;\\n        }\\n    }\\n\\n    function _computeResolutionResult(\\n        ResolutionState memory rState,\\n        PlanetUpdateState memory toPlanetUpdate\\n    ) internal view {\\n        if (rState.taxed) {\\n            rState.fleetQuantity = uint32(\\n                uint256(rState.fleetQuantity) -\\n                    (uint256(rState.fleetQuantity) * _giftTaxPer10000) / 10000\\n            );\\n        }\\n        if (rState.gifting) {\\n            _computeGiftingResolutionResult(rState, toPlanetUpdate);\\n        } else {\\n            _computeAttackResolutionResult(rState, toPlanetUpdate);\\n        }\\n    }\\n\\n    function _computeGiftingResolutionResult(\\n        ResolutionState memory rState,\\n        PlanetUpdateState memory toPlanetUpdate\\n    ) internal view {\\n        uint256 newNumSpaceships = toPlanetUpdate.numSpaceships +\\n            rState.fleetQuantity +\\n            _combinedRefund(rState, toPlanetUpdate);\\n        if (newNumSpaceships >= ACTIVE_MASK) {\\n            newNumSpaceships = ACTIVE_MASK - 1;\\n        }\\n\\n        toPlanetUpdate.numSpaceships = uint32(newNumSpaceships);\\n        if (!toPlanetUpdate.active) {\\n            // NOTE: not active, overflow is applied on cap = 0\\n            if (toPlanetUpdate.numSpaceships > toPlanetUpdate.overflow) {\\n                toPlanetUpdate.overflow = toPlanetUpdate.numSpaceships;\\n            }\\n        } else {\\n            uint32 cap = uint32(\\n                _capWhenActive(_production(toPlanetUpdate.data))\\n            );\\n            if (_productionCapAsDuration > 0 && newNumSpaceships > cap) {\\n                if (\\n                    toPlanetUpdate.numSpaceships - cap > toPlanetUpdate.overflow\\n                ) {\\n                    toPlanetUpdate.overflow = uint32(\\n                        toPlanetUpdate.numSpaceships - cap\\n                    );\\n                }\\n            } else {\\n                toPlanetUpdate.overflow = 0;\\n            }\\n        }\\n    }\\n\\n    function _updateAccumulation(\\n        ResolutionState memory rState,\\n        PlanetUpdateState memory toPlanetUpdate\\n    ) internal view {\\n        // TODO 45min config ?\\n        if (\\n            !rState.taxed && block.timestamp < rState.arrivalTime + 45 minutes\\n        ) {\\n            AccumulatedAttack memory acc = _attacks[toPlanetUpdate.location][\\n                rState.fleetOwner\\n            ][rState.arrivalTime];\\n\\n            // TODO  acc.target == toPlanetUpdate.owner || toPlanetUpdate.owner == fleetOwner  so your combined attack works when you get it\\n            // what about your allies ?\\n            // taxed work as he accumulated attack is already shared with allies (s)\\n            // so we should not need to modify here ?\\n            // if (acc.target == toPlanetUpdate.owner && acc.numAttackSpent != 0) {\\n            if (acc.numAttackSpent != 0) {\\n                rState.attackPower = uint16(\\n                    (uint256(rState.attackPower) *\\n                        uint256(rState.fleetQuantity) +\\n                        uint256(acc.averageAttackPower) *\\n                            uint256(acc.numAttackSpent)) /\\n                        (uint256(rState.fleetQuantity) +\\n                            uint256(acc.numAttackSpent))\\n                );\\n                rState.accumulatedAttackAdded = acc.numAttackSpent;\\n                rState.accumulatedDefenseAdded = acc.damageCausedSoFar;\\n            }\\n        }\\n    }\\n\\n    function _computeAttackResolutionResult(\\n        ResolutionState memory rState,\\n        PlanetUpdateState memory toPlanetUpdate\\n    ) internal view {\\n        // NOTE natives come back to power once numSPaceships == 0 and planet not active\\n        if (\\n            !toPlanetUpdate.active &&\\n            toPlanetUpdate.numSpaceships < _natives(toPlanetUpdate.data)\\n        ) {\\n            _updatePlanetUpdateStateAndResolutionStateForNativeAttack(\\n                rState,\\n                toPlanetUpdate\\n            );\\n        } else {\\n            _updateAccumulation(rState, toPlanetUpdate);\\n\\n            _updatePlanetUpdateStateAndResolutionStateForPlanetAttack(\\n                rState,\\n                toPlanetUpdate\\n            );\\n        }\\n    }\\n\\n    function _updatePlanetUpdateStateAndResolutionStateForNativeAttack(\\n        ResolutionState memory rState,\\n        PlanetUpdateState memory toPlanetUpdate\\n    ) internal view {\\n        // NOTE: when we are dealing with native attacks, we do not consider combined attacks\\n        // TODO We need to consider that case in the UI\\n        uint16 attack = _attack(rState.fromData);\\n        uint16 defense = _defense(toPlanetUpdate.data);\\n        uint16 natives = _natives(toPlanetUpdate.data);\\n        (uint32 attackerLoss, uint32 defenderLoss) = _computeFight(\\n            rState.fleetQuantity,\\n            natives,\\n            attack,\\n            defense\\n        );\\n        rState.attackerLoss = attackerLoss;\\n        if (defenderLoss == natives && rState.fleetQuantity > attackerLoss) {\\n            // (attackerLoss: 0, defenderLoss: 0) means that numAttack was zero as natives cannot be zero\\n            toPlanetUpdate.numSpaceships = rState.fleetQuantity - attackerLoss;\\n            rState.defenderLoss = defenderLoss;\\n            rState.victory = true;\\n            toPlanetUpdate.newOwner = rState.fleetOwner;\\n            // solhint-disable-next-line no-empty-blocks\\n        }\\n        // NOTE else (attacker lost) then nothing happen\\n    }\\n\\n    function _updatePlanetUpdateStateAndResolutionStateForPlanetAttack(\\n        ResolutionState memory rState,\\n        PlanetUpdateState memory toPlanetUpdate\\n    ) internal view {\\n        _updateResolutionStateFromOrbitDefense(rState, toPlanetUpdate);\\n        uint256 numDefense = toPlanetUpdate.numSpaceships +\\n            rState.accumulatedDefenseAdded +\\n            rState.orbitDefense1 +\\n            rState.orbitDefense2;\\n        uint16 production = _production(toPlanetUpdate.data);\\n\\n        if (numDefense == 0 && rState.fleetQuantity > 0) {\\n            // scenario where there is actually no defense on the place,\\n\\n            toPlanetUpdate.newOwner = rState.fleetOwner;\\n            toPlanetUpdate.numSpaceships = rState.fleetQuantity;\\n            if (!toPlanetUpdate.active) {\\n                // numDefense = 0 so numAttack is the overflow, attacker took over\\n                toPlanetUpdate.overflow = toPlanetUpdate.numSpaceships;\\n            } else {\\n                if (_productionCapAsDuration > 0) {\\n                    uint32 cap = uint32(_capWhenActive(production));\\n                    if (toPlanetUpdate.numSpaceships > cap) {\\n                        // numDefense = 0 so numAttack is the overflow, attacker took over\\n                        toPlanetUpdate.overflow = uint32(\\n                            toPlanetUpdate.numSpaceships - cap\\n                        );\\n                    } else {\\n                        toPlanetUpdate.overflow = 0;\\n                    }\\n                }\\n            }\\n\\n            rState.victory = true;\\n        } else {\\n            _computeAttack(rState, toPlanetUpdate, numDefense);\\n            _computeTravelingUpkeepReductionFromDefenseLoss(\\n                rState,\\n                toPlanetUpdate,\\n                production\\n            );\\n        }\\n    }\\n\\n    function _updateResolutionStateFromOrbitDefense(\\n        ResolutionState memory rState,\\n        PlanetUpdateState memory toPlanetUpdate\\n    ) internal view {\\n        // -----------------------------------------------------------------------------------------------------------\\n        // consider fleets that just departed from the planet (used to prevent front-running, see fleet sending)\\n        // -----------------------------------------------------------------------------------------------------------\\n        uint256 timeSlot = block.timestamp / (_frontrunningDelay / 2);\\n        InFlight storage slot1 = _inFlight[toPlanetUpdate.location][\\n            timeSlot - 1\\n        ];\\n        rState.orbitDefense1 = slot1.flying > 2 ** 31\\n            ? 2 ** 31 - 1\\n            : uint32(slot1.flying);\\n        rState.orbitDefenseDestroyed1 = slot1.destroyed > 2 ** 31\\n            ? 2 ** 31 - 1\\n            : uint32(slot1.destroyed);\\n        InFlight storage slot2 = _inFlight[toPlanetUpdate.location][timeSlot];\\n        rState.orbitDefense2 = slot2.flying > 2 ** 31\\n            ? 2 ** 31 - 1\\n            : uint32(slot2.flying);\\n        rState.orbitDefenseDestroyed2 = slot2.destroyed > 2 ** 31\\n            ? 2 ** 31 - 1\\n            : uint32(slot2.destroyed);\\n    }\\n\\n    // solhint-disable-next-line code-complexity\\n    function _computeAttack(\\n        ResolutionState memory rState,\\n        PlanetUpdateState memory toPlanetUpdate,\\n        uint256 numDefense\\n    ) internal view {\\n        uint16 attack = rState.attackPower;\\n        uint16 defense = _defense(toPlanetUpdate.data);\\n        uint256 numAttack = rState.fleetQuantity +\\n            rState.accumulatedAttackAdded;\\n        (uint32 attackerLoss, uint32 defenderLoss) = _computeFight(\\n            numAttack,\\n            numDefense,\\n            attack,\\n            defense\\n        );\\n        rState.defenderLoss = defenderLoss;\\n        rState.attackerLoss = rState.accumulatedAttackAdded > attackerLoss\\n            ? 0\\n            : attackerLoss - rState.accumulatedAttackAdded;\\n\\n        // (attackerLoss: 0, defenderLoss: 0) could either mean attack was zero or defense was zero :\\n        if (rState.fleetQuantity > 0 && rState.defenderLoss == numDefense) {\\n            // NOTE Attacker wins\\n\\n            // all orbiting fleets are destroyed, inFlightPlanetLoss is all that is left\\n            uint256 inFlightPlanetLoss = numDefense -\\n                toPlanetUpdate.numSpaceships -\\n                rState.accumulatedDefenseAdded;\\n            if (inFlightPlanetLoss > ACTIVE_MASK) {\\n                // cap it\\n                // TODO investigate potential issues\\n                inFlightPlanetLoss = ACTIVE_MASK - 1;\\n            }\\n            rState.inFlightPlanetLoss = uint32(inFlightPlanetLoss);\\n\\n            rState.defenderLoss =\\n                rState.defenderLoss - rState.inFlightPlanetLoss;\\n\\n            toPlanetUpdate.numSpaceships =\\n                rState.fleetQuantity - rState.attackerLoss;\\n            rState.victory = true;\\n\\n            toPlanetUpdate.newOwner = rState.fleetOwner;\\n\\n            if (!toPlanetUpdate.active) {\\n                // attack took over, overflow is numSpaceships\\n                toPlanetUpdate.overflow = toPlanetUpdate.numSpaceships;\\n            } else {\\n                if (_productionCapAsDuration > 0) {\\n                    uint16 production = _production(toPlanetUpdate.data);\\n                    uint32 cap = uint32(_capWhenActive(production));\\n                    if (toPlanetUpdate.numSpaceships > cap) {\\n                        if (\\n                            toPlanetUpdate.numSpaceships - cap >\\n                            toPlanetUpdate.overflow\\n                        ) {\\n                            toPlanetUpdate.overflow =\\n                                toPlanetUpdate.numSpaceships - cap;\\n                        }\\n                    } else {\\n                        toPlanetUpdate.overflow = 0;\\n                    }\\n                }\\n            }\\n        } else if (rState.attackerLoss == rState.fleetQuantity) {\\n            // NOTE Defender wins\\n\\n            if (\\n                defenderLoss >\\n                toPlanetUpdate.numSpaceships + rState.accumulatedDefenseAdded\\n            ) {\\n                rState.inFlightPlanetLoss =\\n                    defenderLoss -\\n                    toPlanetUpdate.numSpaceships -\\n                    rState.accumulatedDefenseAdded;\\n\\n                toPlanetUpdate.numSpaceships = 0;\\n                // TODO change owner already if incative ?\\n                //  not needed though as this is the same has having numSpaceships = 1 and become zero over time\\n\\n                if (rState.orbitDefense1 >= rState.inFlightPlanetLoss) {\\n                    rState.orbitDefense1 -= rState.inFlightPlanetLoss;\\n                    rState.orbitDefenseDestroyed1 += rState.inFlightPlanetLoss;\\n                } else {\\n                    rState.orbitDefenseDestroyed1 += rState.orbitDefense1;\\n                    uint32 extra = (rState.inFlightPlanetLoss -\\n                        rState.orbitDefense1);\\n                    if (rState.orbitDefense2 >= extra) {\\n                        rState.orbitDefense2 -= extra;\\n                        rState.orbitDefenseDestroyed2 += extra;\\n                    } else {\\n                        rState.orbitDefenseDestroyed2 += rState.orbitDefense2;\\n                        rState.orbitDefense2 = 0; // should never reach minus but let simply set it to zero\\n                    }\\n                    rState.orbitDefense1 = 0;\\n                }\\n            } else {\\n                toPlanetUpdate.numSpaceships =\\n                    toPlanetUpdate.numSpaceships +\\n                    rState.accumulatedDefenseAdded -\\n                    defenderLoss;\\n\\n                // TODO change owner already if incative and numSpaceship == 0 (like above)\\n                //  not needed though as this is the same has having numSpaceships = 1 and become zero over time\\n            }\\n\\n            // same as numSpaceshipAtArrival - toPlanetUpdate.numSpaceship;\\n            rState.defenderLoss =\\n                rState.defenderLoss -\\n                rState.inFlightPlanetLoss -\\n                rState.accumulatedDefenseAdded;\\n\\n            if (!toPlanetUpdate.active) {\\n                if (defenderLoss > toPlanetUpdate.overflow) {\\n                    toPlanetUpdate.overflow = 0;\\n                } else {\\n                    toPlanetUpdate.overflow -= defenderLoss;\\n                }\\n            } else {\\n                if (_productionCapAsDuration > 0) {\\n                    uint16 production = _production(toPlanetUpdate.data);\\n                    uint32 cap = uint32(_capWhenActive(production));\\n                    if (toPlanetUpdate.numSpaceships > cap) {\\n                        if (defenderLoss <= toPlanetUpdate.overflow) {\\n                            toPlanetUpdate.overflow -= defenderLoss;\\n                        } else {\\n                            toPlanetUpdate.overflow = 0;\\n                        }\\n                    } else {\\n                        toPlanetUpdate.overflow = 0;\\n                    }\\n                }\\n            }\\n        } else {\\n            // should not happen\\n            // because we check for numDefense == 0 before performing the attack, see _updatePlanetUpdateStateAndResolutionStateForPlanetAttack\\n            revert(\\\"ZERO_ZERO\\\");\\n        }\\n    }\\n\\n    function _computeFight(\\n        uint256 numAttack,\\n        uint256 numDefense,\\n        uint256 attack,\\n        uint256 defense\\n    ) internal view returns (uint32 attackerLoss, uint32 defenderLoss) {\\n        if (numAttack == 0 || numDefense == 0) {\\n            // this edge case need to be considered,\\n            // as the result of this function cannot tell from it whos is winning here\\n            return (0, 0);\\n        }\\n\\n        uint256 attackFactor = numAttack *\\n            ((1000000 - _fleetSizeFactor6) +\\n                ((_fleetSizeFactor6 * numAttack) / numDefense));\\n        uint256 attackDamage = (attackFactor * attack) / defense / 1000000;\\n\\n        if (numDefense > attackDamage) {\\n            // attack fails\\n            attackerLoss = uint32(numAttack); // all attack destroyed\\n            defenderLoss = uint32(attackDamage); // 1 spaceship will be left at least as attackDamage < numDefense\\n        } else {\\n            // attack succeed\\n            uint256 defenseFactor = numDefense *\\n                ((1000000 - _fleetSizeFactor6) +\\n                    ((_fleetSizeFactor6 * numDefense) / numAttack));\\n            uint256 defenseDamage = uint32(\\n                (defenseFactor * defense) / attack / 1000000\\n            );\\n\\n            if (defenseDamage >= numAttack) {\\n                defenseDamage = numAttack - 1; // ensure 1 spaceship left\\n            }\\n\\n            attackerLoss = uint32(defenseDamage);\\n            defenderLoss = uint32(numDefense); // all defense destroyed\\n        }\\n    }\\n\\n    function _computeTravelingUpkeepReductionFromDefenseLoss(\\n        ResolutionState memory rState,\\n        PlanetUpdateState memory toPlanetUpdate,\\n        uint16 production\\n    ) internal view {\\n        // allow the attacker to pay for upkeep as part of the attack\\n        // only get to keep the upkeep that was there as a result of spaceships sent away\\n\\n        uint256 capWhenActive = _capWhenActive(production);\\n\\n        int256 totalDefenseLoss = int256(\\n            uint256(rState.defenderLoss) + uint256(rState.inFlightPlanetLoss)\\n        );\\n        int256 newTravelingUpkeep = int256(toPlanetUpdate.travelingUpkeep) -\\n            totalDefenseLoss;\\n        if (newTravelingUpkeep < -int256(capWhenActive)) {\\n            newTravelingUpkeep = -int256(capWhenActive);\\n        }\\n        toPlanetUpdate.travelingUpkeep = int40(newTravelingUpkeep);\\n    }\\n\\n    function _recordInOrbitLossAfterAttack(\\n        ResolutionState memory rState,\\n        PlanetUpdateState memory toPlanetUpdate\\n    ) internal {\\n        if (rState.inFlightPlanetLoss > 0) {\\n            InFlight storage slot1 = _inFlight[toPlanetUpdate.location][\\n                block.timestamp / (_frontrunningDelay / 2) - 1\\n            ];\\n            slot1.flying = rState.orbitDefense1;\\n            slot1.destroyed = rState.orbitDefenseDestroyed1;\\n\\n            InFlight storage slot2 = _inFlight[toPlanetUpdate.location][\\n                block.timestamp / (_frontrunningDelay / 2)\\n            ];\\n            slot2.flying = rState.orbitDefense2;\\n            slot2.destroyed = rState.orbitDefenseDestroyed2;\\n        }\\n    }\\n\\n    function _callWithGas(address to, bytes memory data, uint256 gas) internal {\\n        // We want to ensure enough gas were given for the generator, but no more\\n        // This way if the generator is broken/compromised (we are planning to update it)\\n        // then this will always continue to work\\n        // Reversely, a player have to provide enough gas\\n        // and we want to ensure the player can't force a revert on the hook\\n        // In particular. to prevent players to make a call to `remove` fails\\n\\n        if (to != address(0)) {\\n            // we could do the check prior:\\n            // uint256 gasAvailable = gasleft() - 2000;\\n            // require(gasAvailable - gasAvailable / 64  >= gas, \\\"NOT_ENOUGH_GAS_FOR_INNER_CALL\\\");\\n            // to.call{gas: gas}(data);\\n            // but we instead chose to do the check after.\\n            // for more info see: https://ronan.eth.limo/blog/ethereum-gas-dangers/\\n\\n            to.call{gas: gas}(data);\\n            // we use after the gas check as this allow us to not require heavy gas use if not needed\\n            // instead of + 100,000 for 96,000 gas we can just add 1,524 gas (+ a bit more)\\n            require(gasleft() > gas / 63, \\\"NOT_ENOUGH_GAS_FOR_INNER_CALL\\\");\\n        }\\n    }\\n\\n    function _generator() internal view returns (address generator) {\\n        assembly {\\n            // keccak256(\\\"generator\\\") - 1\\n            generator := sload(\\n                0x27ec6af4a6510eb9b7e0cc7f39415b7f15e430e53eb0cd3997e7c7e0cf680f6e\\n            )\\n        }\\n    }\\n\\n    function _notifyGeneratorAdd(address player, uint256 amount) internal {\\n        _callWithGas(\\n            _generator(),\\n            abi.encodeWithSelector(IOnStakeChange.add.selector, player, amount),\\n            96000\\n        );\\n    }\\n\\n    function _notifyGeneratorRemove(address player, uint256 amount) internal {\\n        _callWithGas(\\n            _generator(),\\n            abi.encodeWithSelector(\\n                IOnStakeChange.remove.selector,\\n                player,\\n                amount\\n            ),\\n            96000\\n        );\\n    }\\n\\n    function _notifyGeneratorMove(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        _callWithGas(\\n            _generator(),\\n            abi.encodeWithSelector(\\n                IOnStakeChange.move.selector,\\n                from,\\n                to,\\n                amount\\n            ),\\n            192000\\n        );\\n    }\\n\\n    // ---------------------------------------------------------------------------------------------------------------\\n    // PLANET STATS\\n    // ---------------------------------------------------------------------------------------------------------------\\n\\n    function _planetData(uint256 location) internal view returns (bytes32) {\\n        return keccak256(abi.encodePacked(_genesis, location));\\n    }\\n\\n    function _subLocation(\\n        bytes32 data\\n    ) internal pure returns (int8 subX, int8 subY) {\\n        subX = 1 - int8(data.value8Mod(0, 3));\\n        subY = 1 - int8(data.value8Mod(2, 3));\\n    }\\n\\n    function _stake(bytes32 data) internal view returns (uint32) {\\n        require(_exists(data), \\\"PLANET_NOT_EXISTS\\\");\\n        // return data.normal16(4, 0x000400050005000A000A000F000F00140014001E001E00280028005000500064);\\n        uint8 productionIndex = data.normal8(12); // production affect the stake value\\n\\n        // TODO remove or decide otherwise:\\n        // uint16 offset = data.normal16(4, 0x0000000100010002000200030003000400040005000500060006000700070008);\\n        // uint16 stakeIndex = productionIndex + offset;\\n        // if (stakeIndex < 4) {\\n        //     stakeIndex = 0;\\n        // } else if (stakeIndex > 19) {\\n        //     stakeIndex = 15;\\n        // } else {\\n        //     stakeIndex -= 4;\\n        // }\\n        uint16 stakeIndex = productionIndex;\\n        return\\n            uint32(\\n                uint256(\\n                    uint16(uint8(_stakeRange[stakeIndex * 2])) * 0x100 +\\n                        uint16(uint8(_stakeRange[stakeIndex * 2 + 1]))\\n                ) * _stakeMultiplier10000th\\n            );\\n    }\\n\\n    function _production(bytes32 data) internal pure returns (uint16) {\\n        require(_exists(data), \\\"PLANET_NOT_EXISTS\\\");\\n        // TODO TRY : 1800,2100,2400,2700,3000,3300,3600, 3600, 3600, 3600,4000,4400,4800,5400,6200,7200 ?\\n\\n        // 1800,2100,2400,2700,3000,3300,3600, 3600, 3600, 3600,4200,5400,6600,7800,9000,12000\\n        // 0x0708083409600a8c0bb80ce40e100e100e100e101068151819c81e7823282ee0\\n        return\\n            data.normal16(\\n                12,\\n                0x0708083409600a8c0bb80ce40e100e100e100e101068151819c81e7823282ee0\\n            ); // per hour\\n    }\\n\\n    function _capWhenActive(uint16 production) internal view returns (uint256) {\\n        return\\n            _acquireNumSpaceships +\\n            (uint256(production) * _productionCapAsDuration) / 1 hours;\\n    }\\n\\n    function _attack(bytes32 data) internal pure returns (uint16) {\\n        require(_exists(data), \\\"PLANET_NOT_EXISTS\\\");\\n        return 4000 + data.normal8(20) * 400; // 4,000 - 7,000 - 10,000\\n    }\\n\\n    function _defense(bytes32 data) internal pure returns (uint16) {\\n        require(_exists(data), \\\"PLANET_NOT_EXISTS\\\");\\n        return 4000 + data.normal8(28) * 400; // 4,000 - 7,000 - 10,000\\n    }\\n\\n    function _speed(bytes32 data) internal pure returns (uint16) {\\n        require(_exists(data), \\\"PLANET_NOT_EXISTS\\\");\\n        return 5005 + data.normal8(36) * 333; // 5,005 - 7,502.5 - 10,000\\n    }\\n\\n    function _natives(bytes32 data) internal pure returns (uint16) {\\n        require(_exists(data), \\\"PLANET_NOT_EXISTS\\\");\\n        return 15000 + data.normal8(44) * 3000; // 15,000 - 37,500 - 60,000\\n    }\\n\\n    function _exists(bytes32 data) internal pure returns (bool) {\\n        return data.value8Mod(52, 16) == 1; // 16 => 36 so : 1 planet per 6 (=24 min unit) square\\n        // also:\\n        // 20000 average starting numSpaceships (or max?)\\n        // speed of min unit = 30 min ( 1 hour per square)\\n        // production : 20000 per 6 hours\\n        // exit : 3 days ? => 72 distance\\n    }\\n\\n    // ---------------------------------------------------------------------------------------------------------------\\n    // GETTERS\\n    // ---------------------------------------------------------------------------------------------------------------\\n\\n    function _getPlanet(\\n        uint256 location\\n    ) internal view returns (Planet storage) {\\n        return _planets[location];\\n    }\\n\\n    function _getPlanetStats(\\n        uint256 location\\n    ) internal view returns (PlanetStats memory) {\\n        bytes32 data = _planetData(location);\\n        require(_exists(data), \\\"no planet in this location\\\");\\n\\n        (int8 subX, int8 subY) = _subLocation(data);\\n        return\\n            PlanetStats({\\n                subX: subX,\\n                subY: subY,\\n                stake: _stake(data),\\n                production: _production(data),\\n                attack: _attack(data),\\n                defense: _defense(data),\\n                speed: _speed(data),\\n                natives: _natives(data)\\n            });\\n    }\\n\\n    // ---------------------------------------------------------------------------------------------------------------\\n    // UTILS\\n    // ---------------------------------------------------------------------------------------------------------------\\n\\n    function _activeNumSpaceships(\\n        uint32 numSpaceshipsData\\n    ) internal pure returns (bool active, uint32 numSpaceships) {\\n        active = (numSpaceshipsData & ACTIVE_MASK) == ACTIVE_MASK;\\n        numSpaceships = numSpaceshipsData % (ACTIVE_MASK);\\n    }\\n\\n    function _setActiveNumSpaceships(\\n        bool active,\\n        uint32 numSpaceships\\n    ) internal pure returns (uint32) {\\n        return uint32((active ? ACTIVE_MASK : 0) + numSpaceships);\\n    }\\n\\n    function _msgSender() internal view returns (address) {\\n        return msg.sender; // TODO metatx\\n    }\\n\\n    modifier whenNotPaused() {\\n        if (_bootstrapSessionEndTime > 0) {\\n            uint256 timestamp = block.timestamp;\\n            uint256 pauseStart = _bootstrapSessionEndTime;\\n            uint256 pauseEnd = _infinityStartTime;\\n\\n            require(timestamp < pauseStart || timestamp >= pauseEnd, \\\"PAUSED\\\");\\n        }\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0xebc1aba45ef231e3f1432799dae662f69f2b6d2177aed39d857a5f6cd24e8a8e\",\"license\":\"AGPL-3.0\"},\"project/src/outerspace/facets/OuterSpaceStakingFacet.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.9;\\n\\nimport \\\"./OuterSpaceFacetBase.sol\\\";\\nimport \\\"../interfaces/IOuterSpaceStaking.sol\\\";\\n\\ncontract OuterSpaceStakingFacet is OuterSpaceFacetBase, IOuterSpaceStaking {\\n    constructor(Config memory config) OuterSpaceFacetBase(config) {}\\n\\n    // ---------------------------------------------------------------------------------------------------------------\\n    // STAKING / PRODUCTION CAPTURE\\n    // ---------------------------------------------------------------------------------------------------------------\\n\\n    function onTokenTransfer(\\n        address,\\n        uint256 amount,\\n        bytes calldata data\\n    ) public returns (bool) {\\n        bool freegift;\\n        if (msg.sender == address(_freeStakingToken)) {\\n            freegift = true;\\n        } else {\\n            require(msg.sender == address(_stakingToken), \\\"INVALID_ERC20\\\");\\n        }\\n\\n        // adhoc support for multiple claim at once\\n        if (data.length > 64) {\\n            (address acquirer, uint256[] memory locations) = abi.decode(\\n                data,\\n                (address, uint256[])\\n            );\\n            uint256 total = 0;\\n            for (uint256 i = 0; i < locations.length; i++) {\\n                uint256 stake = uint256(_stake(_planetData(locations[i]))) *\\n                    (DECIMALS_14);\\n                _acquire(acquirer, stake, locations[i], freegift); // we do not care of who the payer is\\n                total += stake;\\n            }\\n            require(amount == total, \\\"INVALID_AMOUNT\\\");\\n        } else {\\n            (address acquirer, uint256 location) = abi.decode(\\n                data,\\n                (address, uint256)\\n            );\\n            _acquire(acquirer, amount, location, freegift); // we do not care of who the payer is\\n        }\\n        return true;\\n    }\\n\\n    function onTokenPaidFor(\\n        address,\\n        address forAddress,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bool) {\\n        bool freegift;\\n        if (msg.sender == address(_freeStakingToken)) {\\n            freegift = true;\\n        } else {\\n            require(msg.sender == address(_stakingToken), \\\"INVALID_ERC20\\\");\\n        }\\n        uint256 location = abi.decode(data, (uint256));\\n        _acquire(forAddress, amount, location, freegift); // we do not care of who the payer is\\n        return true;\\n    }\\n\\n    function acquireViaTransferFrom(uint256 location, uint256 amount) public {\\n        address sender = _msgSender();\\n        _acquire(sender, amount, location, false);\\n        _stakingToken.transferFrom(sender, address(this), amount);\\n    }\\n\\n    function acquireMultipleViaTransferFrom(\\n        uint256[] memory locations,\\n        uint256 amount\\n    ) public {\\n        address sender = _msgSender();\\n        uint256 total = 0;\\n        for (uint256 i = 0; i < locations.length; i++) {\\n            uint256 stake = uint256(_stake(_planetData(locations[i]))) *\\n                (DECIMALS_14);\\n            _acquire(sender, stake, locations[i], false);\\n            total += stake;\\n        }\\n        require(amount == total, \\\"INVALID_AMOUNT\\\");\\n        _stakingToken.transferFrom(sender, address(this), amount);\\n    }\\n\\n    function acquireViaFreeTokenTransferFrom(\\n        uint256 location,\\n        uint256 amount\\n    ) public {\\n        address sender = _msgSender();\\n        _acquire(sender, amount, location, true);\\n        _freeStakingToken.transferFrom(sender, address(this), amount);\\n    }\\n\\n    function acquireMultipleViaFreeTokenTransferFrom(\\n        uint256[] memory locations,\\n        uint256 amount\\n    ) public {\\n        address sender = _msgSender();\\n        uint256 total = 0;\\n        for (uint256 i = 0; i < locations.length; i++) {\\n            uint256 stake = uint256(_stake(_planetData(locations[i]))) *\\n                (DECIMALS_14);\\n            _acquire(sender, stake, locations[i], true);\\n            total += stake;\\n        }\\n        require(amount == total, \\\"INVALID_AMOUNT\\\");\\n        _freeStakingToken.transferFrom(sender, address(this), amount);\\n    }\\n\\n    function acquireViaNativeTokenAndStakingToken(\\n        uint256 location,\\n        uint256 amountToMint,\\n        uint256 tokenAmount\\n    ) public payable {\\n        // TODO permit\\n        address sender = msg.sender;\\n        _acquire(sender, amountToMint + tokenAmount, location, false);\\n        if (amountToMint > 0) {\\n            _stakingToken.mint{value: msg.value}(address(this), amountToMint);\\n        }\\n        if (tokenAmount > 0) {\\n            _stakingToken.transferFrom(sender, address(this), tokenAmount);\\n        }\\n    }\\n\\n    function acquireMultipleViaNativeTokenAndStakingToken(\\n        uint256[] memory locations,\\n        uint256 amountToMint,\\n        uint256 tokenAmount\\n    ) public payable {\\n        // TODO permit\\n        address sender = msg.sender;\\n        uint256 total = 0;\\n        for (uint256 i = 0; i < locations.length; i++) {\\n            uint256 stake = uint256(_stake(_planetData(locations[i]))) *\\n                (DECIMALS_14);\\n            _acquire(sender, stake, locations[i], false);\\n            total += stake;\\n        }\\n        require(amountToMint + tokenAmount == total, \\\"INVALID_AMOUNT\\\");\\n        _stakingToken.mint{value: msg.value}(address(this), amountToMint);\\n        _stakingToken.transferFrom(sender, address(this), tokenAmount);\\n    }\\n\\n    // ---------------------------------------------------------------------------------------------------------------\\n    // EXIT / WITHDRAWALS\\n    // ---------------------------------------------------------------------------------------------------------------\\n\\n    function exitFor(address owner, uint256 location) external {\\n        address operator = _msgSender();\\n        if (operator != owner) {\\n            require(_operators[owner][operator], \\\"NOT_AUTHORIZED_TO_SEND\\\");\\n        }\\n        _unsafe_exit_for(owner, location);\\n    }\\n\\n    function exitMultipleFor(\\n        address owner,\\n        uint256[] calldata locations\\n    ) external {\\n        address operator = _msgSender();\\n        if (operator != owner) {\\n            require(_operators[owner][operator], \\\"NOT_AUTHORIZED_TO_SEND\\\");\\n        }\\n        uint256 numLocations = locations.length;\\n        for (uint256 i = 0; i < numLocations; i++) {\\n            _unsafe_exit_for(owner, locations[i]);\\n        }\\n    }\\n\\n    function fetchAndWithdrawFor(\\n        address owner,\\n        uint256[] calldata locations\\n    ) external {\\n        _fetchAndWithdrawFor(owner, locations);\\n    }\\n\\n    function balanceToWithdraw(address owner) external view returns (uint256) {\\n        return _stakeReadyToBeWithdrawn[owner];\\n    }\\n\\n    function withdrawFor(address owner) external {\\n        uint256 amount = _stakeReadyToBeWithdrawn[owner];\\n        _unsafe_withdrawAll(owner, amount);\\n    }\\n}\\n\",\"keccak256\":\"0xeb538dcc4e585c88f0434c9935fe6d9636ca11e343953d343d91eeed457dc306\",\"license\":\"AGPL-3.0\"},\"project/src/outerspace/interfaces/IOnStakeChange.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.9;\\n\\ninterface IOnStakeChange {\\n    function add(address account, uint256 amount) external;\\n\\n    function remove(address account, uint256 amount) external;\\n\\n    function move(address from, address to, uint256 amount) external;\\n}\\n\",\"keccak256\":\"0x41097f8a11e2c9f63b33392a0c87e880e9f19678d2259e84d2fa7388a665c640\",\"license\":\"AGPL-3.0\"},\"project/src/outerspace/interfaces/IOuterSpaceStaking.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.9;\\n\\nimport \\\"../types/ImportingOuterSpaceTypes.sol\\\";\\n\\ninterface IOuterSpaceStaking is ImportingOuterSpaceTypes {\\n    function onTokenTransfer(\\n        address,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bool);\\n\\n    function onTokenPaidFor(\\n        address,\\n        address forAddress,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bool);\\n\\n    function acquireViaTransferFrom(uint256 location, uint256 amount) external;\\n\\n    function acquireViaFreeTokenTransferFrom(\\n        uint256 location,\\n        uint256 amount\\n    ) external;\\n\\n    function acquireViaNativeTokenAndStakingToken(\\n        uint256 location,\\n        uint256 amountToMint,\\n        uint256 tokenAmount\\n    ) external payable;\\n\\n    function acquireMultipleViaNativeTokenAndStakingToken(\\n        uint256[] memory locations,\\n        uint256 amountToMint,\\n        uint256 tokenAmount\\n    ) external payable;\\n\\n    function exitFor(address owner, uint256 location) external;\\n\\n    function exitMultipleFor(\\n        address owner,\\n        uint256[] calldata locations\\n    ) external;\\n\\n    function fetchAndWithdrawFor(\\n        address owner,\\n        uint256[] calldata locations\\n    ) external;\\n\\n    function balanceToWithdraw(address owner) external view returns (uint256);\\n\\n    function withdrawFor(address owner) external;\\n}\\n\",\"keccak256\":\"0xdf5f1d125a9cfd7df46a8fbb2d0a89fa39ce6d1c4ff9159ec0af44ea0ffa53ed\",\"license\":\"AGPL-3.0\"},\"project/src/outerspace/types/ImportingOuterSpaceTypes.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../interfaces/IOnStakeChange.sol\\\";\\n\\ninterface ImportingOuterSpaceTypes {\\n    // front running protection : _frontruunningDelay / 2 slots\\n    struct InFlight {\\n        uint32 flying;\\n        uint32 destroyed;\\n        // STORE last attack too, to compute combined attack on it ? uint128 is plainty enough\\n    }\\n\\n    // TODO remove\\n    // struct Account {\\n    //     // TODO add more info\\n    //     // stake for example ? => coild it be used by staking ?\\n    //     // numPlanets ?\\n    //     // numSpaceships ? => probably too much ?\\n    //     uint64 totalProduction;\\n    //     uint64 productionDebt;\\n    // }\\n\\n    struct Discovered {\\n        uint32 minX;\\n        uint32 maxX;\\n        uint32 minY;\\n        uint32 maxY;\\n    }\\n\\n    // TODO split in 2 structs ? PlanetOwnership and PlanetState ?\\n    struct Planet {\\n        address owner;\\n        uint40 ownershipStartTime; // ~ 34865 years, should be enough :)\\n        uint40 exitStartTime; // ~ 34865 years, should be enough :)\\n        // TODO uint16 ?\\n        ///\\n        uint32 numSpaceships; // uint31 + first bit => active // TODO use bool active ?\\n        uint40 lastUpdated; // ~ 34865 years, should be enough :)\\n        int40 travelingUpkeep; // decrease per _upkeepProductionDecreaseRatePer10000th  * production\\n        uint32 overflow;\\n        // bool active; // TODO ?\\n        // bool exiting; // TODO ?\\n    }\\n\\n    struct Fleet {\\n        address owner;\\n        uint40 launchTime; // ~ 34865 years, should be enough :)\\n        uint32 quantity; // TODO? first bit = done? to keep quantity value on-chain post resolution, actually not needed, can be given in the hash\\n        uint24 futureExtraProduction;\\n        address defender;\\n        uint40 arrivalTime;\\n        uint32 defenderLoss;\\n        bool planetActive;\\n        bool victory;\\n        // we got 24bit more to store if needed\\n        // operator ? // signer ?\\n    }\\n\\n    struct FleetData {\\n        bool arrived;\\n        address owner;\\n        uint40 launchTime;\\n        uint32 quantity;\\n        uint64 flyingAtLaunch; // can be more than quantity if multiple fleet were launched around the same time from the same planet\\n        uint64 destroyedAtLaunch;\\n        address defender;\\n        uint40 arrivalTime;\\n        uint32 defenderLoss;\\n        bool planetActive;\\n        bool victory;\\n    }\\n\\n    struct PlanetStats {\\n        int8 subX;\\n        int8 subY;\\n        uint32 stake;\\n        uint16 production;\\n        uint16 attack;\\n        uint16 defense;\\n        uint16 speed;\\n        uint16 natives;\\n    }\\n\\n    struct ExternalPlanet {\\n        address owner;\\n        uint40 ownershipStartTime; // ~ 34865 years, should be enough :)\\n        uint40 exitStartTime; // ~ 34865 years, should be enough :)\\n        uint32 numSpaceships;\\n        uint32 overflow;\\n        uint40 lastUpdated; // ~ 34865 years, should be enough :)\\n        bool active;\\n        // bool exiting;\\n        uint256 reward;\\n    }\\n\\n    struct FleetLaunch {\\n        address fleetSender;\\n        address fleetOwner;\\n        uint256 from;\\n        uint32 quantity;\\n        bytes32 toHash;\\n    }\\n    struct FleetResolution {\\n        uint256 from;\\n        uint256 to;\\n        uint256 distance;\\n        uint256 arrivalTimeWanted;\\n        bool gift;\\n        address specific;\\n        bytes32 secret;\\n        address fleetSender; // does not work ?\\n        address operator; // should be saved ?\\n    }\\n\\n    struct AccumulatedAttack {\\n        address target;\\n        uint32 numAttackSpent;\\n        uint32 damageCausedSoFar;\\n        uint16 averageAttackPower;\\n    }\\n}\\n\",\"keccak256\":\"0x3906d94bc2fb81e50d0de6cb215feca2eed8c9cc257c00d8f014af535f009777\",\"license\":\"AGPL-3.0\"}},\"version\":1}",
  "storageLayout": {
    "storage": [
      {
        "astId": 11256,
        "contract": "project/src/outerspace/facets/OuterSpaceStakingFacet.sol:OuterSpaceStakingFacet",
        "label": "_planets",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_uint256,t_struct(Planet)18386_storage)"
      },
      {
        "astId": 11261,
        "contract": "project/src/outerspace/facets/OuterSpaceStakingFacet.sol:OuterSpaceStakingFacet",
        "label": "_fleets",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_uint256,t_struct(Fleet)18405_storage)"
      },
      {
        "astId": 11265,
        "contract": "project/src/outerspace/facets/OuterSpaceStakingFacet.sol:OuterSpaceStakingFacet",
        "label": "_stakeReadyToBeWithdrawn",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 11271,
        "contract": "project/src/outerspace/facets/OuterSpaceStakingFacet.sol:OuterSpaceStakingFacet",
        "label": "_operators",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_address,t_mapping(t_address,t_bool))"
      },
      {
        "astId": 11278,
        "contract": "project/src/outerspace/facets/OuterSpaceStakingFacet.sol:OuterSpaceStakingFacet",
        "label": "_inFlight",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_uint256,t_mapping(t_uint256,t_struct(InFlight)18362_storage))"
      },
      {
        "astId": 11281,
        "contract": "project/src/outerspace/facets/OuterSpaceStakingFacet.sol:OuterSpaceStakingFacet",
        "label": "_discovered",
        "offset": 0,
        "slot": "5",
        "type": "t_struct(Discovered)18371_storage"
      },
      {
        "astId": 11285,
        "contract": "project/src/outerspace/facets/OuterSpaceStakingFacet.sol:OuterSpaceStakingFacet",
        "label": "_prevRewardIds",
        "offset": 0,
        "slot": "6",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 11289,
        "contract": "project/src/outerspace/facets/OuterSpaceStakingFacet.sol:OuterSpaceStakingFacet",
        "label": "_rewards",
        "offset": 0,
        "slot": "7",
        "type": "t_mapping(t_uint256,t_uint256)"
      },
      {
        "astId": 11295,
        "contract": "project/src/outerspace/facets/OuterSpaceStakingFacet.sol:OuterSpaceStakingFacet",
        "label": "_rewardsToWithdraw",
        "offset": 0,
        "slot": "8",
        "type": "t_mapping(t_address,t_mapping(t_uint256,t_bool))"
      },
      {
        "astId": 11304,
        "contract": "project/src/outerspace/facets/OuterSpaceStakingFacet.sol:OuterSpaceStakingFacet",
        "label": "_attacks",
        "offset": 0,
        "slot": "9",
        "type": "t_mapping(t_uint256,t_mapping(t_address,t_mapping(t_uint256,t_struct(AccumulatedAttack)18501_storage)))"
      },
      {
        "astId": 11308,
        "contract": "project/src/outerspace/facets/OuterSpaceStakingFacet.sol:OuterSpaceStakingFacet",
        "label": "_freeStakeReadyToBeWithdrawn",
        "offset": 0,
        "slot": "10",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 11312,
        "contract": "project/src/outerspace/facets/OuterSpaceStakingFacet.sol:OuterSpaceStakingFacet",
        "label": "_planetFlagged",
        "offset": 0,
        "slot": "11",
        "type": "t_mapping(t_uint256,t_uint256)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_int40": {
        "encoding": "inplace",
        "label": "int40",
        "numberOfBytes": "5"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_address,t_mapping(t_address,t_bool))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => bool))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_bool)"
      },
      "t_mapping(t_address,t_mapping(t_uint256,t_bool))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(uint256 => bool))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint256,t_bool)"
      },
      "t_mapping(t_address,t_mapping(t_uint256,t_struct(AccumulatedAttack)18501_storage))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(uint256 => struct ImportingOuterSpaceTypes.AccumulatedAttack))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint256,t_struct(AccumulatedAttack)18501_storage)"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_bool)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_uint256,t_mapping(t_address,t_mapping(t_uint256,t_struct(AccumulatedAttack)18501_storage)))": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => mapping(address => mapping(uint256 => struct ImportingOuterSpaceTypes.AccumulatedAttack)))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_mapping(t_uint256,t_struct(AccumulatedAttack)18501_storage))"
      },
      "t_mapping(t_uint256,t_mapping(t_uint256,t_struct(InFlight)18362_storage))": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => mapping(uint256 => struct ImportingOuterSpaceTypes.InFlight))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint256,t_struct(InFlight)18362_storage)"
      },
      "t_mapping(t_uint256,t_struct(AccumulatedAttack)18501_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct ImportingOuterSpaceTypes.AccumulatedAttack)",
        "numberOfBytes": "32",
        "value": "t_struct(AccumulatedAttack)18501_storage"
      },
      "t_mapping(t_uint256,t_struct(Fleet)18405_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct ImportingOuterSpaceTypes.Fleet)",
        "numberOfBytes": "32",
        "value": "t_struct(Fleet)18405_storage"
      },
      "t_mapping(t_uint256,t_struct(InFlight)18362_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct ImportingOuterSpaceTypes.InFlight)",
        "numberOfBytes": "32",
        "value": "t_struct(InFlight)18362_storage"
      },
      "t_mapping(t_uint256,t_struct(Planet)18386_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct ImportingOuterSpaceTypes.Planet)",
        "numberOfBytes": "32",
        "value": "t_struct(Planet)18386_storage"
      },
      "t_mapping(t_uint256,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_struct(AccumulatedAttack)18501_storage": {
        "encoding": "inplace",
        "label": "struct ImportingOuterSpaceTypes.AccumulatedAttack",
        "members": [
          {
            "astId": 18494,
            "contract": "project/src/outerspace/facets/OuterSpaceStakingFacet.sol:OuterSpaceStakingFacet",
            "label": "target",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 18496,
            "contract": "project/src/outerspace/facets/OuterSpaceStakingFacet.sol:OuterSpaceStakingFacet",
            "label": "numAttackSpent",
            "offset": 20,
            "slot": "0",
            "type": "t_uint32"
          },
          {
            "astId": 18498,
            "contract": "project/src/outerspace/facets/OuterSpaceStakingFacet.sol:OuterSpaceStakingFacet",
            "label": "damageCausedSoFar",
            "offset": 24,
            "slot": "0",
            "type": "t_uint32"
          },
          {
            "astId": 18500,
            "contract": "project/src/outerspace/facets/OuterSpaceStakingFacet.sol:OuterSpaceStakingFacet",
            "label": "averageAttackPower",
            "offset": 28,
            "slot": "0",
            "type": "t_uint16"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(Discovered)18371_storage": {
        "encoding": "inplace",
        "label": "struct ImportingOuterSpaceTypes.Discovered",
        "members": [
          {
            "astId": 18364,
            "contract": "project/src/outerspace/facets/OuterSpaceStakingFacet.sol:OuterSpaceStakingFacet",
            "label": "minX",
            "offset": 0,
            "slot": "0",
            "type": "t_uint32"
          },
          {
            "astId": 18366,
            "contract": "project/src/outerspace/facets/OuterSpaceStakingFacet.sol:OuterSpaceStakingFacet",
            "label": "maxX",
            "offset": 4,
            "slot": "0",
            "type": "t_uint32"
          },
          {
            "astId": 18368,
            "contract": "project/src/outerspace/facets/OuterSpaceStakingFacet.sol:OuterSpaceStakingFacet",
            "label": "minY",
            "offset": 8,
            "slot": "0",
            "type": "t_uint32"
          },
          {
            "astId": 18370,
            "contract": "project/src/outerspace/facets/OuterSpaceStakingFacet.sol:OuterSpaceStakingFacet",
            "label": "maxY",
            "offset": 12,
            "slot": "0",
            "type": "t_uint32"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(Fleet)18405_storage": {
        "encoding": "inplace",
        "label": "struct ImportingOuterSpaceTypes.Fleet",
        "members": [
          {
            "astId": 18388,
            "contract": "project/src/outerspace/facets/OuterSpaceStakingFacet.sol:OuterSpaceStakingFacet",
            "label": "owner",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 18390,
            "contract": "project/src/outerspace/facets/OuterSpaceStakingFacet.sol:OuterSpaceStakingFacet",
            "label": "launchTime",
            "offset": 20,
            "slot": "0",
            "type": "t_uint40"
          },
          {
            "astId": 18392,
            "contract": "project/src/outerspace/facets/OuterSpaceStakingFacet.sol:OuterSpaceStakingFacet",
            "label": "quantity",
            "offset": 25,
            "slot": "0",
            "type": "t_uint32"
          },
          {
            "astId": 18394,
            "contract": "project/src/outerspace/facets/OuterSpaceStakingFacet.sol:OuterSpaceStakingFacet",
            "label": "futureExtraProduction",
            "offset": 29,
            "slot": "0",
            "type": "t_uint24"
          },
          {
            "astId": 18396,
            "contract": "project/src/outerspace/facets/OuterSpaceStakingFacet.sol:OuterSpaceStakingFacet",
            "label": "defender",
            "offset": 0,
            "slot": "1",
            "type": "t_address"
          },
          {
            "astId": 18398,
            "contract": "project/src/outerspace/facets/OuterSpaceStakingFacet.sol:OuterSpaceStakingFacet",
            "label": "arrivalTime",
            "offset": 20,
            "slot": "1",
            "type": "t_uint40"
          },
          {
            "astId": 18400,
            "contract": "project/src/outerspace/facets/OuterSpaceStakingFacet.sol:OuterSpaceStakingFacet",
            "label": "defenderLoss",
            "offset": 25,
            "slot": "1",
            "type": "t_uint32"
          },
          {
            "astId": 18402,
            "contract": "project/src/outerspace/facets/OuterSpaceStakingFacet.sol:OuterSpaceStakingFacet",
            "label": "planetActive",
            "offset": 29,
            "slot": "1",
            "type": "t_bool"
          },
          {
            "astId": 18404,
            "contract": "project/src/outerspace/facets/OuterSpaceStakingFacet.sol:OuterSpaceStakingFacet",
            "label": "victory",
            "offset": 30,
            "slot": "1",
            "type": "t_bool"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(InFlight)18362_storage": {
        "encoding": "inplace",
        "label": "struct ImportingOuterSpaceTypes.InFlight",
        "members": [
          {
            "astId": 18359,
            "contract": "project/src/outerspace/facets/OuterSpaceStakingFacet.sol:OuterSpaceStakingFacet",
            "label": "flying",
            "offset": 0,
            "slot": "0",
            "type": "t_uint32"
          },
          {
            "astId": 18361,
            "contract": "project/src/outerspace/facets/OuterSpaceStakingFacet.sol:OuterSpaceStakingFacet",
            "label": "destroyed",
            "offset": 4,
            "slot": "0",
            "type": "t_uint32"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(Planet)18386_storage": {
        "encoding": "inplace",
        "label": "struct ImportingOuterSpaceTypes.Planet",
        "members": [
          {
            "astId": 18373,
            "contract": "project/src/outerspace/facets/OuterSpaceStakingFacet.sol:OuterSpaceStakingFacet",
            "label": "owner",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 18375,
            "contract": "project/src/outerspace/facets/OuterSpaceStakingFacet.sol:OuterSpaceStakingFacet",
            "label": "ownershipStartTime",
            "offset": 20,
            "slot": "0",
            "type": "t_uint40"
          },
          {
            "astId": 18377,
            "contract": "project/src/outerspace/facets/OuterSpaceStakingFacet.sol:OuterSpaceStakingFacet",
            "label": "exitStartTime",
            "offset": 25,
            "slot": "0",
            "type": "t_uint40"
          },
          {
            "astId": 18379,
            "contract": "project/src/outerspace/facets/OuterSpaceStakingFacet.sol:OuterSpaceStakingFacet",
            "label": "numSpaceships",
            "offset": 0,
            "slot": "1",
            "type": "t_uint32"
          },
          {
            "astId": 18381,
            "contract": "project/src/outerspace/facets/OuterSpaceStakingFacet.sol:OuterSpaceStakingFacet",
            "label": "lastUpdated",
            "offset": 4,
            "slot": "1",
            "type": "t_uint40"
          },
          {
            "astId": 18383,
            "contract": "project/src/outerspace/facets/OuterSpaceStakingFacet.sol:OuterSpaceStakingFacet",
            "label": "travelingUpkeep",
            "offset": 9,
            "slot": "1",
            "type": "t_int40"
          },
          {
            "astId": 18385,
            "contract": "project/src/outerspace/facets/OuterSpaceStakingFacet.sol:OuterSpaceStakingFacet",
            "label": "overflow",
            "offset": 14,
            "slot": "1",
            "type": "t_uint32"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint16": {
        "encoding": "inplace",
        "label": "uint16",
        "numberOfBytes": "2"
      },
      "t_uint24": {
        "encoding": "inplace",
        "label": "uint24",
        "numberOfBytes": "3"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint32": {
        "encoding": "inplace",
        "label": "uint32",
        "numberOfBytes": "4"
      },
      "t_uint40": {
        "encoding": "inplace",
        "label": "uint40",
        "numberOfBytes": "5"
      }
    }
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "argsData": "0x000000000000000000000000f2795fc18ee47763bd6d712accb40953b7b0373100000000000000000000000040b7584f6f94d720ccaad8c6d6acad5fe929d56400000000000000000000000044faf6adec806215d53b1c75066b733a8c40bc77cce77b122615b6093c0df0c7392bec6f537eb7a0595c337a573ee6d96d1107c8000000000000000000000000000000000000000000000000000000000000a8c00000000000000000000000000000000000000000000000000000000000001c20000000000000000000000000000000000000000000000000000000000003f48000000000000000000000000000000000000000000000000000000000000186a000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000708000000000000000000000000000000000000000000000000000000000003f4800000000000000000000000000000000000000000000000000000000000001388000000000000000000000000000000000000000000000000000000000007a120000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000007d00064008200aa00c800f0010e012c014a014a017201900212029e032003a204b000000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000069b40fc20000000000000000000000000000000000000000000000000000000069b56142",
  "linkedData": {
    "stakingToken": "0xf2795fc18ee47763bd6d712accb40953b7b03731",
    "freeStakingToken": "0x40b7584f6f94d720ccaad8c6d6acad5fe929d564",
    "allianceRegistry": "0x44faf6adec806215d53b1c75066b733a8c40bc77",
    "genesis": "0xcce77b122615b6093c0df0c7392bec6f537eb7a0595c337a573ee6d96d1107c8",
    "resolveWindow": 43200,
    "timePerDistance": 7200,
    "exitDuration": 259200,
    "acquireNumSpaceships": 100000,
    "productionSpeedUp": 1,
    "frontrunningDelay": 1800,
    "productionCapAsDuration": 259200,
    "upkeepProductionDecreaseRatePer10000th": 5000,
    "fleetSizeFactor6": 500000,
    "initialSpaceExpansion": 12,
    "expansionDelta": 6,
    "giftTaxPer10000": 2000,
    "stakeRange": "0x0064008200aa00c800f0010e012c014a014a017201900212029e032003a204b0",
    "stakeMultiplier10000th": 100,
    "bootstrapSessionEndTime": 1773408194,
    "infinityStartTime": 1773494594,
    "chainGenesisHash": "",
    "deploymentTimestamp": 1770816194
  },
  "transaction": {
    "nonce": "0x33",
    "hash": "0x23ccdae7b01f16ce7c75c90cb402e9cdc197f60c0d12753ee303857fe8c96009",
    "origin": "0x61c461ecc993aadeb7e4b47e96d1b8cc37314b20"
  },
  "receipt": {
    "blockHash": "0x852e964accbe81cd49c72de66ed6d3f52077a84bb29b8f602347c06390eeaff1",
    "blockNumber": "0x10b8556",
    "transactionIndex": "0x1"
  }
}