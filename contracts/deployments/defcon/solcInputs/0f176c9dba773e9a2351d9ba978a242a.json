{
  "language": "Solidity",
  "sources": {
    "src/agent/PaymentGateway.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract PaymentGateway {\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event Payment(address indexed payer, uint256 amount, bool refund);\n\n    address public owner;\n\n    constructor(address firstOwner) {\n        owner = firstOwner;\n        emit OwnershipTransferred(address(0), firstOwner);\n    }\n\n    receive() external payable {\n        emit Payment(msg.sender, msg.value, false);\n    }\n\n    // sendETHandRegisterDelegate(address delegate) external payable {\n    //     emit Payment(msg.sender, delegate, msg.value, false);\n    // }\n\n    function transferOwnership(address newOwner) external {\n        require(msg.sender == owner, \"NOT_ALLOWED\");\n        owner = newOwner;\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n\n    function withdrawForRefund(address payable to, uint256 amount) external {\n        require(msg.sender == owner, \"NOT_ALLOWED\");\n        to.transfer(amount);\n        emit Payment(to, amount, true);\n    }\n\n    function withdraw(address payable to, uint256 amount) external {\n        require(msg.sender == owner, \"NOT_ALLOWED\");\n        to.transfer(amount);\n    }\n\n    function withdrawAllETH(address payable to) external {\n        require(msg.sender == owner, \"NOT_ALLOWED\");\n        to.transfer(address(this).balance);\n    }\n\n    function withdrawTokens(IERC20[] calldata tokens, address to) external {\n        require(msg.sender == owner, \"NOT_ALLOWED\");\n        for (uint256 i = 0; i < tokens.length; i++) {\n            uint256 balance = tokens[i].balanceOf(address(this));\n            tokens[i].transfer(to, balance);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "src/utils/Distributor.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\ncontract Distributor {\n    using SafeERC20 for IERC20;\n\n    function distributeVariousAmountsOfTokenAndETH(\n        IERC20 token,\n        address payable[] calldata tos,\n        uint256[] calldata tokenAmounts,\n        uint256[] calldata etherAmounts\n    ) external payable returns (bool) {\n        uint256 totalETHSent = 0;\n        require(tos.length == tokenAmounts.length, \"TOKEN_NOT_SAME_LENGTH\");\n        require(tos.length == etherAmounts.length, \"ETH_NOT_SAME_LENGTH\");\n        for (uint256 i = 0; i < tos.length; i++) {\n            if (tokenAmounts[i] != 0) {\n                token.safeTransferFrom(msg.sender, tos[i], tokenAmounts[i]);\n            }\n            if (etherAmounts[i] != 0) {\n                tos[i].transfer(etherAmounts[i]);\n                totalETHSent += etherAmounts[i];\n            }\n        }\n        require(msg.value == totalETHSent, \"INVALID_MSG_VALUE\");\n        return true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "src/l1/GenericL1ERC20Token.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../base/erc20/UsingERC20Base.sol\";\nimport \"../base/erc20/WithPermitAndFixedDomain.sol\";\n\n// TODO bridging\ncontract GenericL1ERC20Token is UsingERC20Base, WithPermitAndFixedDomain {\n    using Address for address;\n\n    address internal immutable _gateway; // TODO proper bridging\n    address internal immutable _l2Contract; // TODO proper bridging\n\n    constructor(address gateway, address l2Contract) WithPermitAndFixedDomain(\"1\") {\n        _gateway = gateway;\n        _l2Contract = l2Contract;\n    }\n\n    string public constant symbol = \"XCQT\"; //xdai example\n\n    function name() public pure override returns (string memory) {\n        return \"Conquest's Token For xdai\";\n    }\n\n    // ----------------------------------------------------------------------\n    // TODO remove\n    // ----------------------------------------------------------------------\n    mapping(address => bool) public authorized;\n    bool public requireAuthorization;\n    mapping(address => bool) public touched;\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override {\n        require(!requireAuthorization || authorized[from] || authorized[to] || !touched[to], \"NOT_AUTHORIZED_TRANSFER\");\n        super._transfer(from, to, amount);\n        touched[to] = true;\n    }\n\n    function anyNotAuthorized(address[] memory accounts) external view returns (bool) {\n        for (uint256 i = 0; i < accounts.length; i++) {\n            if (!authorized[accounts[i]]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function authorize(address[] memory accounts, bool auth) public {\n        require(msg.sender == _admin(), \"NOT_ADMIN\");\n        for (uint256 i = 0; i < accounts.length; i++) {\n            authorized[accounts[i]] = auth;\n        }\n    }\n\n    function enableRequireAuthorization(address[] calldata accounts) external {\n        require(msg.sender == _admin(), \"NOT_ADMIN\");\n        setRequireAuthorization(true);\n        authorize(accounts, true);\n    }\n\n    function setRequireAuthorization(bool req) public {\n        require(msg.sender == _admin(), \"NOT_ADMIN\");\n        requireAuthorization = req;\n    }\n\n    function _admin() internal view returns (address adminAddress) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            adminAddress := sload(0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103)\n        }\n    }\n    // ----------------------------------------------------------------------\n}\n"
    },
    "src/base/erc20/UsingERC20Base.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"./ERC20BaseInternal.sol\";\nimport \"../../libraries/Constants.sol\";\n\ninterface IBurnReceiver {\n    function onTokenBurn(\n        address,\n        uint256,\n        bytes calldata\n    ) external returns (bool);\n}\n\ninterface ITransferReceiver {\n    function onTokenTransfer(\n        address,\n        uint256,\n        bytes calldata\n    ) external returns (bool);\n}\n\ninterface IPaidForReceiver {\n    function onTokenPaidFor(\n        address payer,\n        address forAddress,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n}\n\ninterface IApprovalReceiver {\n    function onTokenApproval(\n        address,\n        uint256,\n        bytes calldata\n    ) external returns (bool);\n}\n\nabstract contract UsingERC20Base is IERC20, ERC20BaseInternal {\n    using Address for address;\n\n    uint256 internal _totalSupply;\n    mapping(address => uint256) internal _balances;\n    mapping(address => mapping(address => uint256)) internal _allowances;\n\n    function _internal_totalSupply() internal view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function totalSupply() external view override returns (uint256) {\n        return _internal_totalSupply();\n    }\n\n    function balanceOf(address owner) external view override returns (uint256) {\n        return _balances[owner];\n    }\n\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        if (owner == address(this)) {\n            // see transferFrom: address(this) allows anyone\n            return Constants.UINT256_MAX;\n        }\n        return _allowances[owner][spender];\n    }\n\n    function decimals() external pure virtual returns (uint8) {\n        return uint8(18);\n    }\n\n    function transfer(address to, uint256 amount) external override returns (bool) {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function transferAlongWithETH(address payable to, uint256 amount) external payable returns (bool) {\n        _transfer(msg.sender, to, amount);\n        to.transfer(msg.value);\n        return true;\n    }\n\n    function distributeAlongWithETH(address payable[] calldata tos, uint256 totalAmount)\n        external\n        payable\n        returns (bool)\n    {\n        uint256 val = msg.value / tos.length;\n        require(msg.value == val * tos.length, \"INVALID_MSG_VALUE\");\n        uint256 amount = totalAmount / tos.length;\n        require(totalAmount == amount * tos.length, \"INVALID_TOTAL_AMOUNT\");\n        for (uint256 i = 0; i < tos.length; i++) {\n            _transfer(msg.sender, tos[i], amount);\n            tos[i].transfer(val);\n        }\n        return true;\n    }\n\n    function distributeVariousAmountsAlongWithETH(address payable[] calldata tos, uint256[] calldata amounts)\n        external\n        payable\n        returns (bool)\n    {\n        uint256 val = msg.value / tos.length;\n        require(msg.value == val * tos.length, \"INVALID_MSG_VALUE\");\n        require(tos.length == amounts.length, \"NOT_SAME_LENGTH\");\n        for (uint256 i = 0; i < tos.length; i++) {\n            _transfer(msg.sender, tos[i], amounts[i]);\n            tos[i].transfer(val);\n        }\n        return true;\n    }\n\n    function distributeVariousAmountsOfTokenAndETH(\n        address payable[] calldata tos,\n        uint256[] calldata tokenAmounts,\n        uint256[] calldata etherAmounts\n    ) external payable returns (bool) {\n        uint256 totalETHSent = 0;\n        require(tos.length == tokenAmounts.length, \"TOKEN_NOT_SAME_LENGTH\");\n        require(tos.length == etherAmounts.length, \"ETH_NOT_SAME_LENGTH\");\n        for (uint256 i = 0; i < tos.length; i++) {\n            if (tokenAmounts[i] != 0) {\n                _transfer(msg.sender, tos[i], tokenAmounts[i]);\n            }\n            if (etherAmounts[i] != 0) {\n                tos[i].transfer(etherAmounts[i]);\n                totalETHSent += etherAmounts[i];\n            }\n        }\n        require(msg.value == totalETHSent, \"INVALID_MSG_VALUE\");\n        return true;\n    }\n\n    function transferAndCall(\n        address to,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool) {\n        _transfer(msg.sender, to, amount);\n        return ITransferReceiver(to).onTokenTransfer(msg.sender, amount, data);\n    }\n\n    function transferFromAndCall(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool) {\n        _transferFrom(from, to, amount);\n        return ITransferReceiver(to).onTokenTransfer(from, amount, data);\n    }\n\n    function payForAndCall(\n        address forAddress,\n        address to,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool) {\n        _transfer(msg.sender, to, amount);\n        return IPaidForReceiver(to).onTokenPaidFor(msg.sender, forAddress, amount, data);\n    }\n\n    // TODO ?\n    // function transferFromForAndCall(\n    //     address forAddress,\n    //     address from,\n    //     address to,\n    //     uint256 amount,\n    //     bytes calldata data\n    // ) external returns (bool) {\n    //     _transferFrom(from, to, amount);\n    //     return ITransferForReceiver(to).onTokenTransferFor(from, forAddress, amount, data);\n    // }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external override returns (bool) {\n        _transferFrom(from, to, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        // TODO support metatx ?\n        _approveFor(msg.sender, spender, amount);\n        return true;\n    }\n\n    function approveAndCall(\n        address spender,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool) {\n        _approveFor(msg.sender, spender, amount);\n        return IApprovalReceiver(spender).onTokenApproval(msg.sender, amount, data);\n    }\n\n    function _approveFor(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal override {\n        require(owner != address(0) && spender != address(0), \"INVALID_ZERO_ADDRESS\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        // anybody can transfer from this\n        // this allow mintAndApprovedCall without gas overhead\n        if (msg.sender != from && from != address(this)) {\n            uint256 currentAllowance = _allowances[from][msg.sender];\n            if (currentAllowance != Constants.UINT256_MAX) {\n                // save gas when allowance is maximal by not reducing it (see https://github.com/ethereum/EIPs/issues/717)\n                require(currentAllowance >= amount, \"NOT_AUTHOIZED_ALLOWANCE\");\n                _allowances[from][msg.sender] = currentAllowance - amount;\n            }\n        }\n        _transfer(from, to, amount);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(to != address(0), \"INVALID_ZERO_ADDRESS\");\n        require(to != address(this), \"INVALID_THIS_ADDRESS\");\n        uint256 currentBalance = _balances[from];\n        require(currentBalance >= amount, \"NOT_ENOUGH_TOKENS\");\n        _balances[from] = currentBalance - amount;\n        _balances[to] += amount;\n        emit Transfer(from, to, amount);\n    }\n\n    function _transferAllIfAny(address from, address to) internal {\n        uint256 balanceLeft = _balances[from];\n        if (balanceLeft > 0) {\n            _balances[from] = 0;\n            _balances[to] += balanceLeft;\n            emit Transfer(from, to, balanceLeft);\n        }\n    }\n\n    function _mint(address to, uint256 amount) internal override {\n        _totalSupply += amount;\n        _balances[to] += amount;\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burnFrom(address from, uint256 amount) internal override {\n        uint256 currentBalance = _balances[from];\n        require(currentBalance >= amount, \"NOT_ENOUGH_TOKENS\");\n        _balances[from] = currentBalance - amount;\n        _totalSupply -= amount;\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "src/base/erc20/WithPermitAndFixedDomain.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"./ERC20BaseInternal.sol\";\nimport \"../../interfaces/IERC2612Standalone.sol\";\n\nabstract contract WithPermitAndFixedDomain is ERC20BaseInternal, IERC2612Standalone {\n    bytes32 internal constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    bytes32 public immutable override DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) internal _nonces;\n\n    constructor(string memory version) {\n        if (bytes(version).length == 0) {\n            version = \"1\";\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,address verifyingContract)\"),\n                keccak256(bytes(name())),\n                keccak256(bytes(version)),\n                address(this)\n            )\n        );\n    }\n\n    function nonces(address owner) external view override returns (uint256) {\n        return _nonces[owner];\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(owner != address(0), \"INVALID_ZERO_ADDRESS\");\n\n        uint256 currentNonce = _nonces[owner];\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, currentNonce, deadline))\n            )\n        );\n        require(owner == ecrecover(digest, v, r, s), \"INVALID_SIGNATURE\");\n        require(deadline == 0 || block.timestamp <= deadline, \"TOO_LATE\");\n\n        _nonces[owner] = currentNonce + 1;\n        _approveFor(owner, spender, value);\n    }\n}\n"
    },
    "src/base/erc20/ERC20BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nabstract contract ERC20BaseInternal {\n    function _approveFor(\n        address owner,\n        address target,\n        uint256 amount\n    ) internal virtual;\n\n    function name() public virtual returns (string memory);\n\n    function _mint(address to, uint256 amount) internal virtual;\n\n    function _burnFrom(address from, uint256 amount) internal virtual;\n\n    function _internal_totalSupply() internal view virtual returns (uint256);\n}\n"
    },
    "src/libraries/Constants.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity 0.8.9;\n\nlibrary Constants {\n    uint256 internal constant UINT256_MAX = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n    uint256 internal constant DECIMALS_18 = 1000000000000000000;\n    uint256 internal constant DECIMALS_14 = 100000000000000;\n}\n"
    },
    "src/interfaces/IERC2612Standalone.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity 0.8.9;\n\ninterface IERC2612Standalone {\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function nonces(address owner) external view returns (uint256);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "src/conquest_token/PlayToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../base/erc20/UsingERC20Base.sol\";\nimport \"../base/erc20/WithPermitAndFixedDomain.sol\";\nimport \"hardhat-deploy/solc_0.8/proxy/Proxied.sol\";\nimport \"./PlayToken.sol\";\n\ncontract PlayToken is UsingERC20Base, WithPermitAndFixedDomain, Proxied {\n    uint256 internal constant DECIMALS_18 = 1000000000000000000;\n    uint256 public immutable numTokensPerNativeTokenAt18Decimals;\n\n    constructor(uint256 _numTokensPerNativeTokenAt18Decimals) WithPermitAndFixedDomain(\"1\") {\n        numTokensPerNativeTokenAt18Decimals = _numTokensPerNativeTokenAt18Decimals;\n        postUpgrade(numTokensPerNativeTokenAt18Decimals);\n    }\n\n    function postUpgrade(uint256) public proxied {}\n\n    string public constant symbol = \"PLAY\";\n\n    function name() public pure override returns (string memory) {\n        return \"Play\";\n    }\n\n    function mint(address to, uint256 amount) external payable {\n        require((msg.value * numTokensPerNativeTokenAt18Decimals) / DECIMALS_18 == amount, \"INVALID_AMOUNT\");\n        _mint(to, amount);\n    }\n\n    function burn(address payable to, uint256 amount) external {\n        _burnFrom(msg.sender, amount);\n        to.transfer((amount * DECIMALS_18) / numTokensPerNativeTokenAt18Decimals);\n    }\n}\n"
    },
    "hardhat-deploy/solc_0.8/proxy/Proxied.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract Proxied {\n    /// @notice to be used by initialisation / postUpgrade function so that only the proxy's admin can execute them\n    /// It also allows these functions to be called inside a contructor\n    /// even if the contract is meant to be used without proxy\n    modifier proxied() {\n        address proxyAdminAddress = _proxyAdmin();\n        // With hardhat-deploy proxies\n        // the proxyAdminAddress is zero only for the implementation contract\n        // if the implementation contract want to be used as a standalone/immutable contract\n        // it simply has to execute the `proxied` function\n        // This ensure the proxyAdminAddress is never zero post deployment\n        // And allow you to keep the same code for both proxied contract and immutable contract\n        if (proxyAdminAddress == address(0)) {\n            // ensure can not be called twice when used outside of proxy : no admin\n            // solhint-disable-next-line security/no-inline-assembly\n            assembly {\n                sstore(\n                    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103,\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n                )\n            }\n        } else {\n            require(msg.sender == proxyAdminAddress);\n        }\n        _;\n    }\n\n    modifier onlyProxyAdmin() {\n        require(msg.sender == _proxyAdmin(), \"NOT_AUTHORIZED\");\n        _;\n    }\n\n    function _proxyAdmin() internal view returns (address ownerAddress) {\n        // solhint-disable-next-line security/no-inline-assembly\n        assembly {\n            ownerAddress := sload(0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103)\n        }\n    }\n}\n"
    },
    "src/conquest_token/FreePlayToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../base/erc20/UsingERC20Base.sol\";\nimport \"../base/erc20/WithPermitAndFixedDomain.sol\";\nimport \"hardhat-deploy/solc_0.8/proxy/Proxied.sol\";\nimport \"./PlayToken.sol\";\n\ncontract FreePlayToken is UsingERC20Base, WithPermitAndFixedDomain, Proxied {\n    using Address for address;\n    using SafeERC20 for PlayToken;\n\n    uint256 internal constant DECIMALS_18 = 1000000000000000000;\n\n    event Burner(address burner, bool enabled);\n    event Minter(address burner, bool enabled);\n\n    PlayToken internal immutable _underlyingToken;\n\n    mapping(address => bool) public minters;\n    mapping(address => bool) public burners;\n\n    constructor(PlayToken underlyingToken) WithPermitAndFixedDomain(\"1\") {\n        _underlyingToken = underlyingToken;\n    }\n\n    string public constant symbol = \"FPLAY\";\n\n    function name() public pure override returns (string memory) {\n        return \"Free Play\";\n    }\n\n    function setBurner(address burner, bool enabled) external onlyProxyAdmin {\n        burners[burner] = enabled;\n        emit Burner(burner, enabled);\n    }\n\n    function setMinter(address burner, bool enabled) external onlyProxyAdmin {\n        minters[burner] = enabled;\n        emit Minter(burner, enabled);\n    }\n\n    // function onTokenTransfer(\n    //     address from,\n    //     uint256 amount,\n    //     bytes calldata data\n    // ) public returns (bool) {\n    //     require(msg.sender == address(_underlyingToken), \"INVALID_ERC20\");\n    //     require(minters[from], \"NOT_ALLOWED_MINTER\");\n\n    //     address to = abi.decode(data, (address));\n    //     _mint(to, amount);\n    //     return true;\n    // }\n\n    // function onTokenPaidFor(\n    //     address from,\n    //     address forAddress,\n    //     uint256 amount,\n    //     bytes calldata data\n    // ) external returns (bool) {\n    //     require(msg.sender == address(_underlyingToken), \"INVALID_ERC20\");\n    //     require(minters[from], \"NOT_ALLOWED_MINTER\");\n    //     _mint(forAddress, amount);\n    //     return true;\n    // }\n\n    function mintViaNativeToken(address to, uint256 amount) external payable {\n        require(minters[msg.sender], \"NOT_ALLOWED_MINTER\");\n        _underlyingToken.mint{value: msg.value}(address(this), amount);\n        _mint(to, amount);\n    }\n\n    function mintViaNativeTokenPlusSendExtraNativeTokens(address payable to, uint256 amount) external payable {\n        require(minters[msg.sender], \"NOT_ALLOWED_MINTER\");\n        uint256 valueExpected = (amount * DECIMALS_18) / _underlyingToken.numTokensPerNativeTokenAt18Decimals();\n        _underlyingToken.mint{value: valueExpected}(address(this), amount);\n        _mint(to, amount);\n        if (msg.value > valueExpected) {\n            to.transfer(msg.value - valueExpected);\n        }\n    }\n\n    function mintMultipleViaNativeTokenPlusSendExtraNativeTokens(\n        address payable[] calldata tos,\n        uint256[] calldata amounts,\n        uint256[] calldata nativeTokenAmounts\n    ) external payable {\n        require(minters[msg.sender], \"NOT_ALLOWED_MINTER\");\n        for (uint256 i = 0; i < tos.length; i++) {\n            uint256 valueExpected = (amounts[i] * DECIMALS_18) / _underlyingToken.numTokensPerNativeTokenAt18Decimals();\n            _underlyingToken.mint{value: valueExpected}(address(this), amounts[i]);\n            _mint(tos[i], amounts[i]);\n            if (nativeTokenAmounts[i] > 0) {\n                tos[i].transfer(nativeTokenAmounts[i]);\n            }\n        }\n    }\n\n    function mint(\n        address from,\n        address to,\n        uint256 amount\n    ) external {\n        require(minters[msg.sender], \"NOT_ALLOWED_MINTER\");\n        _underlyingToken.safeTransferFrom(from, address(this), amount);\n        _mint(to, amount);\n    }\n\n    function burn(\n        address from,\n        address to,\n        uint256 amount\n    ) external {\n        require(burners[msg.sender], \"NOT_ALLOWED_BURNER\");\n        _underlyingToken.safeTransfer(to, amount);\n        _burnFrom(from, amount);\n    }\n}\n"
    },
    "src/outerspace/facets/OuterSpaceFacetBase.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"../types/ImportingOuterSpaceTypes.sol\";\nimport \"../base/ImportingOuterSpaceConstants.sol\";\nimport \"../events/ImportingOuterSpaceEvents.sol\";\nimport \"../base/UsingOuterSpaceDataLayout.sol\";\n\nimport \"../../libraries/Extraction.sol\";\nimport \"../../libraries/Math.sol\";\n\nimport \"../../interfaces/IAlliance.sol\";\nimport \"../../alliances/AllianceRegistry.sol\";\n\nimport \"../../conquest_token/FreePlayToken.sol\";\n\n// TODO Remove\n//  import \"hardhat/console.sol\";\n\ncontract OuterSpaceFacetBase is\n    ImportingOuterSpaceTypes,\n    ImportingOuterSpaceConstants,\n    ImportingOuterSpaceEvents,\n    UsingOuterSpaceDataLayout\n{\n    using Extraction for bytes32;\n\n    IERC20 internal immutable _stakingToken;\n    FreePlayToken internal immutable _freeStakingToken;\n    AllianceRegistry internal immutable _allianceRegistry;\n\n    bytes32 internal immutable _genesis;\n    uint256 internal immutable _resolveWindow;\n    uint256 internal immutable _timePerDistance;\n    uint256 internal immutable _exitDuration;\n    uint32 internal immutable _acquireNumSpaceships; // TODO use uint256\n    uint32 internal immutable _productionSpeedUp; // TODO use uint256\n    uint256 internal immutable _frontrunningDelay;\n    uint256 internal immutable _productionCapAsDuration;\n    uint256 internal immutable _upkeepProductionDecreaseRatePer10000th;\n    uint256 internal immutable _fleetSizeFactor6;\n    uint32 internal immutable _expansionDelta; // = 8;  // TODO use uint256\n    uint256 internal immutable _giftTaxPer10000; // = 2500;\n    // // 4,5,5,10,10,15,15, 20, 20, 30,30,40,40,80,80,100\n    // bytes32 constant stakeRange = 0x000400050005000A000A000F000F00140014001E001E00280028005000500064;\n    // 6, 8, 10, 12, 14, 16, 18, 20, 20, 22, 24, 32, 40, 48, 56, 72\n    // bytes32 internal constant stakeRange = 0x00060008000A000C000E00100012001400140016001800200028003000380048;\n    bytes32 internal immutable _stakeRange;\n    uint256 internal immutable _stakeMultiplier10000th;\n\n    struct Config {\n        IERC20 stakingToken;\n        FreePlayToken freeStakingToken;\n        AllianceRegistry allianceRegistry;\n        bytes32 genesis;\n        uint256 resolveWindow;\n        uint256 timePerDistance;\n        uint256 exitDuration;\n        uint32 acquireNumSpaceships;\n        uint32 productionSpeedUp;\n        uint256 frontrunningDelay;\n        uint256 productionCapAsDuration;\n        uint256 upkeepProductionDecreaseRatePer10000th;\n        uint256 fleetSizeFactor6;\n        uint32 expansionDelta;\n        uint256 giftTaxPer10000;\n        bytes32 stakeRange;\n        uint256 stakeMultiplier10000th;\n    }\n\n    constructor(Config memory config) {\n        uint32 t = uint32(config.timePerDistance) / 4; // the coordinates space is 4 times bigger\n        require(t * 4 == config.timePerDistance, \"TIME_PER_DIST_NOT_DIVISIBLE_4\");\n\n        _stakingToken = config.stakingToken;\n        _freeStakingToken = config.freeStakingToken;\n        _allianceRegistry = config.allianceRegistry;\n\n        _genesis = config.genesis;\n        _resolveWindow = config.resolveWindow;\n        _timePerDistance = t;\n        _exitDuration = config.exitDuration;\n        _acquireNumSpaceships = config.acquireNumSpaceships;\n        _productionSpeedUp = config.productionSpeedUp;\n        _frontrunningDelay = config.frontrunningDelay;\n        _productionCapAsDuration = config.productionCapAsDuration;\n        _upkeepProductionDecreaseRatePer10000th = config.upkeepProductionDecreaseRatePer10000th;\n        _fleetSizeFactor6 = config.fleetSizeFactor6;\n        _expansionDelta = config.expansionDelta;\n        _giftTaxPer10000 = config.giftTaxPer10000;\n        _stakeRange = config.stakeRange;\n        _stakeMultiplier10000th = config.stakeMultiplier10000th;\n    }\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // PLANET STATE\n    // ---------------------------------------------------------------------------------------------------------------\n\n    struct PlanetUpdateState {\n        uint256 location;\n        uint40 lastUpdated;\n        bool active; // modified\n        uint32 numSpaceships; // modified\n        int40 travelingUpkeep; // modified\n        uint40 exitStartTime;\n        uint40 newExitStartTime; // modified\n        uint32 overflow; // modified\n        address owner;\n        address newOwner; // modified\n        bytes32 data;\n        uint24 futureExtraProduction;\n    }\n\n    function _createPlanetUpdateState(Planet memory planet, uint256 location)\n        internal\n        view\n        returns (PlanetUpdateState memory planetUpdate)\n    {\n        (bool active, uint32 currentNumSpaceships) = _activeNumSpaceships(planet.numSpaceships);\n        planetUpdate.location = location;\n        planetUpdate.lastUpdated = planet.lastUpdated;\n        planetUpdate.active = active;\n        planetUpdate.numSpaceships = currentNumSpaceships;\n        planetUpdate.travelingUpkeep = planet.travelingUpkeep;\n        planetUpdate.exitStartTime = planet.exitStartTime;\n        planetUpdate.newExitStartTime = planet.exitStartTime;\n        planetUpdate.overflow = planet.overflow;\n        planetUpdate.owner = planet.owner;\n        planetUpdate.newOwner = planet.owner;\n        planetUpdate.data = _planetData(location);\n    }\n\n    // solhint-disable-next-line code-complexity\n    function _computePlanetUpdateForTimeElapsed(PlanetUpdateState memory planetUpdate) internal view {\n        if (planetUpdate.exitStartTime != 0) {\n            if (_hasJustExited(planetUpdate.exitStartTime)) {\n                planetUpdate.newExitStartTime = 0;\n                planetUpdate.numSpaceships = 0;\n                planetUpdate.travelingUpkeep = 0;\n                planetUpdate.newOwner = address(0);\n                planetUpdate.overflow = 0;\n                planetUpdate.active = false; // event is emitted at the endof each write function\n                // lastUpdated is set at the end directly on storage\n                return;\n            }\n        }\n\n        uint256 timePassed = block.timestamp - planetUpdate.lastUpdated;\n        uint16 production = _production(planetUpdate.data);\n        uint256 amountProducedTheWholeTime = (timePassed * uint256(_productionSpeedUp) * uint256(production)) / 1 hours;\n\n        uint256 newNumSpaceships = planetUpdate.numSpaceships;\n        uint256 extraUpkeepPaid = 0;\n        if (_productionCapAsDuration > 0) {\n            uint256 capWhenActive = _capWhenActive(production);\n            uint256 cap = planetUpdate.active ? capWhenActive : 0;\n\n            if (newNumSpaceships > cap) {\n                uint256 decreaseRate = 1800;\n                if (planetUpdate.overflow > 0) {\n                    decreaseRate = (uint256(planetUpdate.overflow) * 1800) / capWhenActive;\n                    if (decreaseRate < 1800) {\n                        decreaseRate = 1800;\n                    }\n                }\n\n                uint256 decrease = (timePassed * uint256(_productionSpeedUp) * decreaseRate) / 1 hours;\n                if (decrease > newNumSpaceships - cap) {\n                    decrease = newNumSpaceships - cap;\n                }\n\n                if (planetUpdate.active) {\n                    extraUpkeepPaid = decrease;\n                }\n                newNumSpaceships -= decrease;\n            } else {\n                if (planetUpdate.active) {\n                    uint256 increase = amountProducedTheWholeTime;\n                    if (planetUpdate.travelingUpkeep > 0) {\n                        uint256 timeBeforeUpkeepBackToZero =\n                            (uint256(uint40(planetUpdate.travelingUpkeep)) * 1 hours) /\n                                ((uint256(_productionSpeedUp) *\n                                    uint256(production) *\n                                    _upkeepProductionDecreaseRatePer10000th) / 10000); // 10,000 should be extracted as to not reach div by zero (like \"1 hours\")\n                        if (timeBeforeUpkeepBackToZero >= timePassed) {\n                            extraUpkeepPaid = increase;\n                        } else {\n                            extraUpkeepPaid =\n                                (timeBeforeUpkeepBackToZero * uint256(_productionSpeedUp) * uint256(production)) /\n                                1 hours;\n                            if (extraUpkeepPaid > increase) {\n                                extraUpkeepPaid = increase; // TODO remove ? should not be possible\n                            }\n                        }\n                        increase -= extraUpkeepPaid;\n                    }\n\n                    uint256 maxIncrease = cap - newNumSpaceships;\n                    if (increase > maxIncrease) {\n                        extraUpkeepPaid += increase - maxIncrease;\n                        increase = maxIncrease;\n                    }\n                    newNumSpaceships += increase;\n                    // solhint-disable-next-line no-empty-blocks\n                } else {\n                    // not effect currently, when inactive, cap == 0, meaning zero spaceship here\n                    // NOTE: we could do the following assuming we act on upkeepRepaid when inactive, we do not do that currently\n                    //  extraUpkeepPaid = amountProducedTheWholeTime - upkeepRepaid;\n                }\n            }\n\n            if (planetUpdate.active) {\n                uint256 upkeepRepaid =\n                    ((amountProducedTheWholeTime * _upkeepProductionDecreaseRatePer10000th) / 10000) + extraUpkeepPaid;\n                int256 newTravelingUpkeep = int256(planetUpdate.travelingUpkeep) - int40(uint40(upkeepRepaid));\n\n                if (newTravelingUpkeep < -int256(cap)) {\n                    newTravelingUpkeep = -int256(cap);\n                }\n                planetUpdate.travelingUpkeep = int40(newTravelingUpkeep);\n            }\n        } else {\n            // TODO We are not using this branch, and in that branch there is no upkeep or overflow to consider\n            if (planetUpdate.active) {\n                newNumSpaceships += amountProducedTheWholeTime;\n            } else {\n                // NOTE no need to overflow here  as there is no production cap, so no incentive to regroup spaceships\n                uint256 decrease = (timePassed * uint256(_productionSpeedUp) * 1800) / 1 hours;\n                if (decrease > newNumSpaceships) {\n                    decrease = newNumSpaceships;\n                    newNumSpaceships = 0;\n                } else {\n                    newNumSpaceships -= decrease;\n                }\n            }\n        }\n\n        if (newNumSpaceships >= ACTIVE_MASK) {\n            newNumSpaceships = ACTIVE_MASK - 1;\n        }\n        planetUpdate.numSpaceships = uint32(newNumSpaceships);\n\n        if (!planetUpdate.active && planetUpdate.numSpaceships == 0) {\n            planetUpdate.newOwner = address(0);\n        }\n    }\n\n    function _setPlanet(\n        Planet storage planet,\n        PlanetUpdateState memory planetUpdate,\n        bool exitInterupted\n    ) internal {\n        if (planetUpdate.exitStartTime > 0 && planetUpdate.newExitStartTime == 0) {\n            // NOTE: planetUpdate.newExitStartTime is only set to zero when exit is actually complete (not interupted)\n            //  interuption is handled by exitInterupted\n            // exit has completed, newExitStartTime is not set to zero for interuption,\n            // interuption is taken care below (owner changes)\n            _handleExitComplete(planetUpdate);\n        }\n        if (planetUpdate.owner != planetUpdate.newOwner) {\n            planet.owner = planetUpdate.newOwner;\n            planet.ownershipStartTime = uint40(block.timestamp);\n            // TODO stakedOwnershipStartTime ?\n            // TODO handle staking pool ?\n            emit Transfer(planetUpdate.owner, planetUpdate.newOwner, planetUpdate.location);\n        }\n\n        if (exitInterupted) {\n            // if (planetUpdate.newExitStartTime == 0 && planetUpdate.exitStartTime > 0) {\n            // exit interupted // TODO event ?\n            // }\n            planet.exitStartTime = 0;\n        } else if (planetUpdate.newExitStartTime != planetUpdate.exitStartTime) {\n            planet.exitStartTime = planetUpdate.newExitStartTime;\n        }\n\n        planet.numSpaceships = _setActiveNumSpaceships(planetUpdate.active, planetUpdate.numSpaceships);\n        planet.travelingUpkeep = planetUpdate.travelingUpkeep;\n\n        planet.overflow = planetUpdate.overflow;\n        planet.lastUpdated = uint40(block.timestamp);\n    }\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // STAKING / PRODUCTION CAPTURE\n    // ---------------------------------------------------------------------------------------------------------------\n\n    function _acquire(\n        address player,\n        uint256 stake,\n        uint256 location,\n        bool freegift\n    ) internal {\n        // -----------------------------------------------------------------------------------------------------------\n        // Initialise State Update\n        // -----------------------------------------------------------------------------------------------------------\n        Planet storage planet = _getPlanet(location);\n        PlanetUpdateState memory planetUpdate = _createPlanetUpdateState(planet, location);\n\n        // -----------------------------------------------------------------------------------------------------------\n        // check requirements\n        // -----------------------------------------------------------------------------------------------------------\n        require(stake == uint256(_stake(planetUpdate.data)) * (DECIMALS_14), \"INVALID_AMOUNT\");\n\n        // -----------------------------------------------------------------------------------------------------------\n        // Compute Basic Planet Updates\n        // -----------------------------------------------------------------------------------------------------------\n        _computePlanetUpdateForTimeElapsed(planetUpdate);\n\n        // -----------------------------------------------------------------------------------------------------------\n        // Staking logic...\n        // -----------------------------------------------------------------------------------------------------------\n        _computePlanetUpdateForStaking(player, planetUpdate);\n\n        // -----------------------------------------------------------------------------------------------------------\n        // Write New State\n        // -----------------------------------------------------------------------------------------------------------\n        _setPlanet(planet, planetUpdate, false);\n        // _setAccountFromPlanetUpdate(planetUpdate);\n\n        // -----------------------------------------------------------------------------------------------------------\n        // Update Space Discovery\n        // -----------------------------------------------------------------------------------------------------------\n        _setDiscoveryAfterStaking(location);\n\n        if (freegift) {\n            _planetFlagged[location] = block.timestamp;\n        } else {\n            _planetFlagged[location] = 0; // staked with normal tokens\n        }\n\n        // -----------------------------------------------------------------------------------------------------------\n        // Emit Event\n        // -----------------------------------------------------------------------------------------------------------\n        emit PlanetStake(\n            player,\n            location,\n            planetUpdate.numSpaceships,\n            planetUpdate.travelingUpkeep,\n            planetUpdate.overflow,\n            stake,\n            freegift\n        );\n    }\n\n    function _computePlanetUpdateForStaking(address player, PlanetUpdateState memory planetUpdate) internal view {\n        require(!planetUpdate.active, \"STILL_ACTIVE\");\n\n        uint32 defense;\n        // NOTE : natives are back automatically once spaceships reaches zero (here we know we are not active)\n        // TODO consider making natives come back over time => would need to compute the time numSpaceship became zero\n        if (planetUpdate.numSpaceships == 0) {\n            defense = _natives(planetUpdate.data);\n        } else {\n            // Do not allow staking over occupied planets, they are going to zero at some point though\n            require(planetUpdate.owner == player, \"OCCUPIED\");\n        }\n\n        uint16 production = _production(planetUpdate.data);\n        uint32 cap = uint32(_capWhenActive(production));\n\n        // TODO ensure a player staking on a planet it previously exited work here\n        planetUpdate.newOwner = player;\n        if (defense != 0) {\n            (uint32 attackerLoss, ) =\n                _computeFight(uint256(_acquireNumSpaceships), defense, 10000, _defense(planetUpdate.data));\n            // attacker alwasy win as defense (and stats.native) is restricted to 3500\n            // (attackerLoss: 0, defenderLoss: 0) would mean defense was zero\n            require(attackerLoss < _acquireNumSpaceships, \"FAILED_CAPTURED\");\n            planetUpdate.numSpaceships = _acquireNumSpaceships - attackerLoss;\n\n            // NOTE cannot be overflow here as staking provide a number of spaceships below that\n            planetUpdate.overflow = 0;\n        } else {\n            planetUpdate.numSpaceships += _acquireNumSpaceships;\n            if (_productionCapAsDuration > 0) {\n                if (planetUpdate.numSpaceships > cap) {\n                    planetUpdate.overflow = planetUpdate.numSpaceships - cap;\n                } else {\n                    planetUpdate.overflow = 0;\n                }\n            }\n        }\n\n        // NOTE when staking on a planet, we set an allowance for traveling upkeep\n        planetUpdate.travelingUpkeep =\n            -int32(uint32((uint256(cap) * _upkeepProductionDecreaseRatePer10000th) / 10000)) -\n            int32(planetUpdate.numSpaceships);\n        planetUpdate.active = true;\n    }\n\n    // solhint-disable-next-line code-complexity\n    function _setDiscoveryAfterStaking(uint256 location) internal {\n        Discovered memory discovered = _discovered;\n\n        int256 x = int256(int128(int256(location & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)));\n        int256 y = int256(int128(int256(location >> 128)));\n\n        bool changes = false;\n        if (x < 0) {\n            require(-x <= int256(uint256(discovered.minX)), \"NOT_REACHABLE_YET_MINX\");\n            x = -x + int32(_expansionDelta);\n            if (x > UINT32_MAX) {\n                x = UINT32_MAX;\n            }\n            if (int256(uint256(discovered.minX)) < x) {\n                discovered.minX = uint32(uint256(x));\n                changes = true;\n            }\n        } else {\n            require(x <= int256(uint256(discovered.maxX)), \"NOT_REACHABLE_YET_MAXX\");\n            x = x + int32(_expansionDelta);\n            if (x > UINT32_MAX) {\n                x = UINT32_MAX;\n            }\n            if (discovered.maxX < uint32(uint256(x))) {\n                discovered.maxX = uint32(uint256(x));\n                changes = true;\n            }\n        }\n\n        if (y < 0) {\n            require(-y <= int256(uint256(discovered.minY)), \"NOT_REACHABLE_YET_MINY\");\n            y = -y + int32(_expansionDelta);\n            if (y > UINT32_MAX) {\n                y = UINT32_MAX;\n            }\n            if (int256(uint256(discovered.minY)) < y) {\n                discovered.minY = uint32(uint256(y));\n                changes = true;\n            }\n        } else {\n            require(y <= int256(uint256(discovered.maxY)), \"NOT_REACHABLE_YET_MAXY\");\n            y = y + int32(_expansionDelta);\n            if (y > UINT32_MAX) {\n                y = UINT32_MAX;\n            }\n            if (int256(uint256(discovered.maxY)) < y) {\n                discovered.maxY = uint32(uint256(y));\n                changes = true;\n            }\n        }\n        if (changes) {\n            _discovered = discovered;\n        }\n    }\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // EXITS / WITHDRAWALS\n    // ---------------------------------------------------------------------------------------------------------------\n\n    function _handleExitComplete(PlanetUpdateState memory planetUpdate) internal {\n        uint256 stake = _completeExit(planetUpdate.owner, planetUpdate.location, planetUpdate.data);\n\n        // TODO Transfer to zero and Transfer from zero ?\n\n        // optional so we can use it in the batch withdraw,\n\n        uint256 flagTime = _planetFlagged[planetUpdate.location];\n        if (flagTime > 0) {\n            if (planetUpdate.exitStartTime >= flagTime + (6 days / _productionSpeedUp)) {\n                _freeStakingToken.burn(address(this), address(this), stake);\n                uint256 newStake = _stakeReadyToBeWithdrawn[planetUpdate.owner] + stake;\n                _stakeReadyToBeWithdrawn[planetUpdate.owner] = newStake;\n                emit StakeToWithdraw(planetUpdate.owner, newStake, false);\n            } else {\n                uint256 newStake = _freeStakeReadyToBeWithdrawn[planetUpdate.owner] + stake;\n                _freeStakeReadyToBeWithdrawn[planetUpdate.owner] = newStake;\n                emit StakeToWithdraw(planetUpdate.owner, newStake, true);\n            }\n        } else {\n            uint256 newStake = _stakeReadyToBeWithdrawn[planetUpdate.owner] + stake;\n            _stakeReadyToBeWithdrawn[planetUpdate.owner] = newStake;\n            emit StakeToWithdraw(planetUpdate.owner, newStake, false);\n        }\n    }\n\n    function _completeExit(\n        address owner,\n        uint256 location,\n        bytes32 data\n    ) internal returns (uint256 stake) {\n        stake = uint256(_stake(data)) * (DECIMALS_14);\n        emit ExitComplete(owner, location, stake);\n\n        // TODO handle Staking pool release ?\n        // (maybe not necessary here, can do in withdrawals?)\n\n        // --------------------------------------------------------\n        // Extra Reward was added\n        // --------------------------------------------------------\n        uint256 rewardId = _rewards[location];\n        if (rewardId != 0) {\n            // rewardId would contains the package. maybe this could be handled by an external contract\n            _rewardsToWithdraw[owner][rewardId] = true;\n            _rewards[location] = 0; // reset\n            // if you had reward to a planet in he process of exiting,\n            // you are adding the reward to the player exiting unless _setPlanetAfterExit is called first\n            emit RewardToWithdraw(owner, location, rewardId);\n        }\n        // --------------------------------------------------------\n    }\n\n    function _exitFor(address owner, uint256 location) internal {\n        Planet storage planet = _getPlanet(location);\n        (bool active, ) = _activeNumSpaceships(planet.numSpaceships);\n        require(active, \"NOT_ACTIVE\");\n        require(owner == planet.owner, \"NOT_OWNER\");\n        require(planet.exitStartTime == 0, \"EXITING_ALREADY\");\n\n        planet.exitStartTime = uint40(block.timestamp);\n        emit PlanetExit(owner, location);\n    }\n\n    function _fetchAndWithdrawFor(address owner, uint256[] calldata locations) internal {\n        uint256 addedStake = 0;\n        uint256 freeAddedStake = 0;\n        for (uint256 i = 0; i < locations.length; i++) {\n            Planet storage planet = _getPlanet(locations[i]);\n            if (_hasJustExited(planet.exitStartTime)) {\n                require(owner == planet.owner, \"NOT_OWNER\");\n                emit Transfer(owner, address(0), locations[i]);\n\n                uint256 flagTime = _planetFlagged[locations[i]];\n                if (flagTime > 0) {\n                    if (planet.exitStartTime >= flagTime + (6 days / _productionSpeedUp)) {\n                        uint256 extra = _completeExit(planet.owner, locations[i], _planetData(locations[i]));\n                        addedStake += extra;\n                        _freeStakingToken.burn(address(this), address(this), extra);\n                    } else {\n                        freeAddedStake += _completeExit(planet.owner, locations[i], _planetData(locations[i]));\n                    }\n                } else {\n                    addedStake += _completeExit(planet.owner, locations[i], _planetData(locations[i]));\n                }\n\n                planet.owner = address(0);\n                planet.ownershipStartTime = 0;\n                planet.exitStartTime = 0;\n                planet.numSpaceships = 0;\n                planet.overflow = 0;\n                planet.travelingUpkeep = 0;\n                planet.lastUpdated = uint40(block.timestamp);\n            }\n        }\n        uint256 newStake = _stakeReadyToBeWithdrawn[owner] + addedStake;\n        _unsafe_withdrawAll(owner, newStake);\n\n        uint256 newFreeStake = _freeStakeReadyToBeWithdrawn[owner] + freeAddedStake;\n        _free_unsafe_withdrawAll(owner, newFreeStake);\n    }\n\n    function _unsafe_withdrawAll(address owner, uint256 amount) internal {\n        _stakeReadyToBeWithdrawn[owner] = 0;\n        emit StakeToWithdraw(owner, amount, false);\n        require(_stakingToken.transfer(owner, amount), \"FAILED_TRANSFER\");\n        // TODO Staking Pool\n        emit StakeToWithdraw(owner, 0, false);\n    }\n\n    function _free_unsafe_withdrawAll(address owner, uint256 amount) internal {\n        _freeStakeReadyToBeWithdrawn[owner] = 0;\n        emit StakeToWithdraw(owner, amount, true);\n        require(_freeStakingToken.transfer(owner, amount), \"FAILED_TRANSFER\");\n        // TODO Staking Pool\n        emit StakeToWithdraw(owner, 0, true);\n    }\n\n    function _hasJustExited(uint40 exitTime) internal view returns (bool) {\n        return exitTime > 0 && block.timestamp > exitTime + _exitDuration;\n    }\n\n    function _ping(uint256 location) internal {\n        Planet storage planet = _getPlanet(location);\n        PlanetUpdateState memory planetUpdate = _createPlanetUpdateState(planet, location);\n        _computePlanetUpdateForTimeElapsed(planetUpdate);\n        _setPlanet(planet, planetUpdate, false);\n        // _setAccountFromPlanetUpdate(planetUpdate);\n    }\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // REWARDS\n    // ---------------------------------------------------------------------------------------------------------------\n\n    function _addReward(uint256 location, address sponsor) internal {\n        uint256 rewardId = _rewards[location];\n        if (rewardId == 0) {\n            rewardId = ++_prevRewardIds[sponsor];\n            _rewards[location] = (uint256(uint160(sponsor)) << 96) + rewardId;\n        }\n        // TODO should it fails if different sponsor added reward before\n\n        // TODO rewardId association with the actual rewards // probably contract address holding the reward\n        emit RewardSetup(location, sponsor, rewardId);\n    }\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // FLEET SENDING\n    // ---------------------------------------------------------------------------------------------------------------\n\n    function _unsafe_sendFor(\n        uint256 fleetId,\n        address operator,\n        FleetLaunch memory launch\n    ) internal {\n        // -----------------------------------------------------------------------------------------------------------\n        // Initialise State Update\n        // -----------------------------------------------------------------------------------------------------------\n        Planet storage planet = _getPlanet(launch.from);\n        PlanetUpdateState memory planetUpdate = _createPlanetUpdateState(planet, launch.from);\n\n        // -----------------------------------------------------------------------------------------------------------\n        // check requirements\n        // -----------------------------------------------------------------------------------------------------------\n\n        require(planet.exitStartTime == 0, \"PLANET_EXIT\");\n        require(launch.fleetSender == planet.owner, \"NOT_OWNER\");\n\n        // -----------------------------------------------------------------------------------------------------------\n        // Compute Basic Planet Updates\n        // -----------------------------------------------------------------------------------------------------------\n        _computePlanetUpdateForTimeElapsed(planetUpdate);\n\n        // -----------------------------------------------------------------------------------------------------------\n        // Requirements post Planet Updates\n        // -----------------------------------------------------------------------------------------------------------\n\n        require(planetUpdate.numSpaceships >= launch.quantity, \"SPACESHIPS_NOT_ENOUGH\");\n\n        // -----------------------------------------------------------------------------------------------------------\n        // Sending logic...\n        // -----------------------------------------------------------------------------------------------------------\n        _computePlanetUpdateForFleetLaunch(planetUpdate, launch.quantity);\n\n        // -----------------------------------------------------------------------------------------------------------\n        // Write New State\n        // -----------------------------------------------------------------------------------------------------------\n        _setPlanet(planet, planetUpdate, false);\n        // _setAccountFromPlanetUpdate(planetUpdate);\n\n        _setFleetFlyingSlot(launch.from, launch.quantity);\n\n        // TODO add debt info\n        _fleets[fleetId] = Fleet({\n            launchTime: uint40(block.timestamp),\n            owner: launch.fleetOwner,\n            quantity: launch.quantity,\n            futureExtraProduction: planetUpdate.futureExtraProduction\n        });\n\n        emit FleetSent(\n            launch.fleetSender,\n            launch.fleetOwner,\n            launch.from,\n            operator,\n            fleetId,\n            launch.quantity,\n            planetUpdate.numSpaceships,\n            planetUpdate.travelingUpkeep,\n            planetUpdate.overflow\n        );\n    }\n\n    function _computePlanetUpdateForFleetLaunch(PlanetUpdateState memory planetUpdate, uint32 quantity) internal view {\n        planetUpdate.numSpaceships -= quantity;\n        if (_productionCapAsDuration > 0) {\n            if (planetUpdate.active) {\n                // NOTE we do not update travelingUpkeep on Inactive planets\n                //  these get reset on staking\n\n                uint16 production = _production(planetUpdate.data);\n                uint256 cap = _capWhenActive(production);\n                if (planetUpdate.numSpaceships < cap) {\n                    uint256 futureExtraProduction = cap - planetUpdate.numSpaceships;\n                    if (futureExtraProduction > quantity) {\n                        futureExtraProduction = quantity;\n                    }\n                    int256 newTravelingUpkeep = int256(planetUpdate.travelingUpkeep) + int256(futureExtraProduction);\n                    if (newTravelingUpkeep > int256(cap)) {\n                        newTravelingUpkeep = int256(cap);\n                    }\n                    planetUpdate.travelingUpkeep = int40(newTravelingUpkeep);\n                    planetUpdate.futureExtraProduction = uint24(futureExtraProduction); // cap is always smaller than uint24\n                }\n            }\n\n            if (planetUpdate.overflow > quantity) {\n                planetUpdate.overflow -= quantity;\n            } else {\n                planetUpdate.overflow = 0;\n            }\n        }\n    }\n\n    function _setFleetFlyingSlot(uint256 from, uint32 quantity) internal {\n        // -----------------------------------------------------------------------------------------------------------\n        // record flying fleets (to prevent front-running, see resolution)\n        // -----------------------------------------------------------------------------------------------------------\n        uint256 timeSlot = block.timestamp / (_frontrunningDelay / 2);\n        uint32 flying = _inFlight[from][timeSlot].flying;\n        flying = flying + quantity;\n        require(flying >= quantity, \"ORBIT_OVERFLOW\"); // unlikely to ever happen,\n        // would need a huge amount of spaceships to be received and each in turn being sent\n        // TOEXPLORE could also cap, that would result in some fleet being able to escape.\n        _inFlight[from][timeSlot].flying = flying;\n        // -----------------------------------------------------------------------------------------------------------\n    }\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // FLEET RESOLUTION, ATTACK / REINFORCEMENT\n    // ---------------------------------------------------------------------------------------------------------------\n    struct ResolutionState {\n        address fleetOwner;\n        uint40 fleetLaunchTime;\n        uint32 originalQuantity;\n        uint32 fleetQuantity;\n        bytes32 fromData;\n        uint32 inFlightFleetLoss;\n        uint32 inFlightPlanetLoss;\n        bool gifting;\n        bool taxed;\n        bool victory;\n        uint32 attackerLoss;\n        uint32 defenderLoss;\n        uint32 orbitDefense1;\n        uint32 orbitDefenseDestroyed1;\n        uint32 orbitDefense2;\n        uint32 orbitDefenseDestroyed2;\n        uint40 arrivalTime;\n        uint32 accumulatedDefenseAdded;\n        uint32 accumulatedAttackAdded;\n        uint16 attackPower;\n        uint24 futureExtraProduction;\n    }\n\n    function _resolveFleet(uint256 fleetId, FleetResolution calldata resolution) internal {\n        // -----------------------------------------------------------------------------------------------------------\n        // Initialise State Update\n        // -----------------------------------------------------------------------------------------------------------\n        Planet storage toPlanet = _getPlanet(resolution.to);\n        PlanetUpdateState memory toPlanetUpdate = _createPlanetUpdateState(toPlanet, resolution.to);\n        ResolutionState memory rState = _createResolutionState(_fleets[fleetId], resolution.from);\n\n        // -----------------------------------------------------------------------------------------------------------\n        // check requirements\n        // -----------------------------------------------------------------------------------------------------------\n\n        require(\n            rState.fleetQuantity > 0, // TODO use other indicator, maybe even result: gift / failed attack / success\n            rState.fleetOwner != address(0) ? \"FLEET_RESOLVED_ALREADY\" : \"FLEET_DO_NOT_EXIST\"\n        );\n        _requireCorrectDistance(\n            resolution.distance,\n            resolution.from,\n            resolution.to,\n            rState.fromData,\n            toPlanetUpdate.data\n        );\n        _requireCorrectTimeAndUpdateArrivalTime(\n            resolution.distance,\n            resolution.arrivalTimeWanted,\n            rState.fleetLaunchTime,\n            rState.fromData,\n            rState\n        );\n\n        // -----------------------------------------------------------------------------------------------------------\n        // Compute Basic Planet Updates\n        // -----------------------------------------------------------------------------------------------------------\n        _computePlanetUpdateForTimeElapsed(toPlanetUpdate);\n\n        uint32 numSpaceshipsAtArrival = toPlanetUpdate.numSpaceships;\n\n        // -----------------------------------------------------------------------------------------------------------\n        // Traveling logic...\n        // -----------------------------------------------------------------------------------------------------------\n\n        _computeInFlightLossForFleet(rState, resolution);\n\n        // -----------------------------------------------------------------------------------------------------------\n        // Resolution logic...\n        // -----------------------------------------------------------------------------------------------------------\n\n        _updateFleetForGifting(rState, resolution, toPlanetUpdate.newOwner);\n\n        _computeResolutionResult(rState, toPlanetUpdate);\n\n        // -----------------------------------------------------------------------------------------------------------\n        // Write New State\n        // -----------------------------------------------------------------------------------------------------------\n\n        _recordInOrbitLossAfterAttack(rState, toPlanetUpdate);\n\n        _recordOrbitLossAccountingForFleetOrigin(rState, resolution);\n\n        _setTravelingUpkeepFromOrigin(fleetId, rState, resolution.from);\n\n        _setPlanet(toPlanet, toPlanetUpdate, rState.victory);\n\n        _setAccumulatedAttack(rState, toPlanetUpdate);\n\n        // _setAccountFromPlanetUpdate(toPlanetUpdate); // TODO remove, else think about the fromPlanet ?\n\n        // TODO quantity should be kept ?\n        //  so Alliance Contract can act on that value ?, could use 1st bit indicator\n        _fleets[fleetId].quantity = 0;\n\n        // -----------------------------------------------------------------------------------------------------------\n        // Events\n        // -----------------------------------------------------------------------------------------------------------\n        _emitFleetArrived(\n            fleetId,\n            rState,\n            toPlanetUpdate.owner,\n            resolution.to,\n            _arrivalData(rState, toPlanetUpdate, numSpaceshipsAtArrival)\n        );\n    }\n\n    function _arrivalData(\n        ResolutionState memory rState,\n        PlanetUpdateState memory toPlanetUpdate,\n        uint32 numSpaceshipsAtArrival\n    ) internal pure returns (ArrivalData memory arrivalData) {\n        arrivalData.newNumspaceships = toPlanetUpdate.numSpaceships;\n        arrivalData.newTravelingUpkeep = toPlanetUpdate.travelingUpkeep;\n        arrivalData.newOverflow = toPlanetUpdate.overflow;\n        arrivalData.numSpaceshipsAtArrival = numSpaceshipsAtArrival;\n        arrivalData.taxLoss = rState.taxed\n            ? (rState.originalQuantity - rState.inFlightFleetLoss) - rState.fleetQuantity\n            : 0;\n        arrivalData.fleetLoss = rState.attackerLoss;\n        arrivalData.planetLoss = rState.defenderLoss;\n        arrivalData.inFlightFleetLoss = rState.inFlightFleetLoss;\n        arrivalData.inFlightPlanetLoss = rState.inFlightPlanetLoss;\n        arrivalData.accumulatedDefenseAdded = rState.accumulatedDefenseAdded;\n        arrivalData.accumulatedAttackAdded = rState.accumulatedAttackAdded;\n    }\n\n    function _emitFleetArrived(\n        uint256 fleetId,\n        ResolutionState memory rState,\n        address planetOwner,\n        uint256 to,\n        ArrivalData memory arrivalData\n    ) internal {\n        emit FleetArrived(fleetId, rState.fleetOwner, planetOwner, to, rState.gifting, rState.victory, arrivalData);\n    }\n\n    function _requireCorrectDistance(\n        uint256 distance,\n        uint256 from,\n        uint256 to,\n        bytes32 fromPlanetData,\n        bytes32 toPlanetData\n    ) internal pure {\n        // check input instead of compute sqrt\n\n        (int8 fromSubX, int8 fromSubY) = _subLocation(fromPlanetData);\n        (int8 toSubX, int8 toSubY) = _subLocation(toPlanetData);\n        uint256 distanceSquared =\n            uint256(\n                int256( // check input instead of compute sqrt\n                    ((int128(int256(to & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) * 4 + toSubX) -\n                        (int128(int256(from & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) * 4 + fromSubX)) **\n                        2 +\n                        ((int128(int256(to >> 128)) * 4 + toSubY) - (int128(int256(from >> 128)) * 4 + fromSubY))**2\n                )\n            );\n        require(distance**2 <= distanceSquared && distanceSquared < (distance + 1)**2, \"wrong distance\");\n    }\n\n    function _requireCorrectTimeAndUpdateArrivalTime(\n        uint256 distance,\n        uint256 arrivalTimeWanted,\n        uint40 launchTime,\n        bytes32 fromPlanetData,\n        ResolutionState memory rState\n    ) internal view {\n        uint256 minReachTime = launchTime + (distance * (_timePerDistance * 10000)) / _speed(fromPlanetData);\n        uint256 reachTime = Math.max(arrivalTimeWanted, minReachTime);\n        if (arrivalTimeWanted > 0) {\n            rState.arrivalTime = uint40(arrivalTimeWanted);\n        } else {\n            rState.arrivalTime = uint40(minReachTime);\n        }\n        require(block.timestamp >= reachTime, \"too early\");\n        require(block.timestamp < reachTime + _resolveWindow, \"too late, your spaceships are lost in space\");\n    }\n\n    function _computeInFlightLossForFleet(ResolutionState memory rState, FleetResolution memory resolution)\n        internal\n        view\n    {\n        // -----------------------------------------------------------------------------------------------------------\n        // check if fleet was attacked while departing (used to prevent front-running, see fleet sending)\n        // -----------------------------------------------------------------------------------------------------------\n        uint256 timeSlot = rState.fleetLaunchTime / (_frontrunningDelay / 2);\n        uint32 destroyed = _inFlight[resolution.from][timeSlot].destroyed;\n        uint32 originalQuantity = rState.fleetQuantity;\n        if (destroyed < rState.fleetQuantity) {\n            rState.fleetQuantity -= uint32(destroyed);\n        } else {\n            rState.fleetQuantity = 0;\n        }\n\n        rState.inFlightFleetLoss = originalQuantity - rState.fleetQuantity;\n        // -----------------------------------------------------------------------------------------------------------\n    }\n\n    function _updateFleetForGifting(\n        ResolutionState memory rState,\n        FleetResolution memory resolution,\n        address destinationOwner\n    ) internal view {\n        (bool gifting, bool taxed) = _computeGifting(destinationOwner, resolution, rState);\n        rState.gifting = gifting;\n        rState.taxed = taxed;\n    }\n\n    // TODO simplify and apply that to attack (when fleetOwner is not fleetSender)\n    //  if (resolution.gift) { rState.fleetOwner = destinationOwner }\n    //  then compute tax based on fleetOwner != fleetSender, box for attacks and gift\n    //  combined attack could even work for non-allies ?\n    //  in _computeGift calculate the tax for every branch that result in `gifting` being false\n    //  then in attack, add tax to the quantity of fleet + modify event\n\n    // solhint-disable-next-line code-complexity\n    function _computeGifting(\n        address destinationOwner,\n        FleetResolution memory resolution,\n        ResolutionState memory rState\n    ) internal view returns (bool gifting, bool taxed) {\n        if (destinationOwner == address(0)) {\n            // destination has no owner : this is an attack\n            return (false, _isFleetOwnerTaxed(rState.fleetOwner, resolution.fleetSender, rState.fleetLaunchTime));\n        }\n        if (destinationOwner == rState.fleetOwner && destinationOwner == resolution.fleetSender) {\n            // destination is sender is fleet owner: this is a non-taxed gift\n            return (true, false);\n        }\n\n        if (resolution.gift || destinationOwner == rState.fleetOwner) {\n            // intent was gift\n            if (\n                resolution.specific == address(0) || // anyone\n                resolution.specific == destinationOwner || // only one address and matching owner\n                destinationOwner == rState.fleetOwner // owner is fleet owner => gift\n            ) {\n                // and it was for anyone or specific destination owner that is the same as the current one\n                // or it was simply that fleetOwner = destinationOwner\n\n                // check tax applies with sender\n                (, uint96 joinTime) =\n                    _allianceRegistry.havePlayersAnAllianceInCommon(\n                        resolution.fleetSender,\n                        destinationOwner,\n                        rState.fleetLaunchTime\n                    );\n                return (true, joinTime == 0 || joinTime > rState.fleetLaunchTime);\n            }\n\n            if (resolution.specific == address(1)) {\n                // or the specific specify any common alliances (1)\n\n                if (rState.fleetOwner == resolution.fleetSender) {\n                    (, uint96 joinTime) =\n                        _allianceRegistry.havePlayersAnAllianceInCommon(\n                            resolution.fleetSender,\n                            destinationOwner,\n                            rState.fleetLaunchTime\n                        );\n                    return (joinTime > 0, joinTime > rState.fleetLaunchTime);\n                } else {\n                    (, uint96 fleetOwnerJoinTime) =\n                        _allianceRegistry.havePlayersAnAllianceInCommon(\n                            rState.fleetOwner,\n                            destinationOwner,\n                            rState.fleetLaunchTime\n                        );\n\n                    if (fleetOwnerJoinTime == 0) {\n                        // not in an alliance\n                        return (\n                            false,\n                            _isFleetOwnerTaxed(rState.fleetOwner, resolution.fleetSender, rState.fleetLaunchTime)\n                        );\n                    }\n\n                    // alliance => means gift\n                    // check if taxed:\n                    (, uint96 senderJoinTime) =\n                        _allianceRegistry.havePlayersAnAllianceInCommon(\n                            resolution.fleetSender,\n                            destinationOwner,\n                            rState.fleetLaunchTime\n                        );\n\n                    return (true, senderJoinTime == 0 || senderJoinTime > rState.fleetLaunchTime);\n                }\n            }\n\n            if (uint160(resolution.specific) > 1) {\n                // or a specific alliance that matches\n\n                (uint96 joinTimeToSpecific, ) =\n                    _allianceRegistry.getAllianceData(destinationOwner, IAlliance(resolution.specific));\n\n                if (joinTimeToSpecific > 0) {\n                    (, uint96 joinTime) =\n                        _allianceRegistry.havePlayersAnAllianceInCommon(\n                            resolution.fleetSender,\n                            destinationOwner,\n                            rState.fleetLaunchTime\n                        );\n                    return (true, joinTime == 0 || joinTime > rState.fleetLaunchTime);\n                }\n            }\n        } else {\n            // intent was attack\n            if (resolution.specific == address(1)) {\n                // and the attack was on any non-allies\n\n                if (rState.fleetOwner == resolution.fleetSender) {\n                    // make it a gift if the destination owner is actually an ally\n                    (, uint96 joinTime) =\n                        _allianceRegistry.havePlayersAnAllianceInCommon(\n                            resolution.fleetSender,\n                            destinationOwner,\n                            rState.fleetLaunchTime\n                        );\n                    return (joinTime > 0, joinTime > rState.fleetLaunchTime);\n                } else {\n                    (, uint96 fleetOwnerJoinTime) =\n                        _allianceRegistry.havePlayersAnAllianceInCommon(\n                            rState.fleetOwner,\n                            destinationOwner,\n                            rState.fleetLaunchTime\n                        );\n\n                    if (fleetOwnerJoinTime == 0) {\n                        // not in an alliance\n                        return (\n                            false,\n                            _isFleetOwnerTaxed(rState.fleetOwner, resolution.fleetSender, rState.fleetLaunchTime)\n                        );\n                    }\n\n                    // alliance => means gift\n                    // check if taxed:\n                    (, uint96 senderJoinTime) =\n                        _allianceRegistry.havePlayersAnAllianceInCommon(\n                            resolution.fleetSender,\n                            destinationOwner,\n                            rState.fleetLaunchTime\n                        );\n\n                    return (true, senderJoinTime == 0 || senderJoinTime > rState.fleetLaunchTime);\n                }\n            }\n\n            if (uint160(resolution.specific) > 1 && resolution.specific != destinationOwner) {\n                // but specific not matching current owner\n\n                (uint96 joinTimeToSpecific, ) =\n                    _allianceRegistry.getAllianceData(destinationOwner, IAlliance(resolution.specific));\n\n                // make it a gift if the destination is not matching the specific alliance\n                // (or owner, in which case since it is not an alliance, it will also not match)\n                if (joinTimeToSpecific == 0) {\n                    (, uint96 joinTime) =\n                        _allianceRegistry.havePlayersAnAllianceInCommon(\n                            resolution.fleetSender,\n                            destinationOwner,\n                            rState.fleetLaunchTime\n                        );\n                    return (true, joinTime == 0 || joinTime > rState.fleetLaunchTime);\n                }\n            }\n        }\n        return (false, _isFleetOwnerTaxed(rState.fleetOwner, resolution.fleetSender, rState.fleetLaunchTime));\n    }\n\n    function _isFleetOwnerTaxed(\n        address fleetOwner,\n        address fleetSender,\n        uint40 fleetLaunchTime\n    ) internal view returns (bool) {\n        if (fleetOwner == fleetSender) {\n            return false;\n        }\n        (, uint96 joinTime) = _allianceRegistry.havePlayersAnAllianceInCommon(fleetOwner, fleetSender, fleetLaunchTime);\n        return joinTime == 0 || joinTime > fleetLaunchTime;\n    }\n\n    function _setTravelingUpkeepFromOrigin(\n        uint256 fleetID,\n        ResolutionState memory rState,\n        uint256 location\n    ) internal {\n        // // we have to update the origin\n        Planet storage fromPlanet = _planets[location];\n        PlanetUpdateState memory fromPlanetUpdate = _createPlanetUpdateState(fromPlanet, location);\n        _computePlanetUpdateForTimeElapsed(fromPlanetUpdate);\n\n        uint16 production = _production(fromPlanetUpdate.data);\n        uint256 capWhenActive = _capWhenActive(production);\n\n        uint256 refund = rState.futureExtraProduction;\n        uint256 timePassed = block.timestamp - rState.fleetLaunchTime;\n        uint256 amountProducedTheWholeTime = (timePassed * uint256(_productionSpeedUp) * uint256(production)) / 1 hours;\n        uint256 consumed =\n            amountProducedTheWholeTime + (amountProducedTheWholeTime * _upkeepProductionDecreaseRatePer10000th) / 10000;\n        if (consumed > refund) {\n            refund = 0;\n        } else {\n            refund -= consumed;\n        }\n\n        int256 newTravelingUpkeep = int256(fromPlanetUpdate.travelingUpkeep) - int256(refund);\n        if (newTravelingUpkeep < -int256(capWhenActive)) {\n            newTravelingUpkeep = -int256(capWhenActive);\n        }\n        fromPlanetUpdate.travelingUpkeep = int40(newTravelingUpkeep);\n\n        _setPlanet(fromPlanet, fromPlanetUpdate, false);\n\n        emit TravelingUpkeepRefund(\n            location,\n            fleetID,\n            fromPlanetUpdate.numSpaceships,\n            fromPlanetUpdate.travelingUpkeep,\n            fromPlanetUpdate.overflow\n        );\n    }\n\n    function _setAccumulatedAttack(ResolutionState memory rState, PlanetUpdateState memory toPlanetUpdate) internal {\n        if (rState.victory) {\n            // victory, past attack has been succesful in capturing the planet, They do not count anymore\n            delete _attacks[toPlanetUpdate.location][rState.fleetOwner][rState.arrivalTime];\n        } else if (!rState.taxed) {\n            AccumulatedAttack storage attack = _attacks[toPlanetUpdate.location][rState.fleetOwner][rState.arrivalTime];\n\n            attack.target = toPlanetUpdate.owner;\n            attack.damageCausedSoFar = rState.defenderLoss + rState.inFlightPlanetLoss;\n            attack.numAttackSpent = rState.attackerLoss;\n            attack.averageAttackPower = rState.attackPower;\n        }\n    }\n\n    function _createResolutionState(Fleet storage fleet, uint256 from)\n        internal\n        view\n        returns (ResolutionState memory rState)\n    {\n        rState.fleetOwner = fleet.owner;\n        rState.fleetLaunchTime = fleet.launchTime;\n        rState.originalQuantity = fleet.quantity;\n        rState.fleetQuantity = fleet.quantity;\n        rState.futureExtraProduction = fleet.futureExtraProduction;\n        rState.fromData = _planetData(from);\n        rState.attackPower = _attack(rState.fromData);\n    }\n\n    function _recordOrbitLossAccountingForFleetOrigin(ResolutionState memory rState, FleetResolution memory resolution)\n        internal\n    {\n        if (rState.inFlightFleetLoss > 0) {\n            uint256 timeSlot = rState.fleetLaunchTime / (_frontrunningDelay / 2);\n\n            // NOTE we already computed that destroyed cannot be smaller than inFlightFleetLoss\n            //  see _computeInFlightLossForFleet\n            _inFlight[resolution.from][timeSlot].destroyed -= rState.inFlightFleetLoss;\n        }\n    }\n\n    function _computeResolutionResult(ResolutionState memory rState, PlanetUpdateState memory toPlanetUpdate)\n        internal\n        view\n    {\n        if (rState.taxed) {\n            rState.fleetQuantity = uint32(\n                uint256(rState.fleetQuantity) - (uint256(rState.fleetQuantity) * _giftTaxPer10000) / 10000\n            );\n        }\n        if (rState.gifting) {\n            _computeGiftingResolutionResult(rState, toPlanetUpdate);\n        } else {\n            _computeAttackResolutionResult(rState, toPlanetUpdate);\n        }\n    }\n\n    function _computeGiftingResolutionResult(ResolutionState memory rState, PlanetUpdateState memory toPlanetUpdate)\n        internal\n        view\n    {\n        uint256 newNumSpaceships = toPlanetUpdate.numSpaceships + rState.fleetQuantity;\n        if (newNumSpaceships >= ACTIVE_MASK) {\n            newNumSpaceships = ACTIVE_MASK - 1;\n        }\n\n        toPlanetUpdate.numSpaceships = uint32(newNumSpaceships);\n        if (!toPlanetUpdate.active) {\n            // NOTE: not active, overflow is applied on cap = 0\n            if (toPlanetUpdate.numSpaceships > toPlanetUpdate.overflow) {\n                toPlanetUpdate.overflow = toPlanetUpdate.numSpaceships;\n            }\n        } else {\n            uint32 cap = uint32(_capWhenActive(_production(toPlanetUpdate.data)));\n            if (_productionCapAsDuration > 0 && newNumSpaceships > cap) {\n                if (toPlanetUpdate.numSpaceships - cap > toPlanetUpdate.overflow) {\n                    toPlanetUpdate.overflow = uint32(toPlanetUpdate.numSpaceships - cap);\n                }\n            } else {\n                toPlanetUpdate.overflow = 0;\n            }\n        }\n    }\n\n    function _computeAttackResolutionResult(ResolutionState memory rState, PlanetUpdateState memory toPlanetUpdate)\n        internal\n        view\n    {\n        // NOTE natives come back to power once numSPaceships == 0 and planet not active\n        if (!toPlanetUpdate.active && toPlanetUpdate.numSpaceships < _natives(toPlanetUpdate.data)) {\n            _updatePlanetUpdateStateAndResolutionStateForNativeAttack(rState, toPlanetUpdate);\n        } else {\n            // TODO 45min config ?\n            if (block.timestamp < rState.arrivalTime + 45 minutes) {\n                if (!rState.taxed) {\n                    AccumulatedAttack memory acc =\n                        _attacks[toPlanetUpdate.location][rState.fleetOwner][rState.arrivalTime];\n                    if (acc.target == toPlanetUpdate.owner && acc.numAttackSpent != 0) {\n                        rState.attackPower = uint16(\n                            (uint256(rState.attackPower) *\n                                uint256(rState.fleetQuantity) +\n                                uint256(acc.averageAttackPower) *\n                                uint256(acc.numAttackSpent)) /\n                                (uint256(rState.fleetQuantity) + uint256(acc.numAttackSpent))\n                        );\n                        rState.accumulatedAttackAdded = acc.numAttackSpent;\n                        rState.accumulatedDefenseAdded = acc.damageCausedSoFar;\n                    }\n                }\n            }\n\n            _updatePlanetUpdateStateAndResolutionStateForPlanetAttack(rState, toPlanetUpdate);\n        }\n    }\n\n    function _updatePlanetUpdateStateAndResolutionStateForNativeAttack(\n        ResolutionState memory rState,\n        PlanetUpdateState memory toPlanetUpdate\n    ) internal view {\n        // NOTE: when we are dealing with native attacks, we do not consider combined attacks\n        // TODO We need to consider that case in the UI\n        uint16 attack = _attack(rState.fromData);\n        uint16 defense = _defense(toPlanetUpdate.data);\n        uint16 natives = _natives(toPlanetUpdate.data);\n        (uint32 attackerLoss, uint32 defenderLoss) = _computeFight(rState.fleetQuantity, natives, attack, defense);\n        rState.attackerLoss = attackerLoss;\n        if (defenderLoss == natives && rState.fleetQuantity > attackerLoss) {\n            // (attackerLoss: 0, defenderLoss: 0) means that numAttack was zero as natives cannot be zero\n            toPlanetUpdate.numSpaceships = rState.fleetQuantity - attackerLoss;\n            rState.defenderLoss = defenderLoss;\n            rState.victory = true;\n            toPlanetUpdate.newOwner = rState.fleetOwner;\n            // solhint-disable-next-line no-empty-blocks\n        }\n        // NOTE else (attacker lost) then nothing happen\n    }\n\n    function _updatePlanetUpdateStateAndResolutionStateForPlanetAttack(\n        ResolutionState memory rState,\n        PlanetUpdateState memory toPlanetUpdate\n    ) internal view {\n        _updateResolutionStateFromOrbitDefense(rState, toPlanetUpdate);\n        uint256 numDefense =\n            toPlanetUpdate.numSpaceships + rState.accumulatedDefenseAdded + rState.orbitDefense1 + rState.orbitDefense2;\n        uint16 production = _production(toPlanetUpdate.data);\n\n        if (numDefense == 0 && rState.fleetQuantity > 0) {\n            // scenario where there is actually no defense on the place,\n\n            toPlanetUpdate.newOwner = rState.fleetOwner;\n            toPlanetUpdate.numSpaceships = rState.fleetQuantity;\n            if (!toPlanetUpdate.active) {\n                // numDefense = 0 so numAttack is the overflow, attacker took over\n                toPlanetUpdate.overflow = toPlanetUpdate.numSpaceships;\n            } else {\n                if (_productionCapAsDuration > 0) {\n                    uint32 cap = uint32(_capWhenActive(production));\n                    if (toPlanetUpdate.numSpaceships > cap) {\n                        // numDefense = 0 so numAttack is the overflow, attacker took over\n                        toPlanetUpdate.overflow = uint32(toPlanetUpdate.numSpaceships - cap);\n                    } else {\n                        toPlanetUpdate.overflow = 0;\n                    }\n                }\n            }\n\n            rState.victory = true;\n        } else {\n            _computeAttack(rState, toPlanetUpdate, numDefense);\n            _computeTravelingUpkeepReductionFromDefenseLoss(rState, toPlanetUpdate, production);\n        }\n    }\n\n    function _updateResolutionStateFromOrbitDefense(\n        ResolutionState memory rState,\n        PlanetUpdateState memory toPlanetUpdate\n    ) internal view {\n        // -----------------------------------------------------------------------------------------------------------\n        // consider fleets that just departed from the planet (used to prevent front-running, see fleet sending)\n        // -----------------------------------------------------------------------------------------------------------\n        uint256 timeSlot = block.timestamp / (_frontrunningDelay / 2);\n        InFlight storage slot1 = _inFlight[toPlanetUpdate.location][timeSlot - 1];\n        rState.orbitDefense1 = slot1.flying > 2**31 ? 2**31 - 1 : uint32(slot1.flying);\n        rState.orbitDefenseDestroyed1 = slot1.destroyed > 2**31 ? 2**31 - 1 : uint32(slot1.destroyed);\n        InFlight storage slot2 = _inFlight[toPlanetUpdate.location][timeSlot];\n        rState.orbitDefense2 = slot2.flying > 2**31 ? 2**31 - 1 : uint32(slot2.flying);\n        rState.orbitDefenseDestroyed2 = slot2.destroyed > 2**31 ? 2**31 - 1 : uint32(slot2.destroyed);\n    }\n\n    // solhint-disable-next-line code-complexity\n    function _computeAttack(\n        ResolutionState memory rState,\n        PlanetUpdateState memory toPlanetUpdate,\n        uint256 numDefense\n    ) internal view {\n        uint16 attack = rState.attackPower;\n        uint16 defense = _defense(toPlanetUpdate.data);\n        uint256 numAttack = rState.fleetQuantity + rState.accumulatedAttackAdded;\n        (uint32 attackerLoss, uint32 defenderLoss) = _computeFight(numAttack, numDefense, attack, defense);\n        rState.defenderLoss = defenderLoss;\n        rState.attackerLoss = attackerLoss;\n\n        // (attackerLoss: 0, defenderLoss: 0) could either mean attack was zero or defense was zero :\n        if (rState.fleetQuantity > 0 && rState.defenderLoss == numDefense) {\n            // NOTE Attacker wins\n\n            // all orbiting fleets are destroyed, inFlightPlanetLoss is all that is left\n            uint256 inFlightPlanetLoss = numDefense - toPlanetUpdate.numSpaceships - rState.accumulatedDefenseAdded;\n            if (inFlightPlanetLoss > ACTIVE_MASK) {\n                // cap it\n                // TODO investigate potential issues\n                inFlightPlanetLoss = ACTIVE_MASK - 1;\n            }\n            rState.inFlightPlanetLoss = uint32(inFlightPlanetLoss);\n\n            rState.defenderLoss = rState.defenderLoss - rState.inFlightPlanetLoss;\n\n            toPlanetUpdate.numSpaceships = rState.fleetQuantity + rState.accumulatedAttackAdded - attackerLoss;\n            rState.victory = true;\n\n            toPlanetUpdate.newOwner = rState.fleetOwner;\n\n            if (!toPlanetUpdate.active) {\n                // attack took over, overflow is numSpaceships\n                toPlanetUpdate.overflow = toPlanetUpdate.numSpaceships;\n            } else {\n                if (_productionCapAsDuration > 0) {\n                    uint16 production = _production(toPlanetUpdate.data);\n                    uint32 cap = uint32(_capWhenActive(production));\n                    if (toPlanetUpdate.numSpaceships > cap) {\n                        if (toPlanetUpdate.numSpaceships - cap > toPlanetUpdate.overflow) {\n                            toPlanetUpdate.overflow = toPlanetUpdate.numSpaceships - cap;\n                        }\n                    } else {\n                        toPlanetUpdate.overflow = 0;\n                    }\n                }\n            }\n        } else if (rState.attackerLoss == rState.fleetQuantity + rState.accumulatedAttackAdded) {\n            // NOTE Defender wins\n\n            if (defenderLoss > toPlanetUpdate.numSpaceships + rState.accumulatedDefenseAdded) {\n                rState.inFlightPlanetLoss =\n                    defenderLoss -\n                    toPlanetUpdate.numSpaceships -\n                    rState.accumulatedDefenseAdded;\n\n                toPlanetUpdate.numSpaceships = 0;\n                // TODO change owner already if incative ?\n                //  not needed though as this is the same has having numSpaceships = 1 and become zero over time\n\n                if (rState.orbitDefense1 >= rState.inFlightPlanetLoss) {\n                    rState.orbitDefense1 -= rState.inFlightPlanetLoss;\n                    rState.orbitDefenseDestroyed1 += rState.inFlightPlanetLoss;\n                } else {\n                    rState.orbitDefenseDestroyed1 += rState.orbitDefense1;\n                    uint32 extra = (rState.inFlightPlanetLoss - rState.orbitDefense1);\n                    if (rState.orbitDefense2 >= extra) {\n                        rState.orbitDefense2 -= extra;\n                        rState.orbitDefenseDestroyed2 += extra;\n                    } else {\n                        rState.orbitDefenseDestroyed2 += rState.orbitDefense2;\n                        rState.orbitDefense2 = 0; // should never reach minus but let simply set it to zero\n                    }\n                    rState.orbitDefense1 = 0;\n                }\n            } else {\n                toPlanetUpdate.numSpaceships =\n                    toPlanetUpdate.numSpaceships +\n                    rState.accumulatedDefenseAdded -\n                    defenderLoss;\n\n                // TODO change owner already if incative and numSpaceship == 0 (like above)\n                //  not needed though as this is the same has having numSpaceships = 1 and become zero over time\n            }\n\n            rState.defenderLoss = rState.defenderLoss - rState.inFlightPlanetLoss;\n\n            if (!toPlanetUpdate.active) {\n                if (defenderLoss > toPlanetUpdate.overflow) {\n                    toPlanetUpdate.overflow = 0;\n                } else {\n                    toPlanetUpdate.overflow -= defenderLoss;\n                }\n            } else {\n                if (_productionCapAsDuration > 0) {\n                    uint16 production = _production(toPlanetUpdate.data);\n                    uint32 cap = uint32(_capWhenActive(production));\n                    if (toPlanetUpdate.numSpaceships > cap) {\n                        if (defenderLoss <= toPlanetUpdate.overflow) {\n                            toPlanetUpdate.overflow -= defenderLoss;\n                        } else {\n                            toPlanetUpdate.overflow = 0;\n                        }\n                    } else {\n                        toPlanetUpdate.overflow = 0;\n                    }\n                }\n            }\n        } else {\n            // should not happen\n            // because we check for numDefense == 0 before performing the attack, see _updatePlanetUpdateStateAndResolutionStateForPlanetAttack\n            revert(\"ZERO_ZERO\");\n        }\n    }\n\n    function _computeFight(\n        uint256 numAttack,\n        uint256 numDefense,\n        uint256 attack,\n        uint256 defense\n    ) internal view returns (uint32 attackerLoss, uint32 defenderLoss) {\n        if (numAttack == 0 || numDefense == 0) {\n            // this edge case need to be considered,\n            // as the result of this function cannot tell from it whos is winning here\n            return (0, 0);\n        }\n\n        uint256 attackFactor =\n            numAttack * ((1000000 - _fleetSizeFactor6) + ((_fleetSizeFactor6 * numAttack) / numDefense));\n        uint256 attackDamage = (attackFactor * attack) / defense / 1000000;\n\n        if (numDefense > attackDamage) {\n            // attack fails\n            attackerLoss = uint32(numAttack); // all attack destroyed\n            defenderLoss = uint32(attackDamage); // 1 spaceship will be left at least as attackDamage < numDefense\n        } else {\n            // attack succeed\n            uint256 defenseFactor =\n                numDefense * ((1000000 - _fleetSizeFactor6) + ((_fleetSizeFactor6 * numDefense) / numAttack));\n            uint256 defenseDamage = uint32((defenseFactor * defense) / attack / 1000000);\n\n            if (defenseDamage >= numAttack) {\n                defenseDamage = numAttack - 1; // ensure 1 spaceship left\n            }\n\n            attackerLoss = uint32(defenseDamage);\n            defenderLoss = uint32(numDefense); // all defense destroyed\n        }\n    }\n\n    function _computeTravelingUpkeepReductionFromDefenseLoss(\n        ResolutionState memory rState,\n        PlanetUpdateState memory toPlanetUpdate,\n        uint16 production\n    ) internal view {\n        // allow the attacker to pay for upkeep as part of the attack\n        // only get to keep the upkeep that was there as a result of spaceships sent away\n\n        uint256 capWhenActive = _capWhenActive(production);\n\n        int256 totalDefenseLoss = int256(uint256(rState.defenderLoss) + uint256(rState.inFlightPlanetLoss));\n        int256 newTravelingUpkeep = int256(toPlanetUpdate.travelingUpkeep) - totalDefenseLoss;\n        if (newTravelingUpkeep < -int256(capWhenActive)) {\n            newTravelingUpkeep = -int256(capWhenActive);\n        }\n        toPlanetUpdate.travelingUpkeep = int40(newTravelingUpkeep);\n    }\n\n    function _recordInOrbitLossAfterAttack(ResolutionState memory rState, PlanetUpdateState memory toPlanetUpdate)\n        internal\n    {\n        if (rState.inFlightPlanetLoss > 0) {\n            InFlight storage slot1 = _inFlight[toPlanetUpdate.location][block.timestamp / (_frontrunningDelay / 2) - 1];\n            slot1.flying = rState.orbitDefense1;\n            slot1.destroyed = rState.orbitDefenseDestroyed1;\n\n            InFlight storage slot2 = _inFlight[toPlanetUpdate.location][block.timestamp / (_frontrunningDelay / 2)];\n            slot2.flying = rState.orbitDefense2;\n            slot2.destroyed = rState.orbitDefenseDestroyed2;\n        }\n    }\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // PLANET STATS\n    // ---------------------------------------------------------------------------------------------------------------\n\n    function _planetData(uint256 location) internal view returns (bytes32) {\n        return keccak256(abi.encodePacked(_genesis, location));\n    }\n\n    function _subLocation(bytes32 data) internal pure returns (int8 subX, int8 subY) {\n        subX = 1 - int8(data.value8Mod(0, 3));\n        subY = 1 - int8(data.value8Mod(2, 3));\n    }\n\n    function _stake(bytes32 data) internal view returns (uint32) {\n        require(_exists(data), \"PLANET_NOT_EXISTS\");\n        // return data.normal16(4, 0x000400050005000A000A000F000F00140014001E001E00280028005000500064);\n        uint8 productionIndex = data.normal8(12); // production affect the stake value\n\n        // TODO remove or decide otherwise:\n        // uint16 offset = data.normal16(4, 0x0000000100010002000200030003000400040005000500060006000700070008);\n        // uint16 stakeIndex = productionIndex + offset;\n        // if (stakeIndex < 4) {\n        //     stakeIndex = 0;\n        // } else if (stakeIndex > 19) {\n        //     stakeIndex = 15;\n        // } else {\n        //     stakeIndex -= 4;\n        // }\n        uint16 stakeIndex = productionIndex;\n        // skip stakeIndex * 2 + 0 as it is always zero in stakeRange\n        return uint32(((uint256(uint8(_stakeRange[stakeIndex * 2 + 1])) * _stakeMultiplier10000th) / 1000) * 1000); // round to 1 decimal\n    }\n\n    function _production(bytes32 data) internal pure returns (uint16) {\n        require(_exists(data), \"PLANET_NOT_EXISTS\");\n        // TODO TRY : 1800,2100,2400,2700,3000,3300,3600, 3600, 3600, 3600,4000,4400,4800,5400,6200,7200 ?\n\n        // 1800,2100,2400,2700,3000,3300,3600, 3600, 3600, 3600,4200,5400,6600,7800,9000,12000\n        // 0x0708083409600a8c0bb80ce40e100e100e100e101068151819c81e7823282ee0\n        return data.normal16(12, 0x0708083409600a8c0bb80ce40e100e100e100e101068151819c81e7823282ee0); // per hour\n    }\n\n    function _capWhenActive(uint16 production) internal view returns (uint256) {\n        return _acquireNumSpaceships + (uint256(production) * _productionCapAsDuration) / 1 hours;\n    }\n\n    function _attack(bytes32 data) internal pure returns (uint16) {\n        require(_exists(data), \"PLANET_NOT_EXISTS\");\n        return 4000 + data.normal8(20) * 400; // 4,000 - 7,000 - 10,000\n    }\n\n    function _defense(bytes32 data) internal pure returns (uint16) {\n        require(_exists(data), \"PLANET_NOT_EXISTS\");\n        return 4000 + data.normal8(28) * 400; // 4,000 - 7,000 - 10,000\n    }\n\n    function _speed(bytes32 data) internal pure returns (uint16) {\n        require(_exists(data), \"PLANET_NOT_EXISTS\");\n        return 5005 + data.normal8(36) * 333; // 5,005 - 7,502.5 - 10,000\n    }\n\n    function _natives(bytes32 data) internal pure returns (uint16) {\n        require(_exists(data), \"PLANET_NOT_EXISTS\");\n        return 15000 + data.normal8(44) * 3000; // 15,000 - 37,500 - 60,000\n    }\n\n    function _exists(bytes32 data) internal pure returns (bool) {\n        return data.value8Mod(52, 16) == 1; // 16 => 36 so : 1 planet per 6 (=24 min unit) square\n        // also:\n        // 20000 average starting numSpaceships (or max?)\n        // speed of min unit = 30 min ( 1 hour per square)\n        // production : 20000 per 6 hours\n        // exit : 3 days ? => 72 distance\n    }\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // GETTERS\n    // ---------------------------------------------------------------------------------------------------------------\n\n    function _getPlanet(uint256 location) internal view returns (Planet storage) {\n        return _planets[location];\n    }\n\n    function _getPlanetStats(uint256 location) internal view returns (PlanetStats memory) {\n        bytes32 data = _planetData(location);\n        require(_exists(data), \"no planet in this location\");\n\n        (int8 subX, int8 subY) = _subLocation(data);\n        return\n            PlanetStats({\n                subX: subX,\n                subY: subY,\n                stake: _stake(data),\n                production: _production(data),\n                attack: _attack(data),\n                defense: _defense(data),\n                speed: _speed(data),\n                natives: _natives(data)\n            });\n    }\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // UTILS\n    // ---------------------------------------------------------------------------------------------------------------\n\n    function _activeNumSpaceships(uint32 numSpaceshipsData) internal pure returns (bool active, uint32 numSpaceships) {\n        active = (numSpaceshipsData & ACTIVE_MASK) == ACTIVE_MASK;\n        numSpaceships = numSpaceshipsData % (ACTIVE_MASK);\n    }\n\n    function _setActiveNumSpaceships(bool active, uint32 numSpaceships) internal pure returns (uint32) {\n        return uint32((active ? ACTIVE_MASK : 0) + numSpaceships);\n    }\n\n    function _msgSender() internal view returns (address) {\n        return msg.sender; // TODO metatx\n    }\n}\n"
    },
    "src/outerspace/types/ImportingOuterSpaceTypes.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface ImportingOuterSpaceTypes {\n    // front running protection : _frontruunningDelay / 2 slots\n    struct InFlight {\n        uint32 flying;\n        uint32 destroyed;\n        // STORE last attack too, to compute combined attack on it ? uint128 is plainty enough\n    }\n\n    // TODO remove\n    // struct Account {\n    //     // TODO add more info\n    //     // stake for example ? => coild it be used by staking ?\n    //     // numPlanets ?\n    //     // numSpaceships ? => probably too much ?\n    //     uint64 totalProduction;\n    //     uint64 productionDebt;\n    // }\n\n    struct Discovered {\n        uint32 minX;\n        uint32 maxX;\n        uint32 minY;\n        uint32 maxY;\n    }\n\n    // TODO split in 2 structs ? PlanetOwnership and PlanetState ?\n    struct Planet {\n        address owner;\n        uint40 ownershipStartTime; // ~ 34865 years, should be enough :)\n        uint40 exitStartTime; // ~ 34865 years, should be enough :)\n        // TODO uint16 ?\n        ///\n        uint32 numSpaceships; // uint31 + first bit => active // TODO use bool active ?\n        uint40 lastUpdated; // ~ 34865 years, should be enough :)\n        int40 travelingUpkeep; // decrease per _upkeepProductionDecreaseRatePer10000th  * production\n        uint32 overflow;\n        // bool active; // TODO ?\n        // bool exiting; // TODO ?\n    }\n\n    struct Fleet {\n        address owner;\n        uint40 launchTime; // ~ 34865 years, should be enough :)\n        uint32 quantity; // TODO? first bit = done? to keep quantity value on-chain post resolution, actually not needed, can be given in the hash\n        uint24 futureExtraProduction;\n        // we got 24bit more to store if needed\n        // operator ? // signer ?\n    }\n\n    struct PlanetStats {\n        int8 subX;\n        int8 subY;\n        uint32 stake;\n        uint16 production;\n        uint16 attack;\n        uint16 defense;\n        uint16 speed;\n        uint16 natives;\n    }\n\n    struct ExternalPlanet {\n        address owner;\n        uint40 ownershipStartTime; // ~ 34865 years, should be enough :)\n        uint40 exitStartTime; // ~ 34865 years, should be enough :)\n        uint32 numSpaceships;\n        uint32 overflow;\n        uint40 lastUpdated; // ~ 34865 years, should be enough :)\n        bool active;\n        // bool exiting;\n        uint256 reward;\n    }\n\n    struct FleetLaunch {\n        address fleetSender;\n        address fleetOwner;\n        uint256 from;\n        uint32 quantity;\n        bytes32 toHash;\n    }\n    struct FleetResolution {\n        uint256 from;\n        uint256 to;\n        uint256 distance;\n        uint256 arrivalTimeWanted;\n        bool gift;\n        address specific;\n        bytes32 secret;\n        address fleetSender; // does not work ?\n        address operator; // should be saved ?\n    }\n\n    struct AccumulatedAttack {\n        address target;\n        uint32 numAttackSpent;\n        uint32 damageCausedSoFar;\n        uint16 averageAttackPower;\n    }\n}\n"
    },
    "src/outerspace/base/ImportingOuterSpaceConstants.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\ncontract ImportingOuterSpaceConstants {\n    uint256 internal constant DECIMALS_18 = 1e18;\n    uint256 internal constant DECIMALS_14 = 1e14;\n    uint32 internal constant ACTIVE_MASK = 2**31;\n    int256 internal constant UINT32_MAX = 2**32 - 1;\n    int256 internal constant UINT32_MIN = -2147483648;\n}\n"
    },
    "src/outerspace/events/ImportingOuterSpaceEvents.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\ninterface ImportingOuterSpaceEvents {\n    event PlanetStake(\n        address indexed acquirer,\n        uint256 indexed location,\n        uint32 numSpaceships,\n        int40 travelingUpkeep,\n        uint32 overflow,\n        uint256 stake,\n        bool freegift\n    );\n    event FleetSent(\n        address indexed fleetSender,\n        address indexed fleetOwner,\n        uint256 indexed from,\n        address operator,\n        uint256 fleet,\n        uint32 quantity,\n        uint32 newNumSpaceships,\n        int40 newTravelingUpkeep,\n        uint32 newOverflow\n    );\n\n    struct ArrivalData {\n        uint32 newNumspaceships;\n        int40 newTravelingUpkeep;\n        uint32 newOverflow;\n        uint32 numSpaceshipsAtArrival;\n        uint32 taxLoss;\n        uint32 fleetLoss;\n        uint32 planetLoss;\n        uint32 inFlightFleetLoss;\n        uint32 inFlightPlanetLoss;\n        uint32 accumulatedDefenseAdded;\n        uint32 accumulatedAttackAdded;\n    }\n\n    event FleetArrived(\n        uint256 indexed fleet,\n        address indexed fleetOwner,\n        address indexed destinationOwner,\n        uint256 destination,\n        bool gift,\n        bool won,\n        ArrivalData data\n    );\n\n    event TravelingUpkeepRefund(\n        uint256 indexed origin,\n        uint256 indexed fleet,\n        uint32 newNumspaceships,\n        int40 newTravelingUpkeep,\n        uint32 newOverflow\n    );\n\n    event PlanetTransfer(\n        address indexed previousOwner,\n        address indexed newOwner,\n        uint256 indexed location,\n        uint32 newNumspaceships,\n        int40 newTravelingUpkeep,\n        uint32 newOverflow\n    );\n\n    event PlanetReset(uint256 indexed location);\n\n    event PlanetExit(address indexed owner, uint256 indexed location);\n\n    event ExitComplete(address indexed owner, uint256 indexed location, uint256 stake);\n\n    event RewardSetup(uint256 indexed location, address indexed giver, uint256 rewardId);\n    event RewardToWithdraw(address indexed owner, uint256 indexed location, uint256 indexed rewardId);\n\n    event StakeToWithdraw(address indexed owner, uint256 newStake, bool freegift);\n\n    event Initialized(\n        bytes32 genesis,\n        uint256 resolveWindow,\n        uint256 timePerDistance,\n        uint256 exitDuration,\n        uint32 acquireNumSpaceships,\n        uint32 productionSpeedUp,\n        uint256 frontrunningDelay,\n        uint256 productionCapAsDuration,\n        uint256 upkeepProductionDecreaseRatePer10000th,\n        uint256 fleetSizeFactor6,\n        uint32 initialSpaceExpansion,\n        uint32 expansionDelta,\n        uint256 giftTaxPer10000\n    );\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    // TODO use it\n    event Transfer(address indexed from, address indexed to, uint256 indexed location);\n}\n"
    },
    "src/outerspace/base/UsingOuterSpaceDataLayout.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"../types/ImportingOuterSpaceTypes.sol\";\n\ncontract UsingOuterSpaceDataLayout is ImportingOuterSpaceTypes {\n    mapping(uint256 => Planet) internal _planets;\n    mapping(uint256 => Fleet) internal _fleets;\n\n    mapping(address => uint256) internal _stakeReadyToBeWithdrawn;\n\n    mapping(address => mapping(address => bool)) internal _operators;\n\n    // TODO make it namespaces per user, currently it is possible (though unlikely) for 2 users to share a slot if one attack another and quickly send away spaceships\n    mapping(uint256 => mapping(uint256 => InFlight)) internal _inFlight;\n\n    Discovered internal _discovered;\n    // rewards\n    mapping(address => uint256) internal _prevRewardIds;\n    mapping(uint256 => uint256) internal _rewards;\n    mapping(address => mapping(uint256 => bool)) internal _rewardsToWithdraw;\n\n    // This adds 20,000 gas to all resolution\n    mapping(uint256 => mapping(address => mapping(uint256 => AccumulatedAttack))) internal _attacks;\n\n    mapping(address => uint256) internal _freeStakeReadyToBeWithdrawn;\n    mapping(uint256 => uint256) internal _planetFlagged;\n}\n"
    },
    "src/libraries/Extraction.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity 0.8.9;\n\n// TODO remove\nimport \"hardhat/console.sol\";\n\nlibrary Extraction {\n    function value(\n        bytes32 data,\n        uint8 leastSignificantBit,\n        uint8 size\n    ) internal pure returns (uint256) {\n        return uint256((data >> leastSignificantBit)) % 2**size;\n    }\n\n    function value8Mod(\n        bytes32 data,\n        uint8 leastSignificantBit,\n        uint8 mod\n    ) internal pure returns (uint8) {\n        return uint8(uint256((data >> leastSignificantBit)) % mod);\n    }\n\n    function value8(bytes32 data, uint8 leastSignificantBit) internal pure returns (uint8) {\n        return uint8(uint256((data >> leastSignificantBit)) % 2**8);\n    }\n\n    // 1+1+2+3+4+6+7+8+8+7+6+4+3+2+1+1 // aproximation of normal distribution with mean=7.5 and standard deviation=3 for 16 values\n    bytes32 constant n_m7_5_sd3 = 0x01223334444555555666666677777777888888889999999AAAAAABBBBCCCDDEF;\n\n    function normal8(bytes32 data, uint8 leastSignificantBit) internal pure returns (uint8) {\n        uint8 index = value8Mod(data, leastSignificantBit, 64);\n        uint8 first = index / 2;\n        uint8 second = index % 2;\n        uint8 slot = uint8(n_m7_5_sd3[first]);\n        if (second == 0) {\n            return slot >> 4;\n        } else {\n            return slot % 16;\n        }\n    }\n\n    function normal16(\n        bytes32 data,\n        uint8 leastSignificantBit,\n        bytes32 selection\n    ) internal pure returns (uint16) {\n        uint8 index = normal8(data, leastSignificantBit);\n        return uint16(uint8(selection[index * 2])) * 2**8 + uint16(uint8(selection[index * 2 + 1]));\n    }\n}\n"
    },
    "src/libraries/Math.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity 0.8.9;\n\nlibrary Math {\n    function mul(\n        uint256 a,\n        uint256 b,\n        string memory overflowError\n    ) internal pure returns (uint256 c) {\n        require(b == 0 || a == 0 || ((c = a * b) / b) == a, overflowError);\n    }\n\n    function add(\n        uint256 a,\n        uint256 b,\n        string memory overflowError\n    ) internal pure returns (uint256 c) {\n        require((c = a + b) >= a, overflowError);\n    }\n\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory underflowError\n    ) internal pure returns (uint256 c) {\n        require((c = a - b) <= a, underflowError);\n    }\n\n    function mul18(\n        uint256 a18,\n        uint256 b18,\n        string memory overflowError\n    ) internal pure returns (uint256) {\n        return mul(a18, b18, overflowError) / 10**18;\n    }\n\n    function div18(\n        uint256 a18,\n        uint256 b18,\n        string memory overflowError\n    ) internal pure returns (uint256) {\n        return mul(a18, 10**18, overflowError) / b18;\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a <= b ? a : b;\n    }\n\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    function smin(int256 a, int256 b) internal pure returns (int256) {\n        return a <= b ? a : b;\n    }\n\n    function smax(int256 a, int256 b) internal pure returns (int256) {\n        return a >= b ? a : b;\n    }\n\n    function sqrt(uint256 a) internal pure returns (uint256 c) {\n        uint256 tmp = (a + 1) / 2;\n        c = a;\n        while (tmp < c) {\n            c = tmp;\n            tmp = ((a / tmp) + tmp) / 2;\n        }\n    }\n}\n"
    },
    "src/interfaces/IAlliance.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity 0.8.9;\n\ninterface IAlliance {\n    function requestToJoin(address player, bytes calldata data) external returns (bool);\n\n    function playerHasLeft(address player) external;\n}\n"
    },
    "src/alliances/AllianceRegistry.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity 0.8.9;\n\nimport \"hardhat-deploy/solc_0.8/proxy/Proxied.sol\";\nimport \"../interfaces/IAlliance.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n// import \"hardhat/console.sol\";\n\ncontract AllianceRegistry is Proxied {\n    using ECDSA for bytes32;\n\n    uint8 internal constant MAX_NUM_ALLIANCES = 4;\n\n    mapping(address => mapping(IAlliance => uint256)) internal _allianceNonces;\n    struct AllianceRow {\n        IAlliance alliance;\n        uint96 joinTime;\n    }\n    struct Alliances {\n        AllianceRow alliance0;\n        AllianceRow alliance1;\n        AllianceRow alliance2;\n        AllianceRow alliance3;\n    }\n    mapping(address => Alliances) internal _alliances;\n\n    event AllianceLink(IAlliance indexed alliance, address indexed player, bool joining);\n\n    function getAllianceDataAtSlot(address player, uint8 slot)\n        external\n        view\n        returns (\n            IAlliance alliance,\n            uint96 joinTime,\n            uint256 nonce\n        )\n    {\n        Alliances storage alliances = _alliances[player];\n        if (slot == 0) {\n            alliance = alliances.alliance0.alliance;\n            joinTime = alliances.alliance0.joinTime;\n        } else if (slot == 1) {\n            alliance = alliances.alliance1.alliance;\n            joinTime = alliances.alliance1.joinTime;\n        } else if (slot == 2) {\n            alliance = alliances.alliance2.alliance;\n            joinTime = alliances.alliance2.joinTime;\n        } else if (slot == 3) {\n            alliance = alliances.alliance3.alliance;\n            joinTime = alliances.alliance3.joinTime;\n        }\n\n        nonce = _allianceNonces[player][alliance];\n    }\n\n    function getAllianceData(address player, IAlliance alliance) public view returns (uint96 joinTime, uint256 nonce) {\n        nonce = _allianceNonces[player][alliance];\n\n        Alliances storage alliances = _alliances[player];\n        if (alliances.alliance0.alliance == alliance) {\n            joinTime = alliances.alliance0.joinTime;\n        } else if (alliances.alliance1.alliance == alliance) {\n            joinTime = alliances.alliance1.joinTime;\n        } else if (alliances.alliance2.alliance == alliance) {\n            joinTime = alliances.alliance2.joinTime;\n        } else if (alliances.alliance3.alliance == alliance) {\n            joinTime = alliances.alliance3.joinTime;\n        }\n    }\n\n    function havePlayersAnAllianceInCommon(\n        address player1,\n        address player2,\n        uint256 timestamp\n    ) external view returns (IAlliance alliance, uint96 joinTime) {\n        Alliances storage p1Alliances = _alliances[player1];\n        Alliances storage p2Alliances = _alliances[player2];\n\n        AllianceRow[4] memory player1Alliances;\n        AllianceRow[4] memory player2Alliances;\n        uint256 num1 = 0;\n        uint256 num2 = 0;\n\n        for (uint256 i = 0; i < 4; i++) {\n            if (i == num1) {\n                AllianceRow memory allianceRow;\n                if (i == 0) {\n                    allianceRow = p1Alliances.alliance0;\n                } else if (i == 1) {\n                    allianceRow = p1Alliances.alliance1;\n                } else if (i == 2) {\n                    allianceRow = p1Alliances.alliance2;\n                } else if (i == 3) {\n                    allianceRow = p1Alliances.alliance3;\n                }\n                if (address(allianceRow.alliance) == address(0)) {\n                    // console.log(\"p1 exhausted\");\n                    return (alliance, joinTime); // the alliance leave ensure that there is no gap // TODO\n                }\n                player1Alliances[num1++] = allianceRow;\n            }\n            for (uint256 j = 0; j < 4; j++) {\n                if (j == num2) {\n                    AllianceRow memory allianceRow;\n                    if (j == 0) {\n                        allianceRow = p2Alliances.alliance0;\n                    } else if (j == 1) {\n                        allianceRow = p2Alliances.alliance1;\n                    } else if (j == 2) {\n                        allianceRow = p2Alliances.alliance2;\n                    } else if (j == 3) {\n                        allianceRow = p2Alliances.alliance3;\n                    }\n                    if (address(allianceRow.alliance) == address(0)) {\n                        // console.log(\"p2 exhausted\");\n                        // return (alliance, joinTime); // the alliance leave ensure that there is no gap // TODO\n                        break;\n                    }\n                    player2Alliances[num2++] = allianceRow;\n                }\n\n                if (player1Alliances[i].alliance == player2Alliances[j].alliance) {\n                    if (player1Alliances[i].joinTime >= player2Alliances[j].joinTime) {\n                        if (player1Alliances[i].joinTime < timestamp) {\n                            return (player1Alliances[i].alliance, player1Alliances[i].joinTime);\n                        } else {\n                            // TODO check greater ?\n                            alliance = player1Alliances[i].alliance;\n                            joinTime = player1Alliances[i].joinTime;\n                        }\n                    } else {\n                        if (player2Alliances[j].joinTime < timestamp) {\n                            return (player2Alliances[j].alliance, player2Alliances[j].joinTime);\n                        } else {\n                            // TODO check greater ?\n                            alliance = player2Alliances[j].alliance;\n                            joinTime = player2Alliances[j].joinTime;\n                        }\n                    }\n                }\n            }\n        }\n        // console.log(address(alliance));\n        // console.log(joinTime);\n    }\n\n    // -----------------------------------------------------------------------------------------------------\n    // FROM PLAYER\n    // -----------------------------------------------------------------------------------------------------\n\n    function joinAlliance(IAlliance alliance, bytes calldata data) external returns (bool joined) {\n        Alliances storage alliances = _alliances[msg.sender];\n        uint256 slot = 0;\n        if (address(alliances.alliance0.alliance) != address(0)) {\n            slot++;\n        }\n        if (address(alliances.alliance1.alliance) != address(0)) {\n            slot++;\n        }\n        if (address(alliances.alliance2.alliance) != address(0)) {\n            slot++;\n        }\n        require(address(alliances.alliance3.alliance) == address(0), \"MAX_NUM_ALLIANCES_REACHED\");\n\n        joined = alliance.requestToJoin(msg.sender, data);\n        if (joined) {\n            if (slot == 0) {\n                alliances.alliance0.alliance = alliance;\n                alliances.alliance0.joinTime = uint96(block.timestamp);\n            } else if (slot == 1) {\n                alliances.alliance1.alliance = alliance;\n                alliances.alliance1.joinTime = uint96(block.timestamp);\n            } else if (slot == 2) {\n                alliances.alliance2.alliance = alliance;\n                alliances.alliance2.joinTime = uint96(block.timestamp);\n            } else if (slot == 3) {\n                alliances.alliance3.alliance = alliance;\n                alliances.alliance3.joinTime = uint96(block.timestamp);\n            }\n\n            emit AllianceLink(alliance, msg.sender, true);\n        }\n    }\n\n    function leaveAlliance(IAlliance alliance) external {\n        _leaveAlliance(msg.sender, alliance);\n        try alliance.playerHasLeft(msg.sender) {} catch {}\n        // TODO ensure callback not failed due to low gas (1/64 rule)\n    }\n\n    // -----------------------------------------------------------------------------------------------------\n    // FROM ALLIANCE\n    // -----------------------------------------------------------------------------------------------------\n\n    function addPlayerToAlliance(\n        address player,\n        uint32 nonce,\n        bytes calldata signature\n    ) external {\n        _addPlayerToAlliance(player, nonce, signature);\n    }\n\n    struct PlayerSubmission {\n        address addr;\n        uint32 nonce;\n        bytes signature;\n    }\n\n    function addMultiplePlayersToAlliance(PlayerSubmission[] calldata playerSubmissions) external {\n        for (uint256 i = 0; i < playerSubmissions.length; i++) {\n            _addPlayerToAlliance(playerSubmissions[i].addr, playerSubmissions[i].nonce, playerSubmissions[i].signature);\n        }\n    }\n\n    function ejectPlayerFromAlliance(address player) external {\n        _leaveAlliance(player, IAlliance(msg.sender));\n    }\n\n    // -----------------------------------------------------------------------------------------------------\n    // INTERNAL\n    // -----------------------------------------------------------------------------------------------------\n\n    function _addPlayerToAlliance(\n        address player,\n        uint32 nonce,\n        bytes calldata signature\n    ) internal {\n        IAlliance alliance = IAlliance(msg.sender);\n\n        Alliances storage alliances = _alliances[player];\n        uint256 slot = 0;\n        if (address(alliances.alliance0.alliance) != address(0)) {\n            require(alliances.alliance0.alliance != alliance, \"ALREADY_JOINED\");\n            slot++;\n        }\n        if (address(alliances.alliance1.alliance) != address(0)) {\n            require(alliances.alliance1.alliance != alliance, \"ALREADY_JOINED\");\n            slot++;\n        }\n        if (address(alliances.alliance2.alliance) != address(0)) {\n            require(alliances.alliance2.alliance != alliance, \"ALREADY_JOINED\");\n            slot++;\n        }\n        require(alliances.alliance3.alliance != alliance, \"ALREADY_JOINED\");\n        require(address(alliances.alliance3.alliance) == address(0), \"MAX_NUM_ALLIANCES_REACHED\");\n\n        uint256 currentNonce = _allianceNonces[player][alliance];\n        require(currentNonce == nonce, \"INVALID_NONCE\");\n\n        bytes memory message;\n        if (nonce == 0) {\n            message = abi.encodePacked(\n                \"\\x19Ethereum Signed Message:\\n56\",\n                \"Join Alliance 0x0000000000000000000000000000000000000000\"\n            );\n            _writeUintAsHex(message, 28 + 55, uint160(msg.sender));\n        } else {\n            message = abi.encodePacked(\n                \"\\x19Ethereum Signed Message:\\n76\",\n                \"Join Alliance 0x0000000000000000000000000000000000000000 (nonce:          0)\"\n            );\n            _writeUintAsHex(message, 28 + 55, uint160(msg.sender));\n            _writeUintAsDecimal(message, 28 + 74, nonce);\n        }\n\n        // console.log(string(message));\n\n        bytes32 digest = keccak256(message);\n\n        address signer = digest.recover(signature);\n        require(player == signer, \"INVALID_SIGNATURE\");\n\n        if (slot == 0) {\n            alliances.alliance0.alliance = alliance;\n            alliances.alliance0.joinTime = uint96(block.timestamp);\n        } else if (slot == 1) {\n            alliances.alliance1.alliance = alliance;\n            alliances.alliance1.joinTime = uint96(block.timestamp);\n        } else if (slot == 2) {\n            alliances.alliance2.alliance = alliance;\n            alliances.alliance2.joinTime = uint96(block.timestamp);\n        } else if (slot == 3) {\n            alliances.alliance3.alliance = alliance;\n            alliances.alliance3.joinTime = uint96(block.timestamp);\n        }\n        _allianceNonces[player][alliance] = nonce + 1;\n\n        emit AllianceLink(alliance, player, true);\n\n        _checkERC1155AndCallSafeTransfer(msg.sender, address(0), player, uint256(uint160(address(alliance))), 1);\n        emit TransferSingle(msg.sender, address(0), player, uint256(uint160(address(alliance))), 1);\n    }\n\n    bytes internal constant hexAlphabet = \"0123456789abcdef\";\n    bytes internal constant decimalAlphabet = \"0123456789\";\n\n    function _writeUintAsHex(\n        bytes memory data,\n        uint256 endPos,\n        uint256 num\n    ) internal pure {\n        while (num != 0) {\n            data[endPos--] = bytes1(hexAlphabet[num % 16]);\n            num /= 16;\n        }\n    }\n\n    function _writeUintAsDecimal(\n        bytes memory data,\n        uint256 endPos,\n        uint256 num\n    ) internal pure {\n        while (num != 0) {\n            data[endPos--] = bytes1(decimalAlphabet[num % 10]);\n            num /= 10;\n        }\n    }\n\n    function _leaveAlliance(address player, IAlliance alliance) internal {\n        Alliances storage alliances = _alliances[msg.sender];\n\n        IAlliance lastSlotAlliance;\n        uint96 lastSlotJoinTime;\n\n        require(address(alliances.alliance0.alliance) != address(0), \"NOT_PART_OF_ANY_ALLIANCE\");\n\n        if (address(alliances.alliance1.alliance) == address(0)) {\n            lastSlotAlliance = alliances.alliance0.alliance;\n            lastSlotJoinTime = alliances.alliance0.joinTime;\n            alliances.alliance0.alliance = IAlliance(address(0));\n            alliances.alliance0.joinTime = 0;\n        } else {\n            if (address(alliances.alliance2.alliance) == address(0)) {\n                lastSlotAlliance = alliances.alliance1.alliance;\n                lastSlotJoinTime = alliances.alliance1.joinTime;\n                alliances.alliance1.alliance = IAlliance(address(0));\n                alliances.alliance1.joinTime = 0;\n            } else {\n                if (address(alliances.alliance3.alliance) == address(0)) {\n                    lastSlotAlliance = alliances.alliance2.alliance;\n                    lastSlotJoinTime = alliances.alliance2.joinTime;\n                    alliances.alliance2.alliance = IAlliance(address(0));\n                    alliances.alliance2.joinTime = 0;\n                } else {\n                    lastSlotAlliance = alliances.alliance3.alliance;\n                    lastSlotJoinTime = alliances.alliance3.joinTime;\n                    alliances.alliance3.alliance = IAlliance(address(0));\n                    alliances.alliance3.joinTime = 0;\n                }\n            }\n        }\n\n        if (alliance != lastSlotAlliance) {\n            if (alliances.alliance0.alliance == alliance) {\n                alliances.alliance0.alliance = lastSlotAlliance;\n                alliances.alliance0.joinTime = lastSlotJoinTime;\n            } else if (alliances.alliance1.alliance == alliance) {\n                alliances.alliance1.alliance = lastSlotAlliance;\n                alliances.alliance1.joinTime = lastSlotJoinTime;\n            } else if (alliances.alliance2.alliance == alliance) {\n                alliances.alliance2.alliance = lastSlotAlliance;\n                alliances.alliance2.joinTime = lastSlotJoinTime;\n            } else {\n                revert(\"NOT_PART_OF_THE_ALLIANCE\");\n            }\n        }\n\n        emit AllianceLink(alliance, player, false);\n        emit TransferSingle(msg.sender, player, address(0), uint256(uint160(address(alliance))), 1);\n    }\n\n    function _msgSender() internal view returns (address) {\n        return msg.sender; // TODO metatx\n    }\n\n    // ---------------------------------------------------------------------\n    // Support For ERC-1155\n    // ---------------------------------------------------------------------\n\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    function balanceOf(address owner, uint256 id) external view returns (uint256 balance) {\n        require(id == uint160(id), \"INVALID_ID\");\n        (uint96 joinTime, ) = getAllianceData(owner, IAlliance(address(uint160(id))));\n        if (joinTime > 0) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory balances)\n    {\n        balances = new uint256[](owners.length);\n        for (uint256 i = 0; i < owners.length; i++) {\n            require(ids[i] == uint160(ids[i]), \"INVALID_ID\");\n            (uint96 joinTime, ) = getAllianceData(owners[i], IAlliance(address(uint160(ids[i]))));\n            if (joinTime > 0) {\n                balances[i] = 1;\n            } else {\n                balances[i] = 0;\n            }\n        }\n    }\n\n    function isApprovedForAll(address, address) external pure returns (bool) {\n        return false;\n    }\n\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool) {\n        return interfaceID == 0xd9b67a26 || interfaceID == 0x01ffc9a7;\n    }\n\n    function _checkERC1155AndCallSafeTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 value\n    ) internal returns (bool) {\n        if (!Address.isContract(to)) {\n            return true;\n        }\n\n        return ERC1155TokenReceiver(to).onERC1155Received(operator, from, id, value, \"\") == 0xf23a6e61;\n    }\n}\n\ninterface ERC1155TokenReceiver {\n    function onERC1155Received(\n        address _operator,\n        address _from,\n        uint256 _id,\n        uint256 _value,\n        bytes calldata _data\n    ) external returns (bytes4);\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "src/outerspace/facets/OuterSpaceStakingFacet.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"./OuterSpaceFacetBase.sol\";\n\ncontract OuterSpaceStakingFacet is OuterSpaceFacetBase {\n    constructor(Config memory config) OuterSpaceFacetBase(config) {}\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // STAKING / PRODUCTION CAPTURE\n    // ---------------------------------------------------------------------------------------------------------------\n\n    function onTokenTransfer(\n        address,\n        uint256 amount,\n        bytes calldata data\n    ) public returns (bool) {\n        bool freegift;\n        if (msg.sender == address(_freeStakingToken)) {\n            freegift = true;\n        } else {\n            require(msg.sender == address(_stakingToken), \"INVALID_ERC20\");\n        }\n\n        (address acquirer, uint256 location) = abi.decode(data, (address, uint256));\n        _acquire(acquirer, amount, location, freegift); // we do not care of who the payer is\n        return true;\n    }\n\n    function onTokenPaidFor(\n        address,\n        address forAddress,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool) {\n        bool freegift;\n        if (msg.sender == address(_freeStakingToken)) {\n            freegift = true;\n        } else {\n            require(msg.sender == address(_stakingToken), \"INVALID_ERC20\");\n        }\n        uint256 location = abi.decode(data, (uint256));\n        _acquire(forAddress, amount, location, freegift); // we do not care of who the payer is\n        return true;\n    }\n\n    function acquireViaTransferFrom(uint256 location, uint256 amount) public {\n        address sender = _msgSender();\n        _acquire(sender, amount, location, false);\n        _stakingToken.transferFrom(sender, address(this), amount);\n    }\n\n    function acquireViaFreeTokenTransferFrom(uint256 location, uint256 amount) public {\n        address sender = _msgSender();\n        _acquire(sender, amount, location, true);\n        _freeStakingToken.transferFrom(sender, address(this), amount);\n    }\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // EXIT / WITHDRAWALS\n    // ---------------------------------------------------------------------------------------------------------------\n\n    function exitFor(address owner, uint256 location) external {\n        _exitFor(owner, location);\n    }\n\n    function fetchAndWithdrawFor(address owner, uint256[] calldata locations) external {\n        _fetchAndWithdrawFor(owner, locations);\n    }\n\n    function balanceToWithdraw(address owner) external view returns (uint256) {\n        return _stakeReadyToBeWithdrawn[owner];\n    }\n\n    function withdrawFor(address owner) external {\n        uint256 amount = _stakeReadyToBeWithdrawn[owner];\n        _unsafe_withdrawAll(owner, amount);\n    }\n}\n"
    },
    "src/outerspace/facets/OuterSpacePlanetsFacet.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"./OuterSpaceFacetBase.sol\";\nimport \"../interfaces/IOuterSpacePlanets.sol\";\nimport \"../interfaces/IApprovalForAllReceiver.sol\";\n\ncontract OuterSpacePlanetsFacet is OuterSpaceFacetBase, IOuterSpacePlanets {\n    // solhint-disable-next-line no-empty-blocks\n    constructor(Config memory config) OuterSpaceFacetBase(config) {}\n\n    function setApprovalForAll(address operator, bool approved) external {\n        address sender = _msgSender();\n        _operators[sender][operator] = approved;\n        emit ApprovalForAll(sender, operator, approved);\n    }\n\n    function setApprovalForAllIfNeededAndCall(IApprovalForAllReceiver operator, bytes calldata data) external {\n        address sender = _msgSender();\n        if (!_operators[sender][address(operator)]) {\n            _operators[sender][address(operator)] = true;\n            emit ApprovalForAll(sender, address(operator), true);\n        }\n        operator.onApprovalForAllBy(sender, data);\n    }\n\n    function ownerOf(uint256 location) external view returns (address currentOwner) {\n        Planet storage planet = _getPlanet(location);\n        currentOwner = planet.owner;\n        // TODO should we ?\n        // if (_hasJustExited(_planets[location].exitStartTime)) {\n        //     currentOwner = address(0);\n        // } else {\n        //     PlanetUpdateState memory planetUpdate = _createPlanetUpdateState(planet, location);\n        //     _computePlanetUpdateForTimeElapsed(planetUpdate);\n        //     if (!planetUpdate.active && planetUpdate.numSpaceships == 0) {\n        //         currentOwner = address(0);\n        //     }\n        // }\n    }\n\n    function isApprovedForAll(address owner, address operator) external view returns (bool) {\n        return _operators[owner][operator];\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 location\n    ) external {\n        // TODO safe callback\n        _transfer(from, to, location);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 location,\n        bytes calldata data\n    ) external {\n        // TODO safe callback + data\n        _transfer(from, to, location);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 location\n    ) external {\n        _transfer(from, to, location);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 location\n    ) internal {\n        require(from != address(0), \"NOT_ZERO_ADDRESS\");\n        require(to != address(0), \"NOT_ZERO_ADDRESS\");\n\n        // -----------------------------------------------------------------------------------------------------------\n        // Initialise State Update\n        // -----------------------------------------------------------------------------------------------------------\n        Planet storage planet = _getPlanet(location);\n        PlanetUpdateState memory planetUpdate = _createPlanetUpdateState(planet, location);\n\n        // -----------------------------------------------------------------------------------------------------------\n        // Compute Basic Planet Updates\n        // -----------------------------------------------------------------------------------------------------------\n        _computePlanetUpdateForTimeElapsed(planetUpdate);\n\n        // -----------------------------------------------------------------------------------------------------------\n        // check requirements\n        // -----------------------------------------------------------------------------------------------------------\n\n        require(planetUpdate.newOwner == from, \"FROM_NOT_OWNER\");\n        if (msg.sender != planetUpdate.newOwner) {\n            require(_operators[planetUpdate.newOwner][msg.sender], \"NOT_OPERATOR\");\n        }\n\n        // -----------------------------------------------------------------------------------------------------------\n        // Perform Transfer\n        // -----------------------------------------------------------------------------------------------------------\n        planetUpdate.newOwner = to;\n        // NOTE transfer incurs a tax if the new owner and previous owner are not in an alliance since at least 3 days.\n        if (planetUpdate.numSpaceships > 0 && !_isFleetOwnerTaxed(from, to, uint40(block.timestamp - 3 days))) {\n            planetUpdate.numSpaceships = uint32(\n                uint256(planetUpdate.numSpaceships) - (uint256(planetUpdate.numSpaceships) * _giftTaxPer10000) / 10000\n            );\n        }\n\n        // -----------------------------------------------------------------------------------------------------------\n        // Write New State\n        // -----------------------------------------------------------------------------------------------------------\n        _setPlanet(planet, planetUpdate, false);\n\n        // -----------------------------------------------------------------------------------------------------------\n        // Emit Event\n        // -----------------------------------------------------------------------------------------------------------\n        emit PlanetTransfer(\n            from,\n            to,\n            location,\n            planetUpdate.numSpaceships,\n            planetUpdate.travelingUpkeep,\n            planetUpdate.overflow\n        );\n    }\n\n    function ownerAndOwnershipStartTimeOf(uint256 location)\n        external\n        view\n        returns (address owner, uint40 ownershipStartTime)\n    {\n        owner = _planets[location].owner;\n        ownershipStartTime = _planets[location].ownershipStartTime;\n    }\n\n    function getPlanetState(uint256 location) external view returns (Planet memory state) {\n        return _planets[location];\n    }\n\n    function getPlanet(uint256 location) external view returns (ExternalPlanet memory state, PlanetStats memory stats) {\n        Planet storage planet = _getPlanet(location);\n        (bool active, uint32 numSpaceships) = _activeNumSpaceships(planet.numSpaceships);\n        state = ExternalPlanet({\n            owner: planet.owner,\n            ownershipStartTime: planet.ownershipStartTime,\n            exitStartTime: planet.exitStartTime,\n            numSpaceships: numSpaceships,\n            overflow: planet.overflow,\n            lastUpdated: planet.lastUpdated,\n            active: active,\n            reward: _rewards[location]\n        });\n        stats = _getPlanetStats(location);\n    }\n}\n"
    },
    "src/outerspace/interfaces/IOuterSpacePlanets.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"../types/ImportingOuterSpaceTypes.sol\";\nimport \"../events/ImportingOuterSpaceEvents.sol\";\n\ninterface IOuterSpacePlanets is ImportingOuterSpaceTypes, ImportingOuterSpaceEvents {\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n    function ownerOf(uint256 location) external view returns (address);\n\n    function safeTransferFrom(address from, address to, uint256 location) external;\n    function safeTransferFrom(address from, address to, uint256 location, bytes calldata data) external;\n    function transferFrom(address from, address to, uint256 location) external;\n\n    function ownerAndOwnershipStartTimeOf(uint256 location) external view returns (address owner, uint40 ownershipStartTime);\n\n    function getPlanet(uint256 location) external view returns (ExternalPlanet memory state, PlanetStats memory stats);\n\n    function getPlanetState(uint256 location) external view returns (Planet memory state);\n}\n"
    },
    "src/outerspace/interfaces/IApprovalForAllReceiver.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\ninterface IApprovalForAllReceiver {\n    function onApprovalForAllBy(address owner, bytes calldata data) external;\n}\n"
    },
    "src/outerspace/interfaces/IOuterSpace.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"./IOuterSpaceFleets.sol\";\nimport \"./IOuterSpacePlanets.sol\";\n\n// solhint-disable-next-line no-empty-blocks\ninterface IOuterSpace is IOuterSpaceFleets, IOuterSpacePlanets {}\n"
    },
    "src/outerspace/interfaces/IOuterSpaceFleets.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"../types/ImportingOuterSpaceTypes.sol\";\nimport \"../events/ImportingOuterSpaceEvents.sol\";\n\ninterface IOuterSpaceFleets is ImportingOuterSpaceTypes, ImportingOuterSpaceEvents {\n\n    function resolveFleet(uint256 fleetId, FleetResolution calldata resolution) external;\n\n    function send(\n        uint256 from,\n        uint32 quantity,\n        bytes32 toHash\n    ) external;\n\n    function sendFor(FleetLaunch calldata launch) external;\n\n    function getFleet(uint256 fleetId, uint256 from)\n        external\n        view\n        returns (\n            address owner,\n            uint40 launchTime,\n            uint32 quantity,\n            uint64 flyingAtLaunch, // can be more than quantity if multiple fleet were launched around the same time from the same planet\n            uint64 destroyedAtLaunch\n        );\n}\n"
    },
    "src/outerspace/facets/OuterSpaceInitializationFacet.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"../base/ImportingOuterSpaceConstants.sol\";\nimport \"../events/ImportingOuterSpaceEvents.sol\";\nimport \"../base/UsingOuterSpaceDataLayout.sol\";\n\ncontract OuterSpaceInitializationFacet is\n    ImportingOuterSpaceConstants,\n    ImportingOuterSpaceEvents,\n    UsingOuterSpaceDataLayout\n{\n    bytes32 internal immutable _genesis;\n    uint256 internal immutable _resolveWindow;\n    uint256 internal immutable _timePerDistance;\n    uint256 internal immutable _exitDuration;\n    uint32 internal immutable _acquireNumSpaceships;\n    uint32 internal immutable _productionSpeedUp;\n    uint256 internal immutable _frontrunningDelay;\n    uint256 internal immutable _productionCapAsDuration;\n    uint256 internal immutable _upkeepProductionDecreaseRatePer10000th;\n    uint256 internal immutable _fleetSizeFactor6;\n    uint32 internal immutable _expansionDelta; // = 8;\n    uint32 internal immutable _initialSpaceExpansion; // = 16;\n    uint256 internal immutable _giftTaxPer10000; // = 2500;\n\n    struct Config {\n        bytes32 genesis;\n        uint256 resolveWindow;\n        uint256 timePerDistance;\n        uint256 exitDuration;\n        uint32 acquireNumSpaceships;\n        uint32 productionSpeedUp;\n        uint256 frontrunningDelay;\n        uint256 productionCapAsDuration;\n        uint256 upkeepProductionDecreaseRatePer10000th;\n        uint256 fleetSizeFactor6;\n        uint32 initialSpaceExpansion;\n        uint32 expansionDelta;\n        uint256 giftTaxPer10000;\n    }\n\n    constructor(Config memory config) {\n        uint32 t = uint32(config.timePerDistance) / 4; // the coordinates space is 4 times bigger\n        require(t * 4 == config.timePerDistance, \"TIME_PER_DIST_NOT_DIVISIBLE_4\");\n\n        _genesis = config.genesis;\n        _resolveWindow = config.resolveWindow;\n        _timePerDistance = t;\n        _exitDuration = config.exitDuration;\n        _acquireNumSpaceships = config.acquireNumSpaceships;\n        _productionSpeedUp = config.productionSpeedUp;\n        _frontrunningDelay = config.frontrunningDelay;\n        _productionCapAsDuration = config.productionCapAsDuration;\n        _upkeepProductionDecreaseRatePer10000th = config.upkeepProductionDecreaseRatePer10000th;\n        _fleetSizeFactor6 = config.fleetSizeFactor6;\n        _initialSpaceExpansion = config.initialSpaceExpansion;\n        _expansionDelta = config.expansionDelta;\n        _giftTaxPer10000 = config.giftTaxPer10000;\n    }\n\n    // TODO make this facet an initialization contract\n    function init() external {\n        if (_discovered.minX == 0) {\n            _discovered = Discovered({\n                minX: _initialSpaceExpansion,\n                maxX: _initialSpaceExpansion,\n                minY: _initialSpaceExpansion,\n                maxY: _initialSpaceExpansion\n            });\n            emit Initialized(\n                _genesis,\n                _resolveWindow,\n                _timePerDistance,\n                _exitDuration,\n                _acquireNumSpaceships,\n                _productionSpeedUp,\n                _frontrunningDelay,\n                _productionCapAsDuration,\n                _upkeepProductionDecreaseRatePer10000th,\n                _fleetSizeFactor6,\n                _initialSpaceExpansion,\n                _expansionDelta,\n                _giftTaxPer10000\n            );\n        }\n    }\n}\n"
    },
    "src/outerspace/facets/OuterSpaceFleetsFacet.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"./OuterSpaceFacetBase.sol\";\nimport \"../interfaces/IOuterSpaceFleets.sol\";\n\ncontract OuterSpaceFleetsFacet is OuterSpaceFacetBase, IOuterSpaceFleets {\n    // solhint-disable-next-line no-empty-blocks\n    constructor(Config memory config) OuterSpaceFacetBase(config) {}\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // FLEET RESOLUTION, ATTACK / REINFORCEMENT\n    // ---------------------------------------------------------------------------------------------------------------\n\n    function resolveFleet(uint256 fleetId, FleetResolution calldata resolution) external {\n        require(\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        keccak256(\n                            abi.encodePacked(\n                                resolution.secret,\n                                resolution.to,\n                                resolution.gift,\n                                resolution.specific,\n                                resolution.arrivalTimeWanted\n                            )\n                        ),\n                        resolution.from,\n                        resolution.fleetSender,\n                        resolution.operator\n                    )\n                )\n            ) == fleetId,\n            \"INVALID_FLEET_DATA_OR_SECRET\"\n        );\n        _resolveFleet(fleetId, resolution);\n    }\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // FLEET SENDING\n    // ---------------------------------------------------------------------------------------------------------------\n\n    function send(\n        uint256 from,\n        uint32 quantity,\n        bytes32 toHash\n    ) external {\n        address sender = _msgSender();\n        uint256 fleetId = uint256(keccak256(abi.encodePacked(toHash, from, sender, sender)));\n        _unsafe_sendFor(\n            fleetId,\n            sender,\n            FleetLaunch({fleetSender: sender, fleetOwner: sender, from: from, quantity: quantity, toHash: toHash})\n        );\n    }\n\n    function sendFor(FleetLaunch calldata launch) external {\n        //  bytes calldata fleetSignature // TODO for fleetOwner's signature ?\n\n        address operator = _msgSender();\n        if (operator != launch.fleetSender) {\n            require(_operators[launch.fleetSender][operator], \"NOT_AUTHORIZED_TO_SEND\");\n        }\n        uint256 fleetId = uint256(\n            keccak256(abi.encodePacked(launch.toHash, launch.from, launch.fleetSender, operator))\n        );\n\n        // fleetOwner is basically the one receiving the planet if the attack succeed\n        // fleetSender is the one to be used for alliance resolution\n        // operator is just so alliance can consider fleetSender based on the rule of that operator\n        // if (launch.fleetOwner != launch.fleetSender && launch.fleetOwner != operator) {\n        //     // TODO use signature from fleetOwner instead?\n        //     require(_operators[launch.fleetOwner][operator], \"NOT_AUTHORIZED_TO_FLEET\");\n        // }\n\n        _unsafe_sendFor(fleetId, operator, launch);\n    }\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // GETTERS\n    // ---------------------------------------------------------------------------------------------------------------\n\n    function getFleet(uint256 fleetId, uint256 from)\n        external\n        view\n        returns (\n            address owner,\n            uint40 launchTime,\n            uint32 quantity,\n            uint64 flyingAtLaunch, // can be more than quantity if multiple fleet were launched around the same time from the same planet\n            uint64 destroyedAtLaunch\n        )\n    {\n        launchTime = _fleets[fleetId].launchTime;\n        quantity = _fleets[fleetId].quantity;\n        owner = _fleets[fleetId].owner;\n\n        uint256 timeSlot = launchTime / (_frontrunningDelay / 2);\n        destroyedAtLaunch = _inFlight[from][timeSlot].destroyed;\n        flyingAtLaunch = _inFlight[from][timeSlot].flying;\n    }\n}\n"
    },
    "src/outerspace/facets/OuterSpaceInformationFacet.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"./OuterSpaceFacetBase.sol\";\n\ncontract OuterSpaceInformationFacet is OuterSpaceFacetBase {\n    // solhint-disable-next-line no-empty-blocks\n    constructor(Config memory config) OuterSpaceFacetBase(config) {}\n\n    function getGeneisHash() external view returns (bytes32) {\n        return _genesis;\n    }\n\n    function getAllianceRegistry() external view returns (AllianceRegistry) {\n        return _allianceRegistry;\n    }\n\n    function getDiscovered() external view returns (Discovered memory) {\n        return _discovered;\n    }\n\n    function getPlanetStates(uint256[] calldata locations)\n        external\n        view\n        returns (ExternalPlanet[] memory planetStates, Discovered memory discovered)\n    {\n        planetStates = new ExternalPlanet[](locations.length);\n        for (uint256 i = 0; i < locations.length; i++) {\n            Planet storage planet = _getPlanet(locations[i]);\n            (bool active, uint32 numSpaceships) = _activeNumSpaceships(planet.numSpaceships);\n            planetStates[i] = ExternalPlanet({\n                owner: planet.owner,\n                ownershipStartTime: planet.ownershipStartTime,\n                exitStartTime: planet.exitStartTime,\n                numSpaceships: numSpaceships,\n                overflow: planet.overflow,\n                lastUpdated: planet.lastUpdated,\n                active: active,\n                reward: _rewards[locations[i]]\n            });\n        }\n        discovered = _discovered;\n    }\n}\n"
    },
    "src/alliances/BasicAlliance.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"./AllianceRegistry.sol\";\n// import \"../interfaces/IAlliance.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\ncontract BasicAlliance {\n    using ECDSA for bytes32;\n\n    bool internal _original;\n    AllianceRegistry internal immutable _allianceRegistry;\n    address public admin;\n\n    string internal _baseURI;\n\n    mapping(address => uint32) public memberNonces;\n\n    // constructor(AllianceRegistry allianceRegistry, AllianceRegistry.PlayerSubmission[] memory playerSubmissions) {\n    //     _allianceRegistry = allianceRegistry;\n    //     _allianceRegistry.addMultiplePlayersToAlliance(playerSubmissions);\n    // }\n\n    constructor(AllianceRegistry allianceRegistry, string memory baseURI) {\n        _allianceRegistry = allianceRegistry;\n        _original = true;\n        admin = address(1); // lock it\n        init(baseURI);\n    }\n\n    function init(string memory baseURI) public {\n        require(bytes(_baseURI).length == 0, \"ALREADY_INITIALISED\");\n        _baseURI = baseURI;\n    }\n\n    function frontendURI() external view returns (string memory) {\n        return string(bytes.concat(bytes(_baseURI), bytes(Strings.toHexString(uint256(uint160(address(this))), 20))));\n    }\n\n    function setAdminAndAddMembers(address newAdmin, AllianceRegistry.PlayerSubmission[] calldata playerSubmissions)\n        public\n    {\n        address currentAdmin = admin;\n        require(currentAdmin == address(0) || msg.sender == currentAdmin, \"NOT_ALLOWED\");\n        admin = newAdmin;\n        if (playerSubmissions.length > 0) {\n            _allianceRegistry.addMultiplePlayersToAlliance(playerSubmissions);\n        }\n    }\n\n    function addMembers(AllianceRegistry.PlayerSubmission[] calldata playerSubmissions) external {\n        require(msg.sender == admin, \"NOT_ALLOWED\");\n        _allianceRegistry.addMultiplePlayersToAlliance(playerSubmissions);\n    }\n\n    function removeMember(address player) external {\n        require(msg.sender == admin, \"NOT_ALLOWED\");\n        _allianceRegistry.ejectPlayerFromAlliance(player);\n    }\n\n    function claimInvite(\n        address player,\n        uint32 nonce,\n        bytes calldata signature,\n        uint32 inviteNonce,\n        bytes calldata inviteSignature\n    ) external {\n        uint256 currentNonce = memberNonces[player];\n        require(currentNonce == inviteNonce, \"INVALID_NONCE\");\n        memberNonces[player] = inviteNonce + 1;\n\n        bytes memory message;\n        if (inviteNonce == 0) {\n            message = abi.encodePacked(\n                \"\\x19Ethereum Signed Message:\\n111\",\n                \"Invite Player 0x0000000000000000000000000000000000000000 To Alliance 0x0000000000000000000000000000000000000000\"\n            );\n            _writeUintAsHex(message, 29 + 55, uint160(player));\n            _writeUintAsHex(message, 29 + 110, uint160(address(this)));\n        } else {\n            message = abi.encodePacked(\n                \"\\x19Ethereum Signed Message:\\n131\",\n                \"Invite Player 0x0000000000000000000000000000000000000000 To Alliance 0x0000000000000000000000000000000000000000 (nonce:          0)\"\n            );\n            _writeUintAsHex(message, 29 + 55, uint160(player));\n            _writeUintAsHex(message, 29 + 110, uint160(address(this)));\n            _writeUintAsDecimal(message, 29 + 129, inviteNonce);\n        }\n        bytes32 digest = keccak256(message);\n\n        address signer = digest.recover(inviteSignature);\n        require(admin == signer, \"INVALID_INVITE_SIGNATURE\");\n\n        _allianceRegistry.addPlayerToAlliance(player, nonce, signature);\n    }\n\n    function instantiate(\n        address initialAdmin,\n        AllianceRegistry.PlayerSubmission[] calldata playerSubmissions,\n        bytes32 salt\n    ) external {\n        require(_original, \"CANNOT_INSTANTIATE_FROM_CLONES\");\n        address newAlliance = Clones.cloneDeterministic(address(this), keccak256(abi.encodePacked(salt, msg.sender)));\n        BasicAlliance(newAlliance).init(_baseURI);\n        BasicAlliance(newAlliance).setAdminAndAddMembers(initialAdmin, playerSubmissions);\n    }\n\n    function getAddress(bytes32 salt) external view returns (address) {\n        require(_original, \"CANNOT_INSTANTIATE_FROM_CLONES\");\n        return\n            Clones.predictDeterministicAddress(\n                address(this),\n                keccak256(abi.encodePacked(salt, msg.sender)),\n                address(this)\n            );\n    }\n\n    // function requestToJoin(address player, bytes calldata data) external view returns (bool) {\n    //     if (player == _initialMember) {\n    //         return true;\n    //     } else {\n    //         bytes32 digest = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", \"Add \", ));\n    //         address signer = digest.recover(signature);\n    //         require(_outerspace.allianceJoinTime(signer, this), \"ONLY_ALLIANCE_MEMBER_CAN_INVITE\");\n    //     }\n    // }\n\n    // function playerHasLeft(address player) external {\n\n    // }\n\n    // TODO library\n    bytes internal constant hexAlphabet = \"0123456789abcdef\";\n    bytes internal constant decimalAlphabet = \"0123456789\";\n\n    function _writeUintAsHex(\n        bytes memory data,\n        uint256 endPos,\n        uint256 num\n    ) internal pure {\n        while (num != 0) {\n            data[endPos--] = bytes1(hexAlphabet[num % 16]);\n            num /= 16;\n        }\n    }\n\n    function _writeUintAsDecimal(\n        bytes memory data,\n        uint256 endPos,\n        uint256 num\n    ) internal pure {\n        while (num != 0) {\n            data[endPos--] = bytes1(decimalAlphabet[num % 10]);\n            num /= 10;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "src/libraries/Random.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity 0.8.9;\n\nimport \"./Math.sol\";\n\nlibrary Random {\n    using Math for uint256;\n\n    function r_u8(\n        bytes32 seed,\n        uint256 r,\n        uint8 i,\n        uint256 mod\n    ) internal pure returns (uint8) {\n        return uint8(uint256(keccak256(abi.encodePacked(r, seed, i))) % mod);\n    }\n\n    function r_u256(\n        bytes32 seed,\n        uint256 r,\n        uint8 i,\n        uint256 mod\n    ) internal pure returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(r, seed, i))) % mod;\n    }\n\n    function r_u256_minMax(\n        bytes32 seed,\n        uint256 r,\n        uint8 i,\n        uint256 min,\n        uint256 max\n    ) internal pure returns (uint256) {\n        uint256 range = max.sub(min, \"MAX_LT_MIN\");\n        return min.add(r_u256(seed, r, i, range), \"MAX_OVERFLOW\");\n    }\n\n    // 1+1+2+3+4+6+7+8+8+7+6+4+3+2+1+1 // aproximation of normal distribution with mean=7.5 and standard deviation=3 for 16 values\n    bytes32 constant n_m7_5_sd3 = 0x01223334444555555666666677777777888888889999999AAAAAABBBBCCCDDEF;\n\n    function r_normal(\n        bytes32 seed,\n        uint256 r,\n        uint8 i\n    ) internal pure returns (uint8) {\n        uint8 index = r_u8(seed, r, i, 64);\n        uint8 first = index / 2;\n        uint8 second = index % 2;\n        uint8 slot = uint8(n_m7_5_sd3[first]);\n        uint8 value;\n        if (second == 0) {\n            value = slot >> 4;\n        } else {\n            value = slot % 16;\n        }\n        return value;\n    }\n\n    function r_normalFrom(\n        bytes32 seed,\n        uint256 r,\n        uint8 i,\n        bytes32 selection\n    ) internal pure returns (uint16) {\n        uint8 index = r_normal(seed, r, i);\n        return uint16(uint8(selection[index * 2])) * 2**8 + uint16(uint8(selection[index * 2 + 1]));\n    }\n}\n"
    },
    "src/mock/Conversion.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"hardhat/console.sol\";\n\ncontract TestConversion {\n    function _convertLoc2XY(uint256 location) internal pure returns (int128 x, int128 y) {\n        x = int128(int256(location & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF));\n        y = int128(int256(location >> 128));\n    }\n\n    function _convertXY2Loc(int128 x, int128 y) internal pure returns (uint256 location) {\n        // unchecked {location = uint256(int256(x)) + uint256(int256(y) << 128);}\n        unchecked {\n            location = uint256(uint128(x)) + (uint256(uint128(y)) << 128);\n        }\n    }\n\n    function _convertLocationToLocation(uint256 location) internal pure returns (uint256 newLocation) {\n        (int128 ix, int128 iy) = _convertLoc2XY(location);\n        return _convertXY2Loc(ix, iy);\n    }\n\n    function testConversion(uint256 location) external view {\n        console.logUint(location);\n        (int128 x, int128 y) = _convertLoc2XY(location);\n\n        console.logInt(x);\n        console.logInt(y);\n\n        int256 x256 = int256(location & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n        int256 y256 = int256(location >> 128);\n        // console.log(\"x256 %i y256 %i\", x256, y256);\n        console.logInt(x256);\n        console.logInt(y256);\n\n        uint256 newLocation = _convertXY2Loc(x, y);\n        console.logUint(newLocation);\n        console.logBytes32(bytes32(newLocation));\n\n        if (location != newLocation) {\n            console.log(\"error\");\n        }\n    }\n}\n"
    },
    "src/outerspace/facets/OuterSpaceAdminFacet.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"./OuterSpaceFacetBase.sol\";\nimport \"hardhat-deploy/solc_0.8/diamond/UsingDiamondOwner.sol\";\n\ncontract OuterSpaceAdminFacet is UsingDiamondOwner, OuterSpaceFacetBase {\n    // solhint-disable-next-line no-empty-blocks\n    constructor(Config memory config) OuterSpaceFacetBase(config) {}\n\n    // TODO : ERC20, ERC721, ERC1155\n    // remove sponsor, use msg.sender and this could be special contracts\n    // TODO : reenable, removed because of code size issue\n    function addReward(uint256 location, address sponsor) external onlyOwner {\n        _addReward(location, sponsor);\n    }\n\n    function resetPlanet(uint256 location) external onlyOwner {\n        // TODO\n        // if (_planets[location].owner == address(0) && active) {\n        //     //update totalProduction\n        // }\n\n        _planets[location].owner = address(0);\n        _planets[location].ownershipStartTime = 0;\n        _planets[location].exitStartTime = 0;\n\n        _planets[location].numSpaceships = 0;\n        _planets[location].lastUpdated = 0;\n        _planets[location].overflow = 0;\n\n        emit PlanetReset(location);\n    }\n\n    function debug_reset_exitStartTime(uint256 location) external onlyOwner {\n        _planets[location].exitStartTime = 0;\n    }\n}\n"
    },
    "hardhat-deploy/solc_0.8/diamond/UsingDiamondOwner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./libraries/LibDiamond.sol\";\n\ncontract UsingDiamondOwner {\n    modifier onlyOwner() {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        require(msg.sender == ds.contractOwner, \"Only owner is allowed to perform this action\");\n        _;\n    }\n}\n"
    },
    "hardhat-deploy/solc_0.8/diamond/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\n\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n    }\n\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\n    }\n\n    struct DiamondStorage {\n        // maps function selector to the facet address and\n        // the position of the selector in the facetFunctionSelectors.selectors array\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n        // maps facet addresses to function selectors\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n        // facet addresses\n        address[] facetAddresses;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n    }\n\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    // Internal function version of diamondCut\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else {\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();        \n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);            \n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress != _facetAddress, \"LibDiamondCut: Can't replace function with same function\");\n            removeFunction(ds, oldFacetAddress, selector);\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        // if function does not exist then do nothing and return\n        require(_facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            removeFunction(ds, oldFacetAddress, selector);\n        }\n    }\n\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\n        enforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\n        ds.facetAddresses.push(_facetAddress);\n    }    \n\n\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {        \n        require(_facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n        // an immutable function is a function defined directly in a diamond\n        require(_facetAddress != address(this), \"LibDiamondCut: Can't remove immutable function\");\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete ds.selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n            }\n            ds.facetAddresses.pop();\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n        }\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            require(_calldata.length == 0, \"LibDiamondCut: _init is address(0) but_calldata is not empty\");\n        } else {\n            require(_calldata.length > 0, \"LibDiamondCut: _calldata is empty but _init is not address(0)\");\n            if (_init != address(this)) {\n                enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\n            }\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\n            if (!success) {\n                if (error.length > 0) {\n                    // bubble up the error\n                    revert(string(error));\n                } else {\n                    revert(\"LibDiamondCut: _init function reverted\");\n                }\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    },
    "hardhat-deploy/solc_0.8/diamond/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondCut {\n    enum FacetCutAction {Add, Replace, Remove}\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "src/conquest_token/ConquestToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../base/erc20/UsingERC20Base.sol\";\nimport \"../base/erc20/WithPermitAndFixedDomain.sol\";\nimport \"hardhat-deploy/solc_0.8/proxy/Proxied.sol\";\n\ncontract ConquestToken is UsingERC20Base, WithPermitAndFixedDomain, Proxied {\n    using Address for address;\n\n    address internal _minter;\n\n    constructor(address minter) WithPermitAndFixedDomain(\"1\") {\n        postUpgrade(minter);\n    }\n\n    function postUpgrade(address minter) public proxied {\n        _minter = minter;\n    }\n\n    string public constant symbol = \"CQT\";\n\n    function name() public pure override returns (string memory) {\n        return \"Conquest's Token\";\n    }\n\n    function inflate(address to, uint256 amount) external {\n        require(msg.sender == _minter);\n        _mint(to, amount);\n    }\n\n    // ----------------------------------------------------------------------\n    // TODO remove\n    // ----------------------------------------------------------------------\n    mapping(address => bool) public authorized;\n    bool public requireAuthorization;\n    mapping(address => bool) public touched;\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override {\n        require(!requireAuthorization || authorized[from] || authorized[to] || !touched[to], \"NOT_AUTHORIZED_TRANSFER\");\n        super._transfer(from, to, amount);\n        touched[to] = true;\n    }\n\n    function anyNotAuthorized(address[] memory accounts) external view returns (bool) {\n        for (uint256 i = 0; i < accounts.length; i++) {\n            if (!authorized[accounts[i]]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function authorize(address[] memory accounts, bool auth) public {\n        require(msg.sender == _admin(), \"NOT_ADMIN\");\n        for (uint256 i = 0; i < accounts.length; i++) {\n            authorized[accounts[i]] = auth;\n        }\n    }\n\n    function enableRequireAuthorization(address[] calldata accounts) external {\n        require(msg.sender == _admin(), \"NOT_ADMIN\");\n        setRequireAuthorization(true);\n        authorize(accounts, true);\n    }\n\n    function setRequireAuthorization(bool req) public {\n        require(msg.sender == _admin(), \"NOT_ADMIN\");\n        requireAuthorization = req;\n    }\n\n    function _admin() internal view returns (address adminAddress) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            adminAddress := sload(0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103)\n        }\n    }\n    // ----------------------------------------------------------------------\n}\n"
    },
    "src/conquest_token/ConquestStakingPool.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"./ConquestToken.sol\";\n\ncontract ConquestStakingPool {\n    struct Config {\n        uint64 maxInflation;\n        // 0 and the curve is linear, means inflation moves with the stake and staker win the same ratio at all time\n        // > 0 , means inflation start higher giving more to early stakers\n        uint64 startInflation;\n        uint64 liquidityRewardRatio;\n    }\n\n    uint256 internal constant PRECISION = 1e24;\n\n    event Staked(address indexed account, uint256 amount);\n    event Withdrawn(address indexed account, uint256 amount);\n    event RewardPaid(address indexed account, uint256 reward);\n    event StakeTransfered(address indexed from, address indexed to, uint256 amount);\n\n    uint256 internal _lastUpdateTime;\n    uint256 internal _totalRewardPerTokenAtLastUpdate;\n    uint256 internal _totalStaked;\n    uint256 internal _extraTokenGenerated;\n    uint256 internal _totalLiquidityRewardGenerated;\n\n    mapping(address => uint256) internal _amountStakedPerAccount;\n    mapping(address => uint256) internal _totalRewardPerTokenAccountedPerAccount;\n    mapping(address => uint256) internal _rewardsToWithdrawPerAccount;\n\n    mapping(address => uint256) internal _games;\n    address public owner;\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // CONFIG\n    // ---------------------------------------------------------------------------------------------------------------\n    Config public config;\n    // ---------------------------------------------------------------------------------------------------------------\n\n    ConquestToken internal immutable _conquestToken;\n    uint256 internal immutable _originalTotalSupply;\n\n    constructor(ConquestToken conquestToken, address initialOwner) {\n        _conquestToken = conquestToken;\n        _originalTotalSupply = _conquestToken.totalSupply();\n        owner = initialOwner;\n\n        // -----------------------------------------------------------------------------------------------------------\n        // CONFIG\n        // -----------------------------------------------------------------------------------------------------------\n        config.startInflation = 0; // TODO configure 10000th\n        config.maxInflation = 2000; // TODO configure 10000th\n        config.liquidityRewardRatio = 5000; // TODO configure 10000th\n        // -----------------------------------------------------------------------------------------------------------\n    }\n\n    // TODO implement game weight\n    function setGame(address game, uint256 weight) external {\n        require(msg.sender == owner, \"NOT_OWNER\");\n        _games[game] = weight;\n    }\n\n    // TODO Ownable with Event\n    function transferOwnership(address newOwner) external {\n        require(msg.sender == owner, \"NOT_OWNER\");\n        owner = newOwner;\n    }\n\n    function setConfig(Config calldata newConfig) external {\n        require(msg.sender == owner, \"NOT_OWNER\");\n        _updateGlobal();\n        config = newConfig;\n    }\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // For Authorized Games\n    // ---------------------------------------------------------------------------------------------------------------\n\n    /// @notice stake ${amount} tokens from account ${account}.\n    /// @param account The account whose token are staked. Will be given reward.\n    /// @param amount The amount of tokens to stake.\n    function stake(address account, uint256 amount) external onlyGames {\n        if (amount == 0) {\n            return;\n        }\n\n        (uint256 totalStakedSoFar, uint256 amountStakedSoFar) = _update(account);\n\n        // update staked amount, their reward will be counted on next interaction.\n        _totalStaked = totalStakedSoFar + amount; // WRITE + 1 // TODO remove that line because _conquestToken.balanceOf(address(this)) should be equivalent\n        _amountStakedPerAccount[account] = amountStakedSoFar + amount; // WRITE + 1\n\n        _conquestToken.transferFrom(account, address(this), amount); // WRITE + 2 + ?\n        emit Staked(account, amount);\n    }\n\n    // /// @notice Withdraws ${amount} staked tokens from account ${account}.\n    // /// @param account The account whose token are withdrawn.\n    // /// @param amount The amount of tokens to withdraw.\n    // function withdraw(address account, uint256 amount) external onlyGames {\n    //     if (amount == 0) {\n    //         return;\n    //     }\n\n    //     // update the amount generated, store it in\n    //     (uint256 totalStakedSoFar, uint256 amountStakedSoFar) = _update(account);\n\n    //     unchecked {\n    //         _amountStakedPerAccount[account] = amountStakedSoFar - amount;\n    //         _totalStaked = totalStakedSoFar - amount;\n    //     }\n\n    //     _conquestToken.transfer(account, amount);\n    //     emit Withdrawn(account, amount);\n    // }\n\n    /// @notice Withdraws ${amount} staked tokens from account ${account}.\n    /// @param account The account whose token are withdrawn.\n    /// @param amount The amount of tokens to withdraw.\n    function exit(address account, uint256 amount) external onlyGames {\n        if (amount == 0) {\n            return;\n        }\n\n        // update the amount generated, store it in\n        (uint256 totalStakedSoFar, uint256 amountStakedSoFar) = _update(account);\n\n        unchecked {\n            _amountStakedPerAccount[account] = amountStakedSoFar - amount;\n            _totalStaked = totalStakedSoFar - amount;\n        }\n\n        // TODO exit reserve (if someone capture)\n        // _conquestToken.transfer(account, amount);\n\n        // emit Withdrawn(account, amount);\n    }\n\n    /// @notice Withdraws ${amount} staked tokens from account ${account}.\n    /// @param account The account whose token are withdrawn.\n    /// @param amount The amount of tokens to withdraw.\n    function withdraw(address account, uint256 amount) external onlyGames {\n        // TODO  take from exit reserve\n        _conquestToken.transfer(account, amount);\n        emit Withdrawn(account, amount);\n    }\n\n    // TODO variant where you can withdraw an amount of token + an amount of reward at the same time (not full exit)\n\n    /// @notice Transfers ${amount} staked token to another account. Rewards acrrued are given to account ${from} first.\n    /// @param from account to transfer from\n    /// @param to account to transfer to\n    /// @param amount The amount of staked tokens to transfer\n    function transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) external onlyGames {\n        if (amount == 0) {\n            return;\n        }\n        if (from == to) {\n            return;\n        }\n\n        (uint256 totalStakedSoFar, uint256 totalRewardPerToken, ) = _updateGlobal();\n        uint256 amountStakedSoFar;\n        unchecked {\n            amountStakedSoFar = _updateAccount(from, totalRewardPerToken);\n            _amountStakedPerAccount[from] = amountStakedSoFar - amount;\n            amountStakedSoFar = _updateAccount(to, totalRewardPerToken);\n            _amountStakedPerAccount[to] = amountStakedSoFar + amount;\n        }\n\n        emit StakeTransfered(from, to, amount);\n    }\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // For Accounts\n    // ---------------------------------------------------------------------------------------------------------------\n\n    /// @notice Withdraws all earned rewards\n    function getReward() external {\n        uint256 amountStakedSoFar = _amountStakedPerAccount[msg.sender];\n\n        (uint256 totalStakedSoFar, uint256 totalRewardPerToken, ) = _updateGlobal();\n        uint256 reward = _computeTokenEarned(\n            _totalRewardPerTokenAccountedPerAccount[msg.sender],\n            amountStakedSoFar,\n            totalRewardPerToken,\n            _rewardsToWithdrawPerAccount[msg.sender]\n        );\n        _totalRewardPerTokenAccountedPerAccount[msg.sender] = totalRewardPerToken;\n\n        if (reward > 0) {\n            _rewardsToWithdrawPerAccount[msg.sender] = 0;\n            _conquestToken.transfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // Getters\n    // ---------------------------------------------------------------------------------------------------------------\n\n    // TODO balanceOf\n    // TODO totalSupply\n    // ... ?\n\n    /// @notice The amount of reward tokens each staked token has earned so far\n    function totalRewardPerToken() external view returns (uint256) {\n        uint256 totalStakedSoFar = _totalStaked;\n        uint256 extraTokenGenerated = _extraTokenGenerated;\n        uint256 totalSupplySoFar = _originalTotalSupply + extraTokenGenerated;\n        // TODO add in extraTokenGenerated based on previous rewardRate ?\n        uint256 rewardRate = _computeRewardRate(\n            totalStakedSoFar,\n            totalSupplySoFar,\n            config.startInflation,\n            config.maxInflation\n        );\n        return\n            _totalRewardPerTokenAtLastUpdate +\n            _computeExtraTotalRewardPerTokenSinceLastTime(totalStakedSoFar, rewardRate, _lastUpdateTime);\n    }\n\n    /// @notice The amount of reward tokens an account has accrued so far. Does not include already withdrawn rewards.\n    function earned(address account) external view returns (uint256) {\n        uint256 totalStakedSoFar = _totalStaked;\n        uint256 extraTokenGenerated = _extraTokenGenerated;\n        uint256 totalSupplySoFar = _originalTotalSupply + extraTokenGenerated;\n        // TODO add in extraTokenGenerated based on previous rewardRate ?\n        uint256 rewardRate = _computeRewardRate(\n            totalStakedSoFar,\n            totalSupplySoFar,\n            config.startInflation,\n            config.maxInflation\n        );\n        return\n            _computeTokenEarned(\n                _totalRewardPerTokenAccountedPerAccount[account],\n                _amountStakedPerAccount[account],\n                _totalRewardPerTokenAtLastUpdate +\n                    _computeExtraTotalRewardPerTokenSinceLastTime(totalStakedSoFar, rewardRate, _lastUpdateTime),\n                _rewardsToWithdrawPerAccount[account]\n            );\n    }\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // Internal\n    // ---------------------------------------------------------------------------------------------------------------\n\n    function _computeRewardRate(\n        uint256 totalStakedSoFar,\n        uint256 totalSupplySoFar,\n        uint256 startInflation,\n        uint256 maxInflation\n    ) internal pure returns (uint256 rewardRate) {\n        // assume this is the only generator of token\n        // TODO separate role and have a central place to reserve tokens in ConquestToken\n        // claiming reward fro reserve will reduce the reserve while increasing the token minted, keeping total supply adjusted\n        uint256 targetRate = (maxInflation - startInflation) * (totalStakedSoFar / totalSupplySoFar) + startInflation;\n        rewardRate = (targetRate * totalSupplySoFar) / 315360000000; // number of seconds in a year multiple by 10,000\n    }\n\n    function _computeTokenEarned(\n        uint256 totalRewardPerTokenAccountedSoFar,\n        uint256 accountStakedAmount,\n        uint256 currentTotalRewardPerToken,\n        uint256 accountRewardsSoFar\n    ) internal pure returns (uint256) {\n        return\n            accountRewardsSoFar +\n            ((accountStakedAmount * (currentTotalRewardPerToken - totalRewardPerTokenAccountedSoFar)) / PRECISION);\n    }\n\n    // TODO make it pure and totalStaked == 0 check outside ?\n    function _computeExtraTotalRewardPerTokenSinceLastTime(\n        uint256 totalStaked,\n        uint256 rewardRate,\n        uint256 lastUpdateTime\n    ) internal view returns (uint256) {\n        if (totalStaked == 0) {\n            return 0;\n        }\n        return ((block.timestamp - lastUpdateTime) * rewardRate * PRECISION) / totalStaked;\n    }\n\n    function _updateGlobal()\n        internal\n        returns (\n            uint256 totalStakedSoFar,\n            uint256 totalRewardPerTokenAllocatedSoFar,\n            uint256 rewardRate\n        )\n    {\n        totalStakedSoFar = _totalStaked; // READ + 1\n        uint256 extraTokenGenerated = _extraTokenGenerated; // READ + 1\n        uint256 totalSupplySoFar = _originalTotalSupply + extraTokenGenerated; // READ + 1\n\n        // reward rate for players based on past data, do not consider the compounding effect that should reduce its rate\n        // TODO apply it twice? see below\n        rewardRate = _computeRewardRate(totalStakedSoFar, totalSupplySoFar, config.startInflation, config.maxInflation); // READ config\n\n        // recompute rewardRate based on aproximate computation of extraTotalRewardPerToken\n        // uint256 extraTotalRewardPerToken = _computeExtraTotalRewardPerTokenSinceLastTime(totalStakedSoFar, rewardRate, _lastUpdateTime);\n        // rewardRate = _computeRewardRate(totalStakedSoFar + extraTotalRewardPerToken * totalStakedSoFar, totalSupplySoFar);\n\n        uint256 extraTotalRewardPerToken = _computeExtraTotalRewardPerTokenSinceLastTime(\n            totalStakedSoFar,\n            rewardRate,\n            _lastUpdateTime\n        ); // READ + 1\n\n        // liquidity reward\n        uint256 liquidityRewardPerToken = _computeExtraTotalRewardPerTokenSinceLastTime(\n            totalStakedSoFar,\n            (rewardRate * config.liquidityRewardRatio) / 10000,\n            _lastUpdateTime\n        ); // READ + 1 // READ config?\n        uint256 liquidityRewardGenerated = liquidityRewardPerToken * totalStakedSoFar;\n        _totalLiquidityRewardGenerated = _totalLiquidityRewardGenerated + liquidityRewardGenerated; // WRITE + 1\n\n        totalRewardPerTokenAllocatedSoFar = _totalRewardPerTokenAtLastUpdate + extraTotalRewardPerToken; // READ + 1 // need for returns params\n\n        _extraTokenGenerated =\n            extraTokenGenerated +\n            (extraTotalRewardPerToken * totalStakedSoFar) +\n            liquidityRewardGenerated; // WRITE + 1 // TODO use mint ? => _conquestToken.totalSupply\n\n        // TODO group these 2 in a struct\n        _totalRewardPerTokenAtLastUpdate = totalRewardPerTokenAllocatedSoFar; // WRITE + 1\n        _lastUpdateTime = block.timestamp; // WRITE + 1\n    }\n\n    function _updateAccount(address account, uint256 totalRewardPerTokenAllocatedSoFar)\n        internal\n        returns (uint256 amountStakedSoFar)\n    {\n        amountStakedSoFar = _amountStakedPerAccount[account]; // READ: +1 (the amount staked so far)\n\n        _rewardsToWithdrawPerAccount[account] = _computeTokenEarned( // WRITE: +1 (update the reward that can be withdrawn, catching up account state to global)\n            _totalRewardPerTokenAccountedPerAccount[account], // READ: +1 (last checkpoint : when was the account last updated)\n            amountStakedSoFar,\n            totalRewardPerTokenAllocatedSoFar,\n            _rewardsToWithdrawPerAccount[account] // READ: +1 (rewards already registered)\n        );\n        _totalRewardPerTokenAccountedPerAccount[account] = totalRewardPerTokenAllocatedSoFar; // WRITE: +1\n    }\n\n    function _update(address account) internal returns (uint256, uint256) {\n        (uint256 totalStakedSoFar, uint256 totalRewardPerTokenAllocatedSoFar, ) = _updateGlobal();\n        uint256 accountAmountStakedSoFar = _updateAccount(account, totalRewardPerTokenAllocatedSoFar);\n        return (totalStakedSoFar, accountAmountStakedSoFar);\n    }\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // Modifiers\n    // ---------------------------------------------------------------------------------------------------------------\n\n    modifier onlyGames() {\n        require(_games[msg.sender] > 0, \"NOT_AUTHORIZED_GAME\");\n        _;\n    }\n}\n"
    },
    "src/base/erc20/WithPermit.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"./ERC20BaseInternal.sol\";\nimport \"../../interfaces/IERC2612Standalone.sol\";\n\nabstract contract WithPermit is ERC20BaseInternal, IERC2612Standalone {\n    bytes32 internal constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    mapping(address => uint256) internal _nonces;\n\n    function DOMAIN_SEPARATOR() public view virtual override returns (bytes32);\n\n    function nonces(address owner) external view override returns (uint256) {\n        return _nonces[owner];\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(owner != address(0), \"INVALID_ZERO_ADDRESS\");\n\n        uint256 currentNonce = _nonces[owner];\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR(),\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, currentNonce, deadline))\n            )\n        );\n        require(owner == ecrecover(digest, v, r, s), \"INVALID_SIGNATURE\");\n        require(deadline == 0 || block.timestamp <= deadline, \"TOO_LATE\");\n\n        _nonces[owner] = currentNonce + 1;\n        _approveFor(owner, spender, value);\n    }\n}\n"
    },
    "src/interfaces/IERC2612.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./IERC2612Standalone.sol\";\n\ninterface IERC2612 is IERC2612Standalone, IERC20 {}\n"
    },
    "src/mock/ERC20WithInitialBalance.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity 0.8.9;\n\nimport \"./UsingBaseERC20Mock.sol\";\nimport \"../interfaces/IERC2612.sol\";\n\n///@notice test ERC20 token that give initial balance to all accounts that can claim it in time.\ncontract ERC20WithInitialBalance is UsingBaseERC20Mock, IERC2612 {\n    bytes32 internal constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    mapping(address => uint256) internal _nonces;\n\n    constructor(\n        uint256 supply,\n        uint256 initialIndividualSupply,\n        address gateway\n    ) UsingBaseERC20Mock(supply, initialIndividualSupply, gateway) {\n        // TODO chainId\n        _DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,address verifyingContract)\"),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                address(this)\n            )\n        );\n    }\n\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _DOMAIN_SEPARATOR;\n    }\n\n    function nonces(address owner) external view override returns (uint256) {\n        return _nonces[owner];\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(owner != address(0), \"INVALID_ZERO_ADDRESS\");\n\n        uint256 currentNonce = _nonces[owner];\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                _DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, currentNonce, deadline))\n            )\n        );\n        require(owner == ecrecover(digest, v, r, s), \"INVALID_SIGNATURE\");\n        require(deadline == 0 || block.timestamp <= deadline, \"TOO_LATE\");\n\n        _nonces[owner] = currentNonce + 1;\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n}\n"
    },
    "src/mock/UsingBaseERC20Mock.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nabstract contract UsingBaseERC20Mock is IERC20 {\n    // //////////////////// EXTERNAL /////////////////////////////\n\n    string public constant name = \"Coin\";\n    string public constant symbol = \"COIN\";\n\n    function totalSupply() external view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address owner) external view override returns (uint256 balance) {\n        (, balance) = _balanceOf(owner);\n    }\n\n    function allowance(address owner, address spender) external view override returns (uint256 remaining) {\n        if (spender == _gateway) {\n            return 2**256 - 1;\n        }\n        return _allowances[owner][spender];\n    }\n\n    function decimals() external pure returns (uint8) {\n        return uint8(18);\n    }\n\n    function transfer(address to, uint256 amount) external override returns (bool success) {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external override returns (bool success) {\n        if (msg.sender != from && msg.sender != _gateway) {\n            uint256 currentAllowance = _allowances[from][msg.sender];\n            if (currentAllowance != (2**256) - 1) {\n                // save gas when allowance is maximal by not reducing it (see https://github.com/ethereum/EIPs/issues/717)\n                require(currentAllowance >= amount, \"NOT_ENOUGH_ALLOWANCE\");\n                _allowances[from][msg.sender] = currentAllowance - amount;\n            }\n        }\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) external override returns (bool success) {\n        require(spender != address(0), \"INVALID_ZERO_ADDRESS\");\n        require(spender != _gateway, \"IMMUTABLE_GATEWAY_ALLOWANCE\");\n        _allowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    // function burn(uint256 amount) external returns (bool) {\n    //     _burn(msg.sender, amount);\n    //     return true;\n    // }\n\n    // function hasClaimed() TODO\n\n    // ////////////////////////////////////// INTERNALS ///////////////////////////////////////////\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        require(to != address(0), \"INVALID_ZERO_ADDRESS\");\n        (bool claimed, uint256 currentBalance) = _balanceOf(from);\n        require(currentBalance >= amount, \"NOT_ENOUGH_BALANCE\");\n        if (!claimed) {\n            _supplyClaimed += currentBalance;\n            _claimed[from] = true; // TODO use bit in _balances to reuse same slot\n        }\n        _balances[from] = currentBalance - amount;\n\n        (claimed, currentBalance) = _balanceOf(to);\n        if (!claimed) {\n            _supplyClaimed += currentBalance;\n            _claimed[to] = true; // TODO use bit in _balances to reuse same slot\n        }\n        _balances[to] = currentBalance + amount;\n        emit Transfer(from, to, amount);\n    }\n\n    function _balanceOf(address owner) internal view returns (bool claimed, uint256 balance) {\n        balance = _balances[owner];\n        if (!_claimed[owner] && _supplyClaimed < _totalSupply) {\n            claimed = false;\n            balance = _totalSupply - _supplyClaimed;\n            if (balance > _initialIndividualSupply) {\n                balance = _initialIndividualSupply;\n            }\n        } else {\n            claimed = true;\n        }\n    }\n\n    // function _mint(address to, uint256 amount) internal {\n    //     require(to != address(0), \"INVALID_ZERO_ADDRESS0\");\n    //     require(amount != 0, \"INVALID_AMOUNT\");\n    //     uint256 currentTotalSupply = _totalSupply;\n    //     uint256 newTotalSupply = currentTotalSupply + amount;\n    //     require(newTotalSupply > currentTotalSupply, \"OVERFLOW\");\n    //     _totalSupply = newTotalSupply;\n    //     _balances[to] += amount;\n    //     emit Transfer(address(0), to, amount);\n    // }\n\n    // function _burn(address from, uint256 amount) internal {\n    //     require(amount > 0, \"INVALID_AMOUNT\");\n    //     if (msg.sender != from) {\n    //         uint256 currentAllowance = _allowances[from][msg.sender];\n    //         require(\n    //             currentAllowance >= amount,\n    //             \"NOT_ENOUGH_ALLOWANCE\"\n    //         );\n    //         if (currentAllowance != (2**256) - 1) {\n    //             // save gas when allowance is maximal by not reducing it (see https://github.com/ethereum/EIPs/issues/717)\n    //             _allowances[from][msg.sender] = currentAllowance - amount;\n    //         }\n    //     }\n\n    //     uint256 currentBalance = balanceOf(from);\n    //     require(currentBalance >= amount, \"NOT_ENOUGH_BALANCE\");\n    //     _balances[from] = currentBalance - amount;\n    //     _totalSupply -= amount;\n    //     emit Transfer(from, address(0), amount);\n    // }\n\n    // /////////////////////////////////// STORAGE SLOTS /////////////////////////////////////////\n\n    uint256 internal immutable _totalSupply;\n    uint256 internal immutable _initialIndividualSupply;\n    mapping(address => uint256) internal _balances;\n    mapping(address => mapping(address => uint256)) internal _allowances;\n\n    uint256 internal _supplyClaimed;\n    mapping(address => bool) internal _claimed; // TODO optimize it by storing it in the same slot as _balances\n\n    address internal immutable _gateway;\n\n    // //////////////////////////////////// CONSTRUCTOR ///////////////////////////////////////////\n    constructor(\n        uint256 supply,\n        uint256 initialIndividualSupply,\n        address gateway\n    ) {\n        _totalSupply = supply;\n        _initialIndividualSupply = initialIndividualSupply;\n        _gateway = gateway;\n    }\n}\n"
    },
    "src/conquest_token/LiquidityEngine.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\nimport \"@uniswap/v2-periphery/contracts/interfaces/IWETH.sol\";\nimport \"../uniswap/interfaces/IUniswapV2PairWithRawLiquidityProvisionOption.sol\";\n\ncontract LiquidityEngine {\n    using SafeERC20 for IERC20;\n\n    uint256 internal constant DECIMALS_18 = 10**18;\n\n    IWETH internal immutable _WETH;\n    IERC20 internal immutable _userProvidedToken;\n    IERC20 internal immutable _systemProvidedToken;\n    uint256 internal immutable _tokenRatio18;\n    IUniswapV2Factory internal immutable _factory;\n    address internal immutable _liquidityReserve;\n\n    // receive() external payable {\n    //     assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\n    // }\n\n    constructor(\n        IWETH weth,\n        IUniswapV2Factory factory,\n        IERC20 userProvidedToken,\n        IERC20 systemProvidedToken,\n        uint256 tokenRatio18,\n        address liquidityReserve\n    ) {\n        _WETH = weth;\n        _factory = factory;\n        _userProvidedToken = userProvidedToken;\n        _systemProvidedToken = systemProvidedToken;\n        _tokenRatio18 = tokenRatio18;\n        _liquidityReserve = liquidityReserve;\n    }\n\n    function addLiquidity(\n        uint256 upToAmountA,\n        address to,\n        uint256 deadline\n    )\n        external\n        ensure(deadline)\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        )\n    {\n        uint256 upToAmountB = (upToAmountA * _tokenRatio18) / DECIMALS_18;\n        uint256 balance = _systemProvidedToken.balanceOf(address(this));\n        if (balance < upToAmountB) {\n            amountB = balance;\n        } else {\n            amountB = upToAmountB;\n        }\n        amountA = (amountB * DECIMALS_18) / _tokenRatio18;\n\n        address pair = _factory.getPair(address(_userProvidedToken), address(_systemProvidedToken));\n        if (pair == address(0)) {\n            pair = _factory.createPair(address(_userProvidedToken), address(_systemProvidedToken));\n        }\n\n        _userProvidedToken.safeTransferFrom(msg.sender, pair, amountA);\n        _systemProvidedToken.safeTransferFrom(address(this), pair, amountB);\n        liquidity = IUniswapV2PairWithRawLiquidityProvisionOption(pair).mintWithRawLiquidityProvision(\n            to,\n            _liquidityReserve\n        );\n    }\n\n    function addLiquidityETH(address to, uint256 deadline)\n        external\n        payable\n        ensure(deadline)\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        )\n    {\n        require(address(_userProvidedToken) == address(_WETH), \"NO_ETH_EXPECTED\");\n        uint256 upToAmountB = (msg.value * _tokenRatio18) / DECIMALS_18;\n        uint256 balance = _systemProvidedToken.balanceOf(address(this));\n        if (balance < upToAmountB) {\n            amountB = balance;\n        } else {\n            amountB = upToAmountB;\n        }\n        amountA = (amountB * DECIMALS_18) / _tokenRatio18;\n\n        address pair = _factory.getPair(address(_userProvidedToken), address(_systemProvidedToken));\n        if (pair == address(0)) {\n            pair = _factory.createPair(address(_userProvidedToken), address(_systemProvidedToken));\n        }\n\n        _WETH.deposit{value: amountA}();\n        require(_WETH.transfer(pair, amountA), \"WETH_FAILED\");\n        _systemProvidedToken.safeTransferFrom(address(this), pair, amountB);\n\n        liquidity = IUniswapV2PairWithRawLiquidityProvisionOption(pair).mintWithRawLiquidityProvision(\n            to,\n            _liquidityReserve\n        );\n\n        if (msg.value > amountA) {\n            payable(msg.sender).transfer(msg.value - amountA);\n        }\n    }\n\n    modifier ensure(uint256 deadline) {\n        require(deadline >= block.timestamp, \"LiquidityEngine: EXPIRED\");\n        _;\n    }\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IWETH.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IWETH {\n    function deposit() external payable;\n    function transfer(address to, uint value) external returns (bool);\n    function withdraw(uint) external;\n}\n"
    },
    "src/uniswap/interfaces/IUniswapV2PairWithRawLiquidityProvisionOption.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.5.0;\n\n// import '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\n\n// modified interface that allow a specific address to provide liquidity at any ratio whil ebeing rewarded its product (k) contribution\n// used by Conquest LiquidityEngine\n// we reuse the solidity 0.5.16 compiler and so we cannot extend interface\n// also `initialize` has an extra argument, the address that have right to provide liquidity that way\n/*is IUniswapV2Pair*/\ninterface IUniswapV2PairWithRawLiquidityProvisionOption {\n    function mintWithRawLiquidityProvision(address to1, address to2) external returns (uint256 liquidity);\n\n    function initialize(\n        address,\n        address,\n        address\n    ) external;\n\n    // ---------------------------------------------------------------------------------------------------------------\n    // IUniswapV2Pair\n    // ---------------------------------------------------------------------------------------------------------------\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function kLast() external view returns (uint256);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    // function initialize(address, address) external;\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Callee.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Callee {\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IERC20.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2ERC20.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2ERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}