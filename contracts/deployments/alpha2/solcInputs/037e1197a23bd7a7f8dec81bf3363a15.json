{
  "language": "Solidity",
  "sources": {
    "src/agent/Agent.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\npragma solidity 0.8.9;\n\nimport \"../OuterSpace.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\ncontract Agent {\n    using ECDSA for bytes32;\n\n    address internal immutable _signer;\n    OuterSpace internal immutable _outerspace;\n    constructor(address signer, OuterSpace outerspace) {\n        _signer = signer;\n        _outerspace = outerspace;\n    }\n\n    // TODO include gasPrice in signed message\n\n    // function resolveFleet(uint256 fleetID, uint256 from, uint256 to, uint256 distance, bytes32 secret, bytes calldata signature) external {\n    //     uint256 startgas = gasleft();\n    //     bytes32 digest = keccak256(\n    //         abi.encodePacked(msg.sender, fleetID, from, to, distance, secret, false)\n    //     ).toEthSignedMessageHash();\n    //     address signer = digest.recover(signature);\n    //     require(signer == _signer);\n    //     _outerspace.resolveFleet(fleetID, from, to, distance, secret);\n    //     payable(msg.sender).transfer(tx.gasprice * ((gasleft() - startgas) + 30000));\n    // }\n\n    // function resolveFleetWithSignerAssumingFailureCost(uint256 fleetID, uint256 from, uint256 to, uint256 distance, bytes32 secret, bytes calldata signature) external {\n    //     uint256 startgas = gasleft();\n    //     bytes32 digest = keccak256(\n    //         abi.encodePacked(msg.sender, fleetID, from, to, distance, secret, true)\n    //     ).toEthSignedMessageHash();\n    //     address signer = digest.recover(signature);\n    //     require(signer == _signer);\n    //     // TODO // try {\n    //         _outerspace.resolveFleet(fleetID, from, to, distance, secret);\n    //     // } catch {\n\n    //     // }\n    //     payable(msg.sender).transfer(tx.gasprice * ((gasleft() - startgas) + 30000));\n    // }\n\n}\n"
    },
    "src/OuterSpace.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\n\npragma solidity 0.8.9;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./Libraries/Extraction.sol\";\nimport \"./Libraries/Math.sol\";\nimport \"hardhat-deploy/solc_0.8/proxy/Proxied.sol\";\nimport \"./Interfaces/IAlliance.sol\";\nimport \"./AllianceRegistry.sol\";\n\ncontract OuterSpace is Proxied {\n    using Extraction for bytes32;\n\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // CONSTANTS\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n    uint256 internal constant DECIMALS_18 = 1e18;\n    uint32 internal constant ACTIVE_MASK = 2**31;\n    int256 internal constant UINT32_MAX = 2**32 - 1;\n\n    int256 internal constant EXPANSION = 8;\n    uint32 internal constant INITIAL_SPACE = 16;\n    uint256 internal constant GIFT_TAX_PER_10000 = 2500;\n\n    uint256 internal constant COMBAT_RULE_SWITCH_TIME = 1620144000; // Tuesday, 4 May 2021 16:00:00 GMT\n\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // CONFIGURATION / IMMUTABLE\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n    AllianceRegistry public immutable allianceRegistry;\n    bytes32 internal immutable _genesis;\n    IERC20 internal immutable _stakingToken;\n    uint256 internal immutable _resolveWindow;\n    uint256 internal immutable _timePerDistance;\n    uint256 internal immutable _exitDuration;\n    uint32 internal immutable _acquireNumSpaceships;\n    uint32 internal immutable _productionSpeedUp;\n    uint256 internal immutable _frontrunningDelay;\n    uint256 internal immutable _productionCapAsDuration;\n    uint256 internal immutable _fleetSizeFactor6;\n\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // STORAGE\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n    mapping(uint256 => Planet) internal _planets;\n    mapping(uint256 => Fleet) internal _fleets;\n\n    // struct AccountData {\n    //     uint128 stakeReadyToBeWithdrawn;\n    //     uint8 numAlliances;\n    // }\n    // mapping(address => AccountData) internal _accounts;\n    mapping(address => uint256) internal _stakeReadyToBeWithdrawn;\n\n    mapping(address => mapping(address => bool)) internal _operators;\n\n    // mapping(address => mapping(IAlliance => uint256)) internal _alliances;\n\n    // front running protection : _frontruunningDelay / 2 slots\n    struct InFlight {\n        uint64 flying;\n        uint64 destroyed;\n    }\n    // TODO make it namespaces per user, currently it is possible (though unlikely) for 2 users to share a slot if one attack another and quickly send away spaceships\n    mapping(uint256 => mapping(uint256 => InFlight)) internal _inFlight;\n\n    struct Discovered {\n        uint32 minX;\n        uint32 maxX;\n        uint32 minY;\n        uint32 maxY;\n    }\n\n    Discovered internal _discovered;\n\n    struct Planet {\n        address owner;\n        uint32 exitTime; // could be used as startTime with first bit telling whether it is exit or startTime => means exiting would produce spacehips / or not, but not based on startTime\n        uint32 numSpaceships; // uint31 + first bit => active\n        uint32 lastUpdated; // also used as native-destruction indicator\n    }\n\n    struct Fleet {\n        address owner;\n        uint32 launchTime;\n        uint32 quantity;\n        // TODO uint32 delay\n    }\n\n    // rewards\n    mapping(address => uint256) internal _prevRewardIds;\n    mapping(uint256 => uint256) internal _rewards;\n    mapping(address => mapping(uint256 => bool)) internal _rewardsToWithdraw;\n\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // EVENTS\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n    event PlanetStake(address indexed acquirer, uint256 indexed location, uint32 numSpaceships, uint256 stake);\n    event FleetSent(\n        address indexed fleetSender,\n        address indexed fleetOwner,\n        uint256 indexed from,\n        address operator,\n        uint256 fleet,\n        uint32 quantity,\n        uint32 newNumSpaceships\n    );\n\n    // TODO add fromPlanet to the event ?\n    event FleetArrived(\n        uint256 indexed fleet,\n        address indexed fleetOwner,\n        address indexed destinationOwner,\n        uint256 destination,\n        bool gift,\n        uint32 fleetLoss,\n        uint32 planetLoss,\n        uint32 inFlightFleetLoss,\n        uint32 inFlightPlanetLoss,\n        bool won,\n        uint32 newNumspaceships\n    );\n\n    // event AllianceLink(IAlliance indexed alliance, address indexed player, bool joining);\n\n    event PlanetReset(uint256 indexed location);\n\n    event PlanetExit(address indexed owner, uint256 indexed location);\n\n    event ExitComplete(address indexed owner, uint256 indexed location, uint256 stake);\n\n    event RewardSetup(uint256 indexed location, address indexed giver, uint256 rewardId);\n    event RewardToWithdraw(address indexed owner, uint256 indexed location, uint256 indexed rewardId);\n\n    event StakeToWithdraw(address indexed owner, uint256 newStake);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    event Initialized(uint32 minX, uint32 maxX, uint32 minY, uint32 maxY, bytes32 genesis);\n\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // CONSTRUCTOR / INITIALIZATION\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n    constructor(\n        IERC20 stakingToken,\n        AllianceRegistry theAllianceRegistry,\n        bytes32 genesis,\n        uint32 resolveWindow,\n        uint32 timePerDistance,\n        uint32 exitDuration,\n        uint32 acquireNumSpaceships,\n        uint32 productionSpeedUp,\n        uint32 frontrunningDelay,\n        uint32 productionCapAsDuration,\n        uint32 fleetSizeFactor6\n    ) {\n        uint32 t = timePerDistance / 4; // the coordinates space is 4 times bigger\n        require(t * 4 == timePerDistance, \"TIME_PER_DIST_NOT_DIVISIBLE_4\");\n\n        _stakingToken = stakingToken;\n        allianceRegistry = theAllianceRegistry;\n        _genesis = genesis;\n        _resolveWindow = resolveWindow;\n        _timePerDistance = t;\n        _exitDuration = exitDuration;\n        _acquireNumSpaceships = acquireNumSpaceships;\n        _productionSpeedUp = productionSpeedUp;\n        _frontrunningDelay = frontrunningDelay;\n        _productionCapAsDuration = productionCapAsDuration;\n        _fleetSizeFactor6 = fleetSizeFactor6;\n\n        postUpgrade(\n            stakingToken,\n            theAllianceRegistry,\n            genesis,\n            resolveWindow,\n            timePerDistance,\n            exitDuration,\n            acquireNumSpaceships,\n            productionSpeedUp,\n            frontrunningDelay,\n            productionCapAsDuration,\n            fleetSizeFactor6\n        );\n    }\n\n    function postUpgrade(\n        IERC20,\n        AllianceRegistry,\n        bytes32 genesis,\n        uint32,\n        uint32,\n        uint32,\n        uint32,\n        uint32,\n        uint32,\n        uint32,\n        uint32\n    ) public proxied {\n        if (_discovered.minX == 0) {\n            _discovered = Discovered({\n                minX: INITIAL_SPACE,\n                maxX: INITIAL_SPACE,\n                minY: INITIAL_SPACE,\n                maxY: INITIAL_SPACE\n            });\n            emit Initialized(_discovered.minX, _discovered.maxX, _discovered.minY, _discovered.maxY, genesis);\n        }\n    }\n\n\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // STAKING / PRODUCTION CAPTURE\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n    function onTokenTransfer(\n        address,\n        uint256 amount,\n        bytes calldata data\n    ) public returns (bool) {\n        require(msg.sender == address(_stakingToken), \"INVALID_ERC20\");\n        (address acquirer, uint256 location) = abi.decode(data, (address, uint256));\n        _acquire(acquirer, amount, location); // we do not care of who the payer is\n        return true;\n    }\n\n    function onTokenPaidFor(\n        address,\n        address forAddress,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool) {\n        require(msg.sender == address(_stakingToken), \"INVALID_ERC20\");\n        uint256 location = abi.decode(data, (uint256));\n        _acquire(forAddress, amount, location); // we do not care of who the payer is\n        return true;\n    }\n\n    function acquireViaTransferFrom(uint256 location, uint256 amount) public {\n        address sender = _msgSender();\n        _acquire(sender, amount, location);\n        _stakingToken.transferFrom(sender, address(this), amount);\n    }\n\n    function resetPlanet(uint256 location) external onlyProxyAdmin {\n        _planets[location].owner = address(0);\n        _planets[location].exitTime = 0;\n        _planets[location].numSpaceships = 0;\n        _planets[location].lastUpdated = 0;\n        emit PlanetReset(location);\n    }\n\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // REWARD SETUP\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // TODO : ERC20, ERC721, ERC1155\n    // remove sponsor, use msg.sender and this could be special contracts\n    // TODO : reenable, removed because of code size issue\n    function addReward(uint256 location, address sponsor) external onlyProxyAdmin {\n        Planet memory planet = _planets[location];\n        if (_hasJustExited(planet.exitTime)) {\n            _setPlanetAfterExit(location, planet.owner, _planets[location], address(0), 0);\n        }\n\n        uint256 rewardId = _rewards[location];\n        if (rewardId == 0) {\n            rewardId = ++_prevRewardIds[sponsor];\n            _rewards[location] = (uint256(uint160(sponsor)) << 96) + rewardId;\n        }\n        // TODO should it fails if different sponsor added reward before\n\n        // TODO rewardId association with the actual rewards // probably contract address holding the reward\n        emit RewardSetup(location, sponsor, rewardId);\n    }\n\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // EXIT / WITHDRAWALS\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n    function exitFor(address owner, uint256 location) external {\n        Planet storage planet = _getPlanet(location);\n        require(owner == planet.owner, \"NOT_OWNER\");\n        require(planet.exitTime == 0, \"EXITING_ALREADY\"); // if you own the planet again, you ll need to first withdraw\n        planet.exitTime = uint32(block.timestamp);\n        emit PlanetExit(owner, location);\n    }\n\n    function fetchAndWithdrawFor(address owner, uint256[] calldata locations) external {\n        uint256 addedStake = 0;\n        for (uint256 i = 0; i < locations.length; i++) {\n            Planet storage planet = _getPlanet(locations[i]);\n            if (_hasJustExited(planet.exitTime)) {\n                require(owner == planet.owner, \"NOT_OWNER\");\n                addedStake += _setPlanetAfterExitWithoutUpdatingStake(locations[i], owner, planet, address(0), 0); // no need of event as exitTime passed basically mean owner zero and spaceships zero\n            }\n        }\n        uint256 newStake = _stakeReadyToBeWithdrawn[owner] + addedStake;\n        _withdrawAll(owner, newStake);\n    }\n\n    function balanceToWithdraw(address owner) external view returns (uint256) {\n        return _stakeReadyToBeWithdrawn[owner];\n    }\n\n    function withdrawFor(address owner) external {\n        uint256 amount = _stakeReadyToBeWithdrawn[owner];\n        _withdrawAll(owner, amount);\n    }\n\n    function _withdrawAll(address owner, uint256 amount) internal {\n        _updateStake(owner, 0);\n        require(_stakingToken.transfer(owner, amount), \"FAILED_TRANSFER\"); // TODO FundManager\n    }\n\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // FLEET RESOLUTION, ATTACK / REINFORCEMENT\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n    struct FleetResolution {\n        uint256 from;\n        uint256 to;\n        uint256 distance;\n        bool gift;\n        address specific;\n        bytes32 secret;\n        address fleetSender;\n        address operator;\n    }\n\n    function resolveFleet(uint256 fleetId, FleetResolution calldata resolution) external {\n         require(\n            uint256(keccak256(\n                abi.encodePacked(\n                    keccak256(abi.encodePacked(resolution.secret, resolution.to, resolution.gift, resolution.specific)),\n                    resolution.from, resolution.fleetSender, resolution.operator\n                )\n            )) == fleetId,\n            \"INVALID_FLEET_DATA_OR_SECRET\"\n        );\n        _resolveFleet(fleetId, resolution);\n    }\n\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // FLEET SENDING\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n\n    struct FleetLaunch {\n        address fleetSender;\n        address fleetOwner;\n        uint256 from;\n        uint32 quantity;\n        bytes32 toHash;\n    }\n\n    function send(\n        uint256 from,\n        uint32 quantity,\n        bytes32 toHash\n    ) external {\n        address sender = _msgSender();\n        uint256 fleetId = uint256(keccak256(abi.encodePacked(toHash, from, sender, sender)));\n        _sendFor(fleetId, sender, FleetLaunch({\n            fleetSender: sender,\n            fleetOwner: sender,\n            from: from,\n            quantity: quantity,\n            toHash: toHash\n        }));\n    }\n\n    function sendFor(FleetLaunch calldata launch) external { //  bytes calldata fleetSignature // TODO for fleetOwner's signature ?\n\n        address operator = _msgSender();\n        if (operator != launch.fleetSender) {\n            require(_operators[launch.fleetSender][operator], \"NOT_AUTHORIZED_TO_SEND\");\n        }\n        uint256 fleetId = uint256(keccak256(abi.encodePacked(launch.toHash, launch.from, launch.fleetSender, operator)));\n\n        if (launch.fleetOwner != launch.fleetSender && launch.fleetOwner != operator) {\n            // TODO use signature from fleetOwner instead?\n            require(_operators[launch.fleetOwner][operator], \"NOT_AUTHORIZED_TO_FLEET\");\n        }\n\n        _sendFor(fleetId, operator, launch);\n    }\n\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // GETTERS\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n    function getFleet(uint256 fleetId, uint256 from)\n        external\n        view\n        returns (\n            address owner,\n            uint32 launchTime,\n            uint32 quantity,\n            uint64 flyingAtLaunch, // can be more than quantity if multiple fleet were launched around the same time from the same planet\n            uint64 destroyedAtLaunch\n        )\n    {\n        launchTime = _fleets[fleetId].launchTime;\n        quantity = _fleets[fleetId].quantity;\n        owner = _fleets[fleetId].owner;\n\n        uint256 timeSlot = launchTime / (_frontrunningDelay / 2);\n        destroyedAtLaunch = _inFlight[from][timeSlot].destroyed;\n        flyingAtLaunch = _inFlight[from][timeSlot].flying;\n    }\n\n    function getGeneisHash() external view returns (bytes32) {\n        return _genesis;\n    }\n\n    struct PlanetStats {\n        int8 subX;\n        int8 subY;\n        uint16 stake;\n        uint16 production;\n        uint16 attack;\n        uint16 defense;\n        uint16 speed;\n        uint16 natives;\n    }\n\n    struct ExternalPlanet {\n        address owner;\n        uint32 exitTime;\n        uint32 numSpaceships;\n        uint32 lastUpdated;\n        bool active;\n        uint256 reward;\n    }\n\n    function getPlanet(uint256 location) external view returns (ExternalPlanet memory state, PlanetStats memory stats) {\n        Planet storage planet = _getPlanet(location);\n        (bool active, uint32 numSpaceships) = _activeNumSpaceships(planet.numSpaceships);\n        state = ExternalPlanet({\n            owner: planet.owner,\n            exitTime: planet.exitTime,\n            numSpaceships: numSpaceships,\n            lastUpdated: planet.lastUpdated,\n            active: active,\n            reward: _rewards[location]\n        });\n        stats = _getPlanetStats(location);\n    }\n\n    function getPlanetStates(uint256[] calldata locations)\n        external\n        view\n        returns (ExternalPlanet[] memory planetStates, Discovered memory discovered)\n    {\n        planetStates = new ExternalPlanet[](locations.length);\n        for (uint256 i = 0; i < locations.length; i++) {\n            Planet storage planet = _getPlanet(locations[i]);\n            (bool active, uint32 numSpaceships) = _activeNumSpaceships(planet.numSpaceships);\n            planetStates[i] = ExternalPlanet({\n                owner: planet.owner,\n                exitTime: planet.exitTime,\n                numSpaceships: numSpaceships,\n                lastUpdated: planet.lastUpdated,\n                active: active,\n                reward: _rewards[locations[i]]\n            });\n        }\n        discovered = _discovered;\n    }\n\n    function getDiscovered() external view returns (Discovered memory) {\n        return _discovered;\n    }\n\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // ERC721 : // TODO\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n    function setApprovalForAll(address operator, bool approved) external {\n        address sender = _msgSender();\n        _operators[sender][operator] = approved;\n        emit ApprovalForAll(sender, operator, approved);\n    }\n\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // INTERNALS\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n    // function _actualiseExit(uint256 location) internal {\n    //     Planet storage planet = _getPlanet(location);\n    //     if (planet.exitTime > 0 && block.timestamp > planet.exitTime + _exitDuration) {\n    //         uint16 stake = _stake(location);\n    //         address owner = planet.owner;\n    //         planet.exitTime = 0;\n    //         planet.owner = address(0); // This is fine as long as _actualiseExit is called on every move\n    //         planet.numSpaceships = 0; // This is fine as long as _actualiseExit is called on every move\n    //         planet.lastUpdated = uint32(block.timestamp); // This is fine as long as _actualiseExit is called on every move\n    //         _stakeReadyToBeWithdrawn[owner] += stake * DECIMALS_18;\n    //     }\n    // }\n\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // STAKING / PRODUCTION CAPTURE\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n    function _acquire(\n        address sender,\n        uint256 stake,\n        uint256 location\n    ) internal {\n        // console.logBytes32(bytes32(location));\n        bytes32 data = _planetData(location);\n        require(stake == uint256(_stake(data)) * (DECIMALS_18), \"INVALID_AMOUNT\");\n\n        uint32 numSpaceships = _handleSpaceships(sender, location, data);\n        _handleDiscovery(location);\n        emit PlanetStake(sender, location, numSpaceships, stake);\n    }\n\n    function _handleSpaceships(\n        address sender,\n        uint256 location,\n        bytes32 data\n    ) internal returns (uint32) {\n        Planet storage planet = _getPlanet(location);\n        Planet memory mplanet = planet;\n\n        (bool active, uint32 currentNumSpaceships) = _getCurrentNumSpaceships(\n            mplanet.numSpaceships,\n            mplanet.lastUpdated,\n            _production(data)\n        );\n\n        bool justExited;\n        uint32 defense;\n        if (mplanet.lastUpdated == 0) {\n            defense = _natives(data);\n        } else {\n            if (mplanet.exitTime != 0) {\n                require(_hasJustExited(mplanet.exitTime), \"STILL_EXITING\");\n                justExited = true;\n            } else {\n                require(!active, \"STILL_ACTIVE\");\n\n                // Do not allow staking over occupied planets\n                require(mplanet.owner == sender || currentNumSpaceships == 0, \"OCCUPIED\");\n                // used to be the following (but this gave too many cons to send spaceships to non-active planets):\n                // if (mplanet.owner != sender) {\n                //     defense = currentNumSpaceships;\n                // } else {\n                //     defense = 0;\n                // }\n            }\n        }\n        if (justExited) {\n            currentNumSpaceships = _acquireNumSpaceships;\n            _setPlanetAfterExit(\n                location,\n                mplanet.owner,\n                planet,\n                sender,\n                _setActiveNumSpaceships(true, currentNumSpaceships)\n            );\n        } else {\n            planet.owner = sender;\n            if (defense != 0) {\n                uint32 attackerLoss;\n                if (block.timestamp > COMBAT_RULE_SWITCH_TIME) {\n                    (attackerLoss, ) = _computeFight(_acquireNumSpaceships, defense, 10000, _defense(data));\n                } else {\n                    (attackerLoss, ) = _old_computeFight(_acquireNumSpaceships, defense, 10000, _defense(data));\n                }\n\n                // attacker alwasy win as defense (and stats.native) is restricted to 3500\n                // (attackerLoss: 0, defenderLoss: 0) would mean defense was zero\n                require(attackerLoss < _acquireNumSpaceships, \"FAILED_CAPTURED\");\n                currentNumSpaceships = _acquireNumSpaceships - attackerLoss;\n            } else {\n                currentNumSpaceships += _acquireNumSpaceships;\n            }\n\n            // planet.exitTime = 0; // should not be needed : // TODO actualiseExit\n            planet.numSpaceships = _setActiveNumSpaceships(true, currentNumSpaceships);\n            planet.lastUpdated = uint32(block.timestamp);\n        }\n        return currentNumSpaceships;\n    }\n\n    // solhint-disable-next-line code-complexity\n    function _handleDiscovery(uint256 location) internal {\n        Discovered memory discovered = _discovered;\n\n        int256 x = int256(int128(int256(location & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)));\n        int256 y = int256(int128(int256(location >> 128)));\n\n        bool changes = false;\n        if (x < 0) {\n            require(-x <= int256(uint256(discovered.minX)), \"NOT_REACHABLE_YET_MINX\");\n            x = -x + EXPANSION;\n            if (x > UINT32_MAX) {\n                x = UINT32_MAX;\n            }\n            if (int256(uint256(discovered.minX)) < x) {\n                discovered.minX = uint32(uint256(x));\n                changes = true;\n            }\n        } else {\n            require(x <= int256(uint256(discovered.maxX)), \"NOT_REACHABLE_YET_MAXX\");\n            x = x + EXPANSION;\n            if (x > UINT32_MAX) {\n                x = UINT32_MAX;\n            }\n            if (discovered.maxX < uint32(uint256(x))) {\n                discovered.maxX = uint32(uint256(x));\n                changes = true;\n            }\n        }\n\n        if (y < 0) {\n            require(-y <= int256(uint256(discovered.minY)), \"NOT_REACHABLE_YET_MINY\");\n            y = -y + EXPANSION;\n            if (y > UINT32_MAX) {\n                y = UINT32_MAX;\n            }\n            if (int256(uint256(discovered.minY)) < y) {\n                discovered.minY = uint32(uint256(y));\n                changes = true;\n            }\n        } else {\n            require(y <= int256(uint256(discovered.maxY)), \"NOT_REACHABLE_YET_MAXY\");\n            y = y + EXPANSION;\n            if (y > UINT32_MAX) {\n                y = UINT32_MAX;\n            }\n            if (int256(uint256(discovered.maxY)) < y) {\n                discovered.maxY = uint32(uint256(y));\n                changes = true;\n            }\n        }\n        if (changes) {\n            _discovered = discovered;\n        }\n    }\n\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // EXITS / WITHDRAWALS\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n    function _hasJustExited(uint32 exitTime) internal view returns (bool) {\n        return exitTime > 0 && block.timestamp > exitTime + _exitDuration;\n    }\n\n    function _setPlanetAfterExit(\n        uint256 location,\n        address owner,\n        Planet storage planet,\n        address newOwner,\n        uint32 spaceshipsData\n    ) internal {\n        uint256 addedStake = _setPlanetAfterExitWithoutUpdatingStake(location, owner, planet, newOwner, spaceshipsData);\n        _updateStake(owner, _stakeReadyToBeWithdrawn[owner] + addedStake);\n    }\n\n    function _updateStake(address owner, uint256 newStake) internal {\n        _stakeReadyToBeWithdrawn[owner] = newStake;\n        emit StakeToWithdraw(owner, newStake);\n    }\n\n    function _setPlanetAfterExitWithoutUpdatingStake(\n        uint256 location,\n        address owner,\n        Planet storage planet,\n        address newOwner,\n        uint32 spaceshipsData\n    ) internal returns (uint256) {\n        bytes32 data = _planetData(location);\n        uint256 stake = uint256(_stake(data)) * (DECIMALS_18);\n        emit ExitComplete(owner, location, stake);\n\n        // --------------------------------------------------------\n        // Extra Reward was added\n        // --------------------------------------------------------\n        uint256 rewardId = _rewards[location];\n        if (rewardId != 0) {\n            _rewardsToWithdraw[owner][rewardId] = true; // rewardId would contains the package. maybe this could be handled by an external contract\n            _rewards[location] = 0; // reset / if you had reward to a planet in he process of exiting, you are adding the reward to the player exiting unless _setPlanetAfterExit is called first\n            emit RewardToWithdraw(owner, location, rewardId);\n        }\n        // --------------------------------------------------------\n\n        planet.exitTime = 0;\n        planet.owner = newOwner; // This is fine as long as _actualiseExit is called on every move\n        planet.lastUpdated = uint32(block.timestamp); // This is fine as long as _actualiseExit is called on every move\n        planet.numSpaceships = spaceshipsData;\n        return stake;\n    }\n\n    /*\n    uint256 newStake = _stakeReadyToBeWithdrawn[owner] + stake * DECIMALS_18;\n    _stakeReadyToBeWithdrawn[owner] = newStake;\n    emit StakeToWithdraw(owner, newStake);\n    */\n\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // FLEET SENDING\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n    function _sendFor(uint256 fleetId, address operator, FleetLaunch memory launch) internal {\n        Planet storage planet = _getPlanet(launch.from);\n\n        require(planet.exitTime == 0, \"PLANET_EXIT\");\n        require(launch.fleetSender == planet.owner, \"NOT_OWNER\");\n\n        bytes32 data = _planetData(launch.from);\n        uint16 production = _production(data);\n\n        (bool active, uint32 currentNumSpaceships) = _getCurrentNumSpaceships(\n            planet.numSpaceships,\n            planet.lastUpdated,\n            production\n        );\n        require(currentNumSpaceships >= launch.quantity, \"SPACESHIPS_NOT_ENOUGH\");\n\n        (uint32 launchTime, uint32 numSpaceships) = _computeSpaceshipBeforeSending(currentNumSpaceships, active, launch.from, launch.quantity);\n\n\n        _fleets[fleetId] = Fleet({launchTime: launchTime, owner: launch.fleetOwner, quantity: launch.quantity});\n\n        emit FleetSent(launch.fleetSender, launch.fleetOwner, launch.from, operator, fleetId, launch.quantity, numSpaceships);\n    }\n\n    function _computeSpaceshipBeforeSending(\n        uint32 currentNumSpaceships,\n        bool active,\n        uint256 from,\n        uint32 quantity\n    ) internal returns( uint32 launchTime, uint32 numSpaceships) {\n        Planet storage planet = _getPlanet(from);\n         // ----------------------------------------------------------------------------------------------------------------------------------------------------------\n        // record flying fleets (to prevent front-running, see resolution)\n        // ----------------------------------------------------------------------------------------------------------------------------------------------------------\n        uint256 timeSlot = block.timestamp / (_frontrunningDelay / 2);\n        uint64 flying = _inFlight[from][timeSlot].flying;\n        flying = flying + quantity;\n        require(flying >= quantity, \"OVERFLOW\"); // unlikely to ever happen, would need a hug amount of spaceships to be received and each in turn being sent\n        _inFlight[from][timeSlot].flying = flying;\n        // ----------------------------------------------------------------------------------------------------------------------------------------------------------\n\n        launchTime = uint32(block.timestamp); // TODO allow delay : launchTime in future\n        numSpaceships = currentNumSpaceships - quantity;\n        planet.numSpaceships = _setActiveNumSpaceships(active, numSpaceships);\n        planet.lastUpdated = launchTime;\n\n    }\n\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // FLEET RESOLUTION, ATTACK / REINFORCEMENT\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n    struct FleetResult {\n        uint32 inFlightPlanetLoss;\n        uint32 attackerLoss;\n        uint32 defenderLoss;\n        bool won;\n        uint32 numSpaceships;\n    }\n\n    function _resolveFleet(uint256 fleetId, FleetResolution memory resolution) internal {\n        Fleet memory fleet = _fleets[fleetId];\n        (uint32 quantity, uint32 inFlightFleetLoss) = _checkFleetAndComputeQuantityLeft(\n            fleet,\n            resolution\n        );\n        Planet memory toPlanet = _getPlanet(resolution.to);\n        _resolveAndEmit(fleetId, toPlanet, _hasJustExited(toPlanet.exitTime) ? address(0) : toPlanet.owner, fleet, resolution, quantity, inFlightFleetLoss);\n    }\n\n    function _resolveAndEmit(uint256 fleetId, Planet memory toPlanet, address destinationOwner, Fleet memory fleet, FleetResolution memory resolution, uint32 quantity, uint32 inFlightFleetLoss) internal {\n        (bool gifting, bool taxed) = _checkGifting(fleet.owner, resolution, toPlanet, fleet.launchTime); // TODO fleet.owner or sender or origin (or seller) ?\n        FleetResult memory result = _performResolution(fleet, resolution.from, toPlanet, resolution.to, gifting, taxed, quantity);\n         emit_fleet_arrived(\n            fleet.owner,\n            fleetId,\n            destinationOwner,\n            resolution.to,\n            gifting,\n            result,\n            inFlightFleetLoss\n        );\n        _fleets[fleetId].quantity = 0; // TODO reset all to get gas refund? // TODO ensure frontend can still easily check fleet status\n    }\n\n\n    function _checkGifting(address sender, FleetResolution memory resolution, Planet memory toPlanet, uint256 fleetLaunchTime) internal returns(bool gifting, bool taxed) {\n        if (toPlanet.owner == address(0)) {\n            // destination has no owner : this is an attack\n            return (false, false);\n        }\n        if (toPlanet.owner == sender) {\n            // destination is sender: this is a non-taxed gift\n            return (true, false);\n        }\n\n        if (resolution.gift) {\n            // intent was gift\n            if (resolution.specific == address(0) || resolution.specific == toPlanet.owner) {\n                // and it was for anyone or specific destination owner that is the same as the current one\n\n                (, uint96 joinTime) = allianceRegistry.havePlayersAnAllianceInCommon(sender, toPlanet.owner, fleetLaunchTime);\n                return (true, joinTime == 0 || joinTime > fleetLaunchTime);\n            }\n\n            if (resolution.specific == address(1)) {\n                // or the specific specify any common alliances (1)\n\n                (, uint96 joinTime) = allianceRegistry.havePlayersAnAllianceInCommon(sender, toPlanet.owner, fleetLaunchTime);\n                return (joinTime > 0, joinTime > fleetLaunchTime);\n            }\n\n            if (uint160(resolution.specific) > 1) {\n                // or a specific one that matches\n\n                (uint96 joinTimeToSpecific,) = allianceRegistry.getAllianceData(toPlanet.owner, IAlliance(resolution.specific));\n\n                if (joinTimeToSpecific > 0) {\n                    (, uint96 joinTime) = allianceRegistry.havePlayersAnAllianceInCommon(sender, toPlanet.owner, fleetLaunchTime);\n                    return (true, joinTime == 0 || joinTime > fleetLaunchTime);\n                }\n            }\n        } else {\n            // intent was attack\n            if (resolution.specific == address(1)) {\n                // and the attack was on any non-allies\n\n                // make it a gift if the destination owner is actually an ally\n                (, uint96 joinTime) = allianceRegistry.havePlayersAnAllianceInCommon(sender, toPlanet.owner, fleetLaunchTime);\n                return (joinTime > 0, joinTime > fleetLaunchTime);\n            }\n\n            if (uint160(resolution.specific) > 1 && resolution.specific != toPlanet.owner) {\n                // but specific not matching current owner\n\n                (uint96 joinTimeToSpecific,) = allianceRegistry.getAllianceData(toPlanet.owner, IAlliance(resolution.specific));\n\n                // make it a gift if the destination is not matching the specific alliance (or owner, in which case since it is not an alliance, it will also not match)\n                if (joinTimeToSpecific == 0) {\n                    (, uint96 joinTime) = allianceRegistry.havePlayersAnAllianceInCommon(sender, toPlanet.owner, fleetLaunchTime);\n                    return (true, joinTime == 0 || joinTime > fleetLaunchTime);\n                }\n            }\n\n        }\n    }\n\n    function _performResolution(\n        Fleet memory fleet,\n        uint256 from,\n        Planet memory toPlanet,\n        uint256 to,\n        bool gifting,\n        bool taxed,\n        uint32 quantity\n    ) internal returns (FleetResult memory result) {\n        if (gifting) {\n            return _performReinforcement(fleet.owner, toPlanet, to, quantity, taxed, fleet.launchTime);\n        } else {\n            return _performAttack(fleet.owner, fleet.launchTime, from, toPlanet, to, quantity);\n        }\n    }\n\n    function _checkFleetAndComputeQuantityLeft(\n        Fleet memory fleet,\n        FleetResolution memory resolution\n    ) internal returns (uint32 quantity, uint32 inFlightFleetLoss) {\n\n        quantity = fleet.quantity;\n        require(quantity > 0, \"FLEET_DO_NOT_EXIST\");\n\n        // ----------------------------------------------------------------------------------------------------------------------------------------------------------\n        // check if fleet was attacked while departing (used to prevent front-running, see fleet sending)\n        // ----------------------------------------------------------------------------------------------------------------------------------------------------------\n        quantity = _fleet_flying_at_origin(quantity, resolution.from, fleet.launchTime);\n        inFlightFleetLoss = fleet.quantity - quantity;\n        // ----------------------------------------------------------------------------------------------------------------------------------------------------------\n\n        _checkDistance(resolution.distance, resolution.from, resolution.to);\n        _checkTime(resolution.distance, resolution.from, fleet.launchTime);\n    }\n\n    function emit_fleet_arrived(\n        address fleetOwner,\n        uint256 fleetID,\n        address toOwner,\n        uint256 to,\n        bool gift,\n        FleetResult memory result,\n        uint32 inFlightFleetLoss\n    ) internal {\n        emit FleetArrived(\n            fleetID,\n            fleetOwner,\n            toOwner,\n            to,\n            gift,\n            result.attackerLoss,\n            result.defenderLoss,\n            inFlightFleetLoss,\n            result.inFlightPlanetLoss,\n            result.won,\n            result.numSpaceships\n        );\n    }\n\n    function _fleet_flying_at_origin(\n        uint32 quantity,\n        uint256 from,\n        uint32 launchTime\n    ) internal returns (uint32) {\n        uint256 timeSlot = launchTime / (_frontrunningDelay / 2);\n        uint64 destroyed = _inFlight[from][timeSlot].destroyed;\n        if (destroyed < quantity) {\n            quantity -= uint32(destroyed);\n            _inFlight[from][timeSlot].destroyed = 0;\n        } else {\n            quantity = 0;\n            _inFlight[from][timeSlot].destroyed = destroyed - quantity;\n        }\n        return quantity;\n    }\n\n    function _performAttack(\n        address attacker,\n        uint32 launchTime,\n        uint256 from,\n        Planet memory toPlanet,\n        uint256 to,\n        uint32 numAttack\n    ) internal returns (FleetResult memory result) {\n        if (toPlanet.lastUpdated == 0) {\n            // Planet was never touched (previous attack could have failed to succeed attack on natives)\n            bytes32 toPlanetData = _planetData(to);\n            return _nativeAttack(attacker, launchTime, from, to, toPlanetData, numAttack);\n        } else if (_hasJustExited(toPlanet.exitTime)) {\n            return _fleetAfterExit(to, toPlanet.owner, _planets[to], attacker, numAttack);\n        } else {\n            bytes32 toPlanetData = _planetData(to);\n            uint16 attack = _attack(_planetData(from));\n            uint16 defense = _defense(toPlanetData);\n            uint16 production = _production(toPlanetData);\n            return _actualAttack(attacker, launchTime, attack, defense, toPlanet, to, production, numAttack);\n        }\n    }\n\n    function _fleetAfterExit(\n        uint256 to,\n        address owner,\n        Planet storage planet,\n        address newOwner,\n        uint32 numSpaceshipsArrived\n    ) internal returns (FleetResult memory result) {\n        _setPlanetAfterExit(to, owner, planet, numSpaceshipsArrived > 0 ? newOwner : address(0), numSpaceshipsArrived);\n        result.numSpaceships = numSpaceshipsArrived;\n        result.won = numSpaceshipsArrived > 0; // TODO does it make sense if reinforcement ?\n    }\n\n    function _nativeAttack(\n        address attacker,\n        uint32 launchTime,\n        uint256 from,\n        uint256 to,\n        bytes32 toData,\n        uint32 numAttack\n    ) internal returns (FleetResult memory result) {\n        uint16 attack = _attack(_planetData(from));\n        uint16 defense = _defense(toData);\n        uint16 natives = _natives(toData);\n        uint32 attackerLoss;\n        uint32 defenderLoss;\n        if (launchTime > COMBAT_RULE_SWITCH_TIME) {\n            (attackerLoss, defenderLoss) = _computeFight(numAttack, natives, attack, defense);\n        } else {\n            (attackerLoss, defenderLoss) = _old_computeFight(numAttack, natives, attack, defense);\n        }\n        result.attackerLoss = attackerLoss;\n        if (defenderLoss == natives && numAttack > attackerLoss) {\n            // (attackerLoss: 0, defenderLoss: 0) means that numAttack was zero as natives cannot be zero\n            result.numSpaceships = numAttack - attackerLoss;\n            _planets[to].numSpaceships = _setActiveNumSpaceships(false, result.numSpaceships);\n            _planets[to].lastUpdated = uint32(block.timestamp);\n            _planets[to].owner = attacker;\n            result.defenderLoss = defenderLoss;\n            result.won = true;\n        }\n    }\n\n    function _actualAttack(\n        address attacker,\n        uint32 launchTime,\n        uint16 attack,\n        uint16 defense,\n        Planet memory toPlanet,\n        uint256 to,\n        uint16 production,\n        uint32 numAttack\n    ) internal returns (FleetResult memory result) {\n        PreCombatState memory state = _getPlanetPreCombatState(toPlanet, to, production);\n\n        if (state.numDefense == 0 && numAttack > 0) {\n            _planets[to].owner = attacker;\n            _planets[to].exitTime = 0;\n            _planets[to].numSpaceships = _setActiveNumSpaceships(state.active, numAttack);\n            _planets[to].lastUpdated = uint32(block.timestamp);\n            result.won = true;\n            result.numSpaceships = numAttack;\n            return result;\n        }\n\n        return _completeCombatResult(state, attacker, launchTime, to, numAttack, attack, defense);\n    }\n\n    struct PreCombatState {\n        bool active;\n        uint32 currentNumSpaceships;\n        uint32 numDefense;\n        uint64 flying1;\n        uint64 destroyed1;\n        uint64 flying2;\n        uint64 destroyed2;\n    }\n\n    function _getPlanetPreCombatState(\n        Planet memory toPlanet,\n        uint256 to,\n        uint16 production\n    ) internal view returns (PreCombatState memory state) {\n        (bool active, uint32 currentNumSpaceships) = _getCurrentNumSpaceships(\n            toPlanet.numSpaceships,\n            toPlanet.lastUpdated,\n            production\n        );\n\n        (\n            uint32 numDefense,\n            uint64 flying1,\n            uint64 destroyed1,\n            uint64 flying2,\n            uint64 destroyed2\n        ) = computeDefenseWithInFlightFleets(currentNumSpaceships, to);\n        state.active = active;\n        state.currentNumSpaceships = currentNumSpaceships;\n        state.numDefense = numDefense;\n        state.flying1 = flying1;\n        state.destroyed1 = destroyed1;\n        state.flying2 = flying2;\n        state.destroyed2 = destroyed2;\n    }\n\n    function computeDefenseWithInFlightFleets(uint32 numSpaceships, uint256 to)\n        internal\n        view\n        returns (\n            uint32 numDefense,\n            uint64 flying1,\n            uint64 destroyed1,\n            uint64 flying2,\n            uint64 destroyed2\n        )\n    {\n        numDefense = numSpaceships;\n        // ----------------------------------------------------------------------------------------------------------------------------------------------------------\n        // consider fleets that just departed from the planet (used to prevent front-running, see fleet sending)\n        // ----------------------------------------------------------------------------------------------------------------------------------------------------------\n        uint256 timeSlot = block.timestamp / (_frontrunningDelay / 2);\n        flying1 = _inFlight[to][timeSlot - 1].flying;\n        destroyed1 = _inFlight[to][timeSlot - 1].flying;\n        flying2 = _inFlight[to][timeSlot].flying;\n        destroyed2 = _inFlight[to][timeSlot].destroyed;\n        numDefense = uint32(Math.min(flying1 + flying2 + numDefense, 2**32 - 1));\n        // ----------------------------------------------------------------------------------------------------------------------------------------------------------\n    }\n\n    function _completeCombatResult(\n        PreCombatState memory state,\n        address attacker,\n        uint32 launchTime,\n        uint256 to,\n        uint32 numAttack,\n        uint16 attack,\n        uint16 defense\n    ) internal returns (FleetResult memory result) {\n        uint32 attackerLoss;\n        uint32 defenderLoss;\n        if (launchTime > COMBAT_RULE_SWITCH_TIME) {\n            (attackerLoss, defenderLoss) = _computeFight(numAttack, state.numDefense, attack, defense);\n        } else {\n            (attackerLoss, defenderLoss) = _old_computeFight(numAttack, state.numDefense, attack, defense);\n        }\n        result.attackerLoss = attackerLoss;\n        result.defenderLoss = defenderLoss;\n\n        // ----------------------------------------------------------------------------------------------------------------------------------------------------------\n        // consider fleets that just departed from the planet (used to prevent front-running, see fleet sending)\n        // ----------------------------------------------------------------------------------------------------------------------------------------------------------\n        if (result.defenderLoss > state.currentNumSpaceships) {\n            result.inFlightPlanetLoss = defenderLoss - state.currentNumSpaceships;\n            result.defenderLoss = state.currentNumSpaceships;\n            if (state.flying1 >= result.inFlightPlanetLoss) {\n                state.flying1 -= result.inFlightPlanetLoss;\n                state.destroyed1 += result.inFlightPlanetLoss;\n            } else {\n                state.destroyed1 += state.flying1;\n                uint64 extra = (result.inFlightPlanetLoss - state.flying1);\n                if (state.flying2 >= extra) {\n                    state.flying2 -= extra;\n                    state.destroyed2 += extra;\n                } else {\n                    state.destroyed2 += state.flying2;\n                    state.flying2 = 0; // should never reach minus but let simply set it to zero\n                }\n                state.flying1 = 0;\n            }\n            _inFlight[to][block.timestamp / (_frontrunningDelay / 2) - 1].flying = state.flying1;\n            _inFlight[to][block.timestamp / (_frontrunningDelay / 2) - 1].destroyed = state.destroyed1;\n            _inFlight[to][block.timestamp / (_frontrunningDelay / 2)].flying = state.flying2;\n            _inFlight[to][block.timestamp / (_frontrunningDelay / 2)].destroyed = state.destroyed2;\n        }\n        // ----------------------------------------------------------------------------------------------------------------------------------------------------------\n        // (attackerLoss: 0, defenderLoss: 0) could either mean attack was zero or defense was zero :\n        if (numAttack > 0 && result.defenderLoss == state.currentNumSpaceships) {\n            result.numSpaceships = numAttack - attackerLoss;\n            result.won = true;\n            _planets[to].owner = attacker;\n            _planets[to].exitTime = 0;\n            _planets[to].numSpaceships = _setActiveNumSpaceships(state.active, result.numSpaceships);\n            _planets[to].lastUpdated = uint32(block.timestamp);\n        } else if (result.attackerLoss == numAttack) {\n            // always true as if attack won it will be going in the \"if\" above\n            result.numSpaceships = state.currentNumSpaceships - defenderLoss;\n            _planets[to].numSpaceships = _setActiveNumSpaceships(state.active, result.numSpaceships);\n            _planets[to].lastUpdated = uint32(block.timestamp);\n        } else {\n            assert(false); // should not happen\n        }\n    }\n\n    function _performReinforcement(\n        address sender,\n        Planet memory toPlanet,\n        uint256 to,\n        uint32 quantity,\n        bool taxed,\n        uint32 launchTime\n    ) internal returns (FleetResult memory result) {\n        if (_hasJustExited(toPlanet.exitTime)) {\n            address newOwner = toPlanet.owner;\n            if (newOwner == address(0)) {\n                newOwner = sender;\n            }\n            return _fleetAfterExit(to, toPlanet.owner, _planets[to], quantity > 0 ? newOwner : address(0), quantity);\n        } else {\n            if (taxed) {\n                quantity = uint32(uint256(quantity) - (uint256(quantity) * GIFT_TAX_PER_10000) / 10000);\n            }\n            bytes32 toPlanetData = _planetData(to);\n            uint16 production = _production(toPlanetData);\n            (bool active, uint32 currentNumSpaceships) = _getCurrentNumSpaceships(\n                toPlanet.numSpaceships,\n                toPlanet.lastUpdated,\n                production\n            );\n            uint256 newNumSpaceships = currentNumSpaceships + quantity;\n            if (newNumSpaceships >= ACTIVE_MASK) {\n                newNumSpaceships = ACTIVE_MASK - 1;\n            }\n            _planets[to].lastUpdated = uint32(block.timestamp);\n            _planets[to].numSpaceships = _setActiveNumSpaceships(active, uint32(newNumSpaceships));\n            result.numSpaceships = uint32(newNumSpaceships);\n        }\n    }\n\n    function _computeFight(\n        uint256 numAttack,\n        uint256 numDefense,\n        uint256 attack,\n        uint256 defense\n    ) internal view returns (uint32 attackerLoss, uint32 defenderLoss) {\n        if (numAttack == 0 || numDefense == 0) {\n            return (0, 0); // this edge case need to be considered, as the result of this function cannot tell from it whos is winning here\n        }\n\n        uint256 attackFactor = numAttack * ((1000000 - _fleetSizeFactor6) + (_fleetSizeFactor6 * numAttack / numDefense));\n        uint256 attackDamage = (attackFactor * attack) / defense / 1000000;\n\n        if (numDefense > attackDamage) {\n            // attack fails\n            attackerLoss = uint32(numAttack); // all attack destroyed\n            defenderLoss = uint32(attackDamage); // 1 spaceship will be left at least as attackDamage < numDefense\n        } else {\n            // attack succeed\n            uint256 defenseFactor = numDefense * ((1000000 - _fleetSizeFactor6) + (_fleetSizeFactor6 * numDefense / numAttack));\n            uint256 defenseDamage = uint32((defenseFactor * defense) / attack / 1000000);\n\n            if (defenseDamage >= numAttack) {\n                defenseDamage = numAttack - 1; // ensure 1 spaceship left\n            }\n\n            attackerLoss = uint32(defenseDamage);\n            defenderLoss = uint32(numDefense); // all defense destroyed\n        }\n    }\n\n    function _old_computeFight(\n        uint256 numAttack,\n        uint256 numDefense,\n        uint256 attack,\n        uint256 defense\n    ) internal pure returns (uint32 attackerLoss, uint32 defenderLoss) {\n        if (numAttack == 0 || numDefense == 0) {\n            return (0, 0);\n        }\n        uint256 attackPower = (numAttack * attack);\n        uint256 defensePower = (numDefense * defense);\n\n        uint256 numAttackRound = (numDefense * 100000000) / attackPower;\n        if (numAttackRound * attackPower < (numDefense * 100000000)) {\n            numAttackRound++;\n        }\n        uint256 numDefenseRound = (numAttack * 100000000) / defensePower;\n        if (numDefenseRound * defensePower < (numAttack * 100000000)) {\n            numDefenseRound++;\n        }\n\n        uint256 numRound = Math.min(numAttackRound, numDefenseRound);\n        attackerLoss = uint32(Math.min((numRound * defensePower) / 100000000, numAttack));\n        defenderLoss = uint32(Math.min((numRound * attackPower) / 100000000, numDefense));\n    }\n\n    function _checkDistance(\n        uint256 distance,\n        uint256 from,\n        uint256 to\n    ) internal view {\n        (int8 fromSubX, int8 fromSubY) = _subLocation(_planetData(from));\n        (int8 toSubX, int8 toSubY) = _subLocation(_planetData(to));\n        // check input instead of compute sqrt\n\n        uint256 distanceSquared = uint256(int256( // check input instead of compute sqrt\n            ((int128(int256(to & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) * 4 + toSubX) -\n                (int128(int256(from & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) * 4 + fromSubX)) **\n                2 +\n                ((int128(int256(to >> 128)) * 4 + toSubY) - (int128(int256(from >> 128)) * 4 + fromSubY))**2\n        ));\n        require(distance**2 <= distanceSquared && distanceSquared < (distance + 1)**2, \"wrong distance\");\n    }\n\n    function _checkTime(\n        uint256 distance,\n        uint256 from,\n        uint32 launchTime\n    ) internal view {\n        uint256 reachTime = launchTime + (distance * (_timePerDistance * 10000)) / _speed(_planetData(from));\n        require(block.timestamp >= reachTime, \"too early\");\n        require(block.timestamp < reachTime + _resolveWindow, \"too late, your spaceships are lost in space\");\n    }\n\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // PLANET STATS\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n    function _planetData(uint256 location) internal view returns (bytes32) {\n        return keccak256(abi.encodePacked(_genesis, location));\n    }\n\n    function _subLocation(bytes32 data) internal pure returns (int8 subX, int8 subY) {\n        subX = 1 - int8(data.value8Mod(0, 3));\n        subY = 1 - int8(data.value8Mod(2, 3));\n    }\n\n    // // 4,5,5,10,10,15,15, 20, 20, 30,30,40,40,80,80,100\n    // bytes32 constant stakeRange = 0x000400050005000A000A000F000F00140014001E001E00280028005000500064;\n\n    // 6, 8, 10, 12, 14, 16, 18, 20, 20, 22, 24, 32, 40, 48, 56, 72\n    bytes32 constant stakeRange = 0x00060008000A000C000E00100012001400140016001800200028003000380048;\n\n    function _stake(bytes32 data) internal pure returns (uint16) {\n        require(_exists(data), \"PLANET_NOT_EXISTS\");\n        // return data.normal16(4, 0x000400050005000A000A000F000F00140014001E001E00280028005000500064);\n        uint8 productionIndex = data.normal8(12); // production affect the stake value\n\n        // TODO remove or decide otherwise:\n        // uint16 offset = data.normal16(4, 0x0000000100010002000200030003000400040005000500060006000700070008);\n        // uint16 stakeIndex = productionIndex + offset;\n        // if (stakeIndex < 4) {\n        //     stakeIndex = 0;\n        // } else if (stakeIndex > 19) {\n        //     stakeIndex = 15;\n        // } else {\n        //     stakeIndex -= 4;\n        // }\n        uint16 stakeIndex = productionIndex;\n        return uint16(uint8(stakeRange[stakeIndex * 2 + 1])); // skip stakeIndex * 2 + 0 as it is always zero in stakeRange\n    }\n\n    function _production(bytes32 data) internal pure returns (uint16) {\n        require(_exists(data), \"PLANET_NOT_EXISTS\");\n        // TODO TRY : 1800,2100,2400,2700,3000,3300,3600, 3600, 3600, 3600,4000,4400,4800,5400,6200,7200 ?\n\n        // 1800,2100,2400,2700,3000,3300,3600, 3600, 3600, 3600,4200,5400,6600,7800,9000,12000\n        // 0x0708083409600a8c0bb80ce40e100e100e100e101068151819c81e7823282ee0\n        return data.normal16(12, 0x0708083409600a8c0bb80ce40e100e100e100e101068151819c81e7823282ee0); // per hour\n    }\n\n    function _attack(bytes32 data) internal pure returns (uint16) {\n        require(_exists(data), \"PLANET_NOT_EXISTS\");\n        return 4000 + data.normal8(20) * 400; // 4,000 - 7,000 - 10,000\n    }\n\n    function _defense(bytes32 data) internal pure returns (uint16) {\n        require(_exists(data), \"PLANET_NOT_EXISTS\");\n        return 4000 + data.normal8(28) * 400; // 4,000 - 7,000 - 10,000\n    }\n\n    function _speed(bytes32 data) internal pure returns (uint16) {\n        require(_exists(data), \"PLANET_NOT_EXISTS\");\n        return 5005 + data.normal8(36) * 333; // 5,005 - 7,502.5 - 10,000\n    }\n\n    function _natives(bytes32 data) internal pure returns (uint16) {\n        require(_exists(data), \"PLANET_NOT_EXISTS\");\n        return 15000 + data.normal8(44) * 3000; // 15,000 - 37,500 - 60,000\n    }\n\n    function _exists(bytes32 data) internal pure returns (bool) {\n        return data.value8Mod(52, 16) == 1; // 16 => 36 so : 1 planet per 6 (=24 min unit) square\n        // also:\n        // 20000 average starting numSpaceships (or max?)\n        // speed of min unit = 30 min ( 1 hour per square)\n        // production : 20000 per 6 hours\n        // exit : 3 days ? => 72 distance\n    }\n\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // GETTERS\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n    function _getPlanet(uint256 location) internal view returns (Planet storage) {\n        return _planets[location];\n    }\n\n    function _getPlanetStats(uint256 location) internal view returns (PlanetStats memory) {\n        bytes32 data = _planetData(location);\n        require(_exists(data), \"no planet in this location\");\n\n        (int8 subX, int8 subY) = _subLocation(data);\n        return\n            PlanetStats({\n                subX: subX,\n                subY: subY,\n                stake: _stake(data),\n                production: _production(data),\n                attack: _attack(data),\n                defense: _defense(data),\n                speed: _speed(data),\n                natives: _natives(data)\n            });\n    }\n\n    function _getCurrentNumSpaceships(\n        uint32 numSpaceshipsData,\n        uint256 lastUpdated,\n        uint16 production\n    ) internal view returns (bool active, uint32 currentNumSpaceships) {\n        (active, currentNumSpaceships) = _activeNumSpaceships(numSpaceshipsData);\n\n        uint256 maxIncrease = ACTIVE_MASK -1;\n        uint256 timePassed = block.timestamp - lastUpdated;\n        uint256 newSpaceships = currentNumSpaceships;\n        if (_productionCapAsDuration > 0) {\n            uint256 decrease = 0;\n            uint256 cap = _acquireNumSpaceships + _productionCapAsDuration * uint256(production) / 1 hours;\n            if (currentNumSpaceships > cap) {\n                decrease = timePassed * 1800 / 3600; // 1800 per hours\n                if (decrease > currentNumSpaceships - cap) {\n                    decrease = currentNumSpaceships - cap;\n                }\n                maxIncrease = 0;\n            } else {\n                maxIncrease = cap - currentNumSpaceships;\n            }\n\n            if (active) {\n                uint256 increase = (timePassed * uint256(production) * _productionSpeedUp) / 1 hours;\n                if (increase > maxIncrease) {\n                    increase = maxIncrease;\n                }\n                newSpaceships += increase;\n            }\n\n            if (decrease > newSpaceships) {\n                newSpaceships = 0; // not possible\n            } else {\n                newSpaceships -= decrease;\n            }\n        } else if (active) {\n            newSpaceships += (timePassed * uint256(production) * _productionSpeedUp) / 1 hours;\n        }\n\n        if (newSpaceships >= ACTIVE_MASK) {\n            newSpaceships = ACTIVE_MASK - 1;\n        }\n        currentNumSpaceships = uint32(newSpaceships);\n\n    }\n\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // UTILS\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n    function _activeNumSpaceships(uint32 numSpaceshipsData) internal pure returns (bool active, uint32 numSpaceships) {\n        active = (numSpaceshipsData & ACTIVE_MASK) == ACTIVE_MASK;\n        numSpaceships = numSpaceshipsData % (ACTIVE_MASK);\n    }\n\n    function _setActiveNumSpaceships(bool active, uint32 numSpaceships) internal pure returns (uint32) {\n        return uint32((active ? ACTIVE_MASK : 0) + numSpaceships);\n    }\n\n    function _msgSender() internal view returns (address) {\n        return msg.sender; // TODO metatx\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "src/Libraries/Extraction.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\n\npragma solidity 0.8.9;\n\n// TODO remove\nimport \"hardhat/console.sol\";\n\nlibrary Extraction {\n    function value(\n        bytes32 data,\n        uint8 leastSignificantBit,\n        uint8 size\n    ) internal pure returns (uint256) {\n        return uint256((data >> leastSignificantBit)) % 2**size;\n    }\n\n    function value8Mod(\n        bytes32 data,\n        uint8 leastSignificantBit,\n        uint8 mod\n    ) internal pure returns (uint8) {\n        return uint8(uint256((data >> leastSignificantBit)) % mod);\n    }\n\n    function value8(bytes32 data, uint8 leastSignificantBit) internal pure returns (uint8) {\n        return uint8(uint256((data >> leastSignificantBit)) % 2**8);\n    }\n\n    // 1+1+2+3+4+6+7+8+8+7+6+4+3+2+1+1 // aproximation of normal distribution with mean=7.5 and standard deviation=3 for 16 values\n    bytes32 constant n_m7_5_sd3 = 0x01223334444555555666666677777777888888889999999AAAAAABBBBCCCDDEF;\n\n    function normal8(bytes32 data, uint8 leastSignificantBit) internal pure returns (uint8) {\n        uint8 index = value8Mod(data, leastSignificantBit, 64);\n        uint8 first = index / 2;\n        uint8 second = index % 2;\n        uint8 slot = uint8(n_m7_5_sd3[first]);\n        if (second == 0) {\n            return slot >> 4;\n        } else {\n            return slot % 16;\n        }\n    }\n\n    function normal16(\n        bytes32 data,\n        uint8 leastSignificantBit,\n        bytes32 selection\n    ) internal pure returns (uint16) {\n        uint8 index = normal8(data, leastSignificantBit);\n        return uint16(uint8(selection[index * 2])) * 2**8 + uint16(uint8(selection[index * 2 + 1]));\n    }\n}\n"
    },
    "src/Libraries/Math.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\n\npragma solidity 0.8.9;\n\nlibrary Math {\n    function mul(\n        uint256 a,\n        uint256 b,\n        string memory overflowError\n    ) internal pure returns (uint256 c) {\n        require(b == 0 || a == 0 || ((c = a * b) / b) == a, overflowError);\n    }\n\n    function add(\n        uint256 a,\n        uint256 b,\n        string memory overflowError\n    ) internal pure returns (uint256 c) {\n        require((c = a + b) >= a, overflowError);\n    }\n\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory underflowError\n    ) internal pure returns (uint256 c) {\n        require((c = a - b) <= a, underflowError);\n    }\n\n    function mul18(\n        uint256 a18,\n        uint256 b18,\n        string memory overflowError\n    ) internal pure returns (uint256) {\n        return mul(a18, b18, overflowError) / 10**18;\n    }\n\n    function div18(\n        uint256 a18,\n        uint256 b18,\n        string memory overflowError\n    ) internal pure returns (uint256) {\n        return mul(a18, 10**18, overflowError) / b18;\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a <= b ? a : b;\n    }\n\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    function smin(int256 a, int256 b) internal pure returns (int256) {\n        return a <= b ? a : b;\n    }\n\n    function smax(int256 a, int256 b) internal pure returns (int256) {\n        return a >= b ? a : b;\n    }\n\n    function sqrt(uint256 a) internal pure returns (uint256 c) {\n        uint256 tmp = (a + 1) / 2;\n        c = a;\n        while (tmp < c) {\n            c = tmp;\n            tmp = ((a / tmp) + tmp) / 2;\n        }\n    }\n}\n"
    },
    "hardhat-deploy/solc_0.8/proxy/Proxied.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract Proxied {\n    /// @notice to be used by initialisation / postUpgrade function so that only the proxy's admin can execute them\n    /// It also allows these functions to be called inside a contructor\n    /// even if the contract is meant to be used without proxy\n    modifier proxied() {\n        address proxyAdminAddress = _proxyAdmin();\n        // With hardhat-deploy proxies\n        // the proxyAdminAddress is zero only for the implementation contract\n        // if the implementation contract want to be used as a standalone/immutable contract\n        // it simply has to execute the `proxied` function\n        // This ensure the proxyAdminAddress is never zero post deployment\n        // And allow you to keep the same code for both proxied contract and immutable contract\n        if (proxyAdminAddress == address(0)) {\n            // ensure can not be called twice when used outside of proxy : no admin\n            // solhint-disable-next-line security/no-inline-assembly\n            assembly {\n                sstore(\n                    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103,\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n                )\n            }\n        } else {\n            require(msg.sender == proxyAdminAddress);\n        }\n        _;\n    }\n\n    modifier onlyProxyAdmin() {\n        require(msg.sender == _proxyAdmin(), \"NOT_AUTHORIZED\");\n        _;\n    }\n\n    function _proxyAdmin() internal view returns (address ownerAddress) {\n        // solhint-disable-next-line security/no-inline-assembly\n        assembly {\n            ownerAddress := sload(0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103)\n        }\n    }\n}\n"
    },
    "src/Interfaces/IAlliance.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\n\npragma solidity 0.8.9;\n\ninterface IAlliance {\n    function requestToJoin(address player, bytes calldata data) external returns (bool);\n\n    function playerHasLeft(address player) external;\n}\n\n"
    },
    "src/AllianceRegistry.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\n\npragma solidity 0.8.9;\n\nimport \"hardhat-deploy/solc_0.8/proxy/Proxied.sol\";\nimport \"./Interfaces/IAlliance.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\n// import \"hardhat/console.sol\";\n\ncontract AllianceRegistry is Proxied {\n     using ECDSA for bytes32;\n\n\n    uint8 internal constant MAX_NUM_ALLIANCES = 4;\n\n    mapping(address => mapping(IAlliance => uint256)) internal _allianceNonces;\n    struct AllianceRow {\n        IAlliance alliance;\n        uint96 joinTime;\n    }\n    struct Alliances {\n        AllianceRow alliance0;\n        AllianceRow alliance1;\n        AllianceRow alliance2;\n        AllianceRow alliance3;\n    }\n    mapping(address => Alliances) internal _alliances;\n\n\n    event AllianceLink(IAlliance indexed alliance, address indexed player, bool joining);\n\n\n    function getAllianceDataAtSlot(address player, uint8 slot) external view returns (IAlliance alliance, uint96 joinTime, uint256 nonce) {\n\n        Alliances storage alliances = _alliances[player];\n        if (slot == 0) {\n            alliance = alliances.alliance0.alliance;\n            joinTime = alliances.alliance0.joinTime;\n        } else if (slot == 1) {\n            alliance = alliances.alliance1.alliance;\n            joinTime = alliances.alliance1.joinTime;\n        } else if (slot == 2) {\n            alliance = alliances.alliance2.alliance;\n            joinTime = alliances.alliance2.joinTime;\n        } else if (slot == 3) {\n            alliance = alliances.alliance3.alliance;\n            joinTime = alliances.alliance3.joinTime;\n        }\n\n        nonce = _allianceNonces[player][alliance];\n    }\n\n    function getAllianceData(address player, IAlliance alliance) external view returns (uint96 joinTime, uint256 nonce) {\n        nonce = _allianceNonces[player][alliance];\n\n        Alliances storage alliances = _alliances[player];\n        if (alliances.alliance0.alliance == alliance) {\n            joinTime = alliances.alliance0.joinTime;\n        } else if (alliances.alliance1.alliance == alliance) {\n            joinTime = alliances.alliance1.joinTime;\n        } else if (alliances.alliance2.alliance == alliance) {\n            joinTime = alliances.alliance2.joinTime;\n        } else if (alliances.alliance3.alliance == alliance) {\n            joinTime = alliances.alliance3.joinTime;\n        }\n    }\n\n    function havePlayersAnAllianceInCommon(address player1, address player2, uint256 timestamp) external view returns (IAlliance alliance, uint96 joinTime) {\n        Alliances storage p1Alliances = _alliances[player1];\n        Alliances storage p2Alliances = _alliances[player2];\n\n        AllianceRow[4] memory player1Alliances;\n        AllianceRow[4] memory player2Alliances;\n        uint256 num1 = 0;\n        uint256 num2 = 0;\n\n        for (uint256 i = 0; i < 4; i++) {\n            if (i == num1) {\n                AllianceRow memory allianceRow;\n                if (i == 0) {\n                    allianceRow = p1Alliances.alliance0;\n                } else if(i==1) {\n                    allianceRow = p1Alliances.alliance1;\n                } else if(i==2) {\n                    allianceRow = p1Alliances.alliance2;\n                } else if(i==3) {\n                    allianceRow = p1Alliances.alliance3;\n                }\n                if (address(allianceRow.alliance) == address(0)) {\n                    // console.log(\"p1 exhausted\");\n                    return (alliance, joinTime); // the alliance leave ensure that there is no gap // TODO\n                }\n                player1Alliances[num1 ++] = allianceRow;\n            }\n            for (uint256 j = 0; j < 4; j++) {\n                if (j == num2) {\n                    AllianceRow memory allianceRow;\n                    if (j == 0) {\n                        allianceRow = p2Alliances.alliance0;\n                    } else if(j==1) {\n                        allianceRow = p2Alliances.alliance1;\n                    } else if(j==2) {\n                        allianceRow = p2Alliances.alliance2;\n                    } else if(j==3) {\n                        allianceRow = p2Alliances.alliance3;\n                    }\n                    if (address(allianceRow.alliance) == address(0)) {\n                        // console.log(\"p2 exhausted\");\n                        // return (alliance, joinTime); // the alliance leave ensure that there is no gap // TODO\n                        break;\n                    }\n                    player2Alliances[num2 ++] = allianceRow;\n                }\n\n                if (player1Alliances[i].alliance == player2Alliances[j].alliance) {\n                    if (player1Alliances[i].joinTime >= player2Alliances[j].joinTime) {\n                        if (player1Alliances[i].joinTime < timestamp) {\n                            return (player1Alliances[i].alliance, player1Alliances[i].joinTime);\n                        } else {\n                            // TODO check greater ?\n                            alliance = player1Alliances[i].alliance;\n                            joinTime = player1Alliances[i].joinTime;\n                        }\n                    } else {\n                        if (player2Alliances[j].joinTime < timestamp) {\n                            return (player2Alliances[j].alliance, player2Alliances[j].joinTime);\n                        } else {\n                            // TODO check greater ?\n                            alliance = player2Alliances[j].alliance;\n                            joinTime = player2Alliances[j].joinTime;\n                        }\n                    }\n                }\n            }\n        }\n        // console.log(address(alliance));\n        // console.log(joinTime);\n    }\n\n    // -----------------------------------------------------------------------------------------------------\n    // FROM PLAYER\n    // -----------------------------------------------------------------------------------------------------\n\n    function joinAlliance(IAlliance alliance, bytes calldata data) external returns (bool joined) {\n        Alliances storage alliances = _alliances[msg.sender];\n        uint256 slot = 0;\n        if (address(alliances.alliance0.alliance) != address(0)) {\n            slot ++;\n        }\n        if (address(alliances.alliance1.alliance) != address(0)) {\n            slot ++;\n        }\n        if (address(alliances.alliance2.alliance) != address(0)) {\n            slot ++;\n        }\n        require(address(alliances.alliance3.alliance) == address(0), \"MAX_NUM_ALLIANCES_REACHED\");\n\n        joined = alliance.requestToJoin(msg.sender, data);\n        if (joined) {\n            if (slot == 0) {\n                alliances.alliance0.alliance = alliance;\n                alliances.alliance0.joinTime = uint96(block.timestamp);\n            } else if (slot == 1) {\n                alliances.alliance1.alliance = alliance;\n                alliances.alliance1.joinTime = uint96(block.timestamp);\n            } else if (slot == 2) {\n                alliances.alliance2.alliance = alliance;\n                alliances.alliance2.joinTime = uint96(block.timestamp);\n            } else if (slot == 3) {\n                alliances.alliance3.alliance = alliance;\n                alliances.alliance3.joinTime = uint96(block.timestamp);\n            }\n\n            emit AllianceLink(alliance, msg.sender, true);\n        }\n    }\n\n    function leaveAlliance(IAlliance alliance) external {\n        _leaveAlliance(msg.sender, alliance);\n        try alliance.playerHasLeft(msg.sender) {} catch {}\n        // TODO ensure callback not failed due to low gas (1/64 rule)\n    }\n\n\n    // -----------------------------------------------------------------------------------------------------\n    // FROM ALLIANCE\n    // -----------------------------------------------------------------------------------------------------\n\n    function addPlayerToAlliance(address player, uint32 nonce, bytes calldata signature) external {\n        _addPlayerToAlliance(player, nonce, signature);\n    }\n\n    struct PlayerSubmission {\n        address addr;\n        uint32 nonce;\n        bytes signature;\n    }\n\n\n    function addMultiplePlayersToAlliance(PlayerSubmission[] calldata playerSubmissions) external {\n       for(uint256 i = 0 ; i < playerSubmissions.length; i++) {\n           _addPlayerToAlliance(playerSubmissions[i].addr, playerSubmissions[i].nonce, playerSubmissions[i].signature);\n       }\n    }\n\n    function ejectPlayerFromAlliance(address player) external {\n        _leaveAlliance(player, IAlliance(msg.sender));\n    }\n\n\n    // -----------------------------------------------------------------------------------------------------\n    // INTERNAL\n    // -----------------------------------------------------------------------------------------------------\n\n    function _addPlayerToAlliance(address player, uint32 nonce, bytes calldata signature) internal {\n        IAlliance alliance = IAlliance(msg.sender);\n\n        Alliances storage alliances = _alliances[player];\n        uint256 slot = 0;\n        if (address(alliances.alliance0.alliance) != address(0)) {\n            require(alliances.alliance0.alliance != alliance, \"ALREADY_JOINED\");\n            slot ++;\n        }\n        if (address(alliances.alliance1.alliance) != address(0)) {\n            require(alliances.alliance1.alliance != alliance, \"ALREADY_JOINED\");\n            slot ++;\n        }\n        if (address(alliances.alliance2.alliance) != address(0)) {\n            require(alliances.alliance2.alliance != alliance, \"ALREADY_JOINED\");\n            slot ++;\n        }\n        require(alliances.alliance3.alliance != alliance, \"ALREADY_JOINED\");\n        require(address(alliances.alliance3.alliance) == address(0), \"MAX_NUM_ALLIANCES_REACHED\");\n\n\n        uint256 currentNonce = _allianceNonces[player][alliance];\n        require(currentNonce == nonce, \"INVALID_NONCE\");\n\n        bytes memory message;\n        if (nonce == 0) {\n            message = abi.encodePacked(\"\\x19Ethereum Signed Message:\\n56\", \"Join Alliance 0x0000000000000000000000000000000000000000\");\n            _writeUintAsHex(message, 28 + 55, uint160(msg.sender));\n        } else {\n            message = abi.encodePacked(\"\\x19Ethereum Signed Message:\\n76\", \"Join Alliance 0x0000000000000000000000000000000000000000 (nonce:          0)\");\n            _writeUintAsHex(message, 28 + 55, uint160(msg.sender));\n            _writeUintAsDecimal(message, 28 + 74, nonce);\n        }\n\n\n        // console.log(string(message));\n\n        bytes32 digest = keccak256(message);\n\n        address signer = digest.recover(signature);\n        require(player == signer, \"INVALID_SIGNATURE\");\n\n        if (slot == 0) {\n            alliances.alliance0.alliance = alliance;\n            alliances.alliance0.joinTime = uint96(block.timestamp);\n        } else if (slot == 1) {\n            alliances.alliance1.alliance = alliance;\n            alliances.alliance1.joinTime = uint96(block.timestamp);\n        } else if (slot == 2) {\n            alliances.alliance2.alliance = alliance;\n            alliances.alliance2.joinTime = uint96(block.timestamp);\n        } else if (slot == 3) {\n            alliances.alliance3.alliance = alliance;\n            alliances.alliance3.joinTime = uint96(block.timestamp);\n        }\n        _allianceNonces[player][alliance] = nonce + 1;\n\n        emit AllianceLink(alliance, player, true);\n    }\n\n    bytes internal constant hexAlphabet = \"0123456789abcdef\";\n    bytes internal constant decimalAlphabet = \"0123456789\";\n    function _writeUintAsHex(\n        bytes memory data,\n        uint256 endPos,\n        uint256 num\n    ) internal pure {\n        while (num != 0) {\n            data[endPos--] = bytes1(hexAlphabet[num % 16]);\n            num /= 16;\n        }\n    }\n    function _writeUintAsDecimal(\n        bytes memory data,\n        uint256 endPos,\n        uint256 num\n    ) internal pure {\n        while (num != 0) {\n            data[endPos--] = bytes1(decimalAlphabet[num % 10]);\n            num /= 10;\n        }\n    }\n\n    function _leaveAlliance(address player, IAlliance alliance) internal {\n\n        Alliances storage alliances = _alliances[msg.sender];\n\n        IAlliance lastSlotAlliance;\n        uint96 lastSlotJoinTime;\n\n\n        require(address(alliances.alliance0.alliance) != address(0), \"NOT_PART_OF_ANY_ALLIANCE\");\n\n        if (address(alliances.alliance1.alliance) == address(0)) {\n            lastSlotAlliance = alliances.alliance0.alliance;\n            lastSlotJoinTime = alliances.alliance0.joinTime;\n            alliances.alliance0.alliance = IAlliance(address(0));\n            alliances.alliance0.joinTime = 0;\n        } else {\n            if (address(alliances.alliance2.alliance) == address(0)) {\n                lastSlotAlliance = alliances.alliance1.alliance;\n                lastSlotJoinTime = alliances.alliance1.joinTime;\n                alliances.alliance1.alliance = IAlliance(address(0));\n                alliances.alliance1.joinTime = 0;\n            } else {\n                if (address(alliances.alliance3.alliance) == address(0)) {\n                    lastSlotAlliance = alliances.alliance2.alliance;\n                    lastSlotJoinTime = alliances.alliance2.joinTime;\n                    alliances.alliance2.alliance = IAlliance(address(0));\n                    alliances.alliance2.joinTime = 0;\n                } else {\n                    lastSlotAlliance = alliances.alliance3.alliance;\n                    lastSlotJoinTime = alliances.alliance3.joinTime;\n                    alliances.alliance3.alliance = IAlliance(address(0));\n                    alliances.alliance3.joinTime = 0;\n                }\n            }\n        }\n\n\n        if (alliance != lastSlotAlliance) {\n            if (alliances.alliance0.alliance == alliance) {\n                alliances.alliance0.alliance = lastSlotAlliance;\n                alliances.alliance0.joinTime = lastSlotJoinTime;\n            } else if (alliances.alliance1.alliance == alliance) {\n                alliances.alliance1.alliance =lastSlotAlliance;\n                alliances.alliance1.joinTime = lastSlotJoinTime;\n            } else if (alliances.alliance2.alliance == alliance) {\n                alliances.alliance2.alliance =lastSlotAlliance;\n                alliances.alliance2.joinTime = lastSlotJoinTime;\n            } else {\n                revert(\"NOT_PART_OF_THE_ALLIANCE\");\n            }\n        }\n\n\n        emit AllianceLink(alliance, player, false);\n    }\n\n\n\n    function _msgSender() internal view returns (address) {\n        return msg.sender; // TODO metatx\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "src/Alliances/BasicAlliance.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\npragma solidity 0.8.9;\n\nimport \"../AllianceRegistry.sol\";\n// import \"../Interfaces/IAlliance.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n\ncontract BasicAlliance {\n\n    bool internal _original;\n    AllianceRegistry internal immutable _allianceRegistry;\n    address public admin;\n\n\n    // constructor(AllianceRegistry allianceRegistry, AllianceRegistry.PlayerSubmission[] memory playerSubmissions) {\n    //     _allianceRegistry = allianceRegistry;\n    //     _allianceRegistry.addMultiplePlayersToAlliance(playerSubmissions);\n    // }\n\n    constructor(AllianceRegistry allianceRegistry) {\n        _allianceRegistry = allianceRegistry;\n        _original = true;\n        admin = address(1); // lock it\n    }\n\n    function setAdminAndAddMembers(address newAdmin, AllianceRegistry.PlayerSubmission[] calldata playerSubmissions) public {\n        address currentAdmin = admin;\n        require(currentAdmin == address(0) || msg.sender == currentAdmin, \"NOT_ALLOWED\");\n        admin = newAdmin;\n        if (playerSubmissions.length > 0) {\n            _allianceRegistry.addMultiplePlayersToAlliance(playerSubmissions);\n        }\n    }\n\n    function addMembers(AllianceRegistry.PlayerSubmission[] calldata playerSubmissions) external {\n        require(msg.sender == admin, \"NOT_ALLOWED\");\n        _allianceRegistry.addMultiplePlayersToAlliance(playerSubmissions);\n    }\n\n    function instantiate(address initialAdmin, AllianceRegistry.PlayerSubmission[] calldata playerSubmissions, bytes32 salt) external {\n        require(_original, \"CANNOT_INSTANTIATE_FROM_CLONES\");\n        address newAlliance = Clones.cloneDeterministic(address(this), keccak256(abi.encodePacked(salt, msg.sender)));\n        BasicAlliance(newAlliance).setAdminAndAddMembers(initialAdmin, playerSubmissions);\n    }\n\n    function getAddress(bytes32 salt) external view returns(address) {\n        require(_original, \"CANNOT_INSTANTIATE_FROM_CLONES\");\n        return Clones.predictDeterministicAddress(address(this), keccak256(abi.encodePacked(salt, msg.sender)), address(this));\n    }\n\n\n    // function requestToJoin(address player, bytes calldata data) external view returns (bool) {\n    //     if (player == _initialMember) {\n    //         return true;\n    //     } else {\n    //         bytes32 digest = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", \"Add \", ));\n    //         address signer = digest.recover(signature);\n    //         require(_outerspace.allianceJoinTime(signer, this), \"ONLY_ALLIANCE_MEMBER_CAN_INVITE\");\n    //     }\n    // }\n\n    // function playerHasLeft(address player) external {\n\n    // }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "src/PlayToken/Play.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../Interfaces/ITokenManager.sol\";\nimport \"./Base.sol\";\nimport \"./WithPermitAndFixedDomain.sol\";\nimport \"./CompoundAdapter.sol\";\nimport \"hardhat-deploy/solc_0.8/proxy/Proxied.sol\";\n\ncontract Play is Base, WithPermitAndFixedDomain, CompoundAdapter, Proxied {\n    using Address for address;\n\n    address internal _owner; // TODO ownership as extension\n\n    constructor(\n        IERC20 underlyingToken,\n        ICompoundERC20 cToken,\n        address owner\n    ) WithPermitAndFixedDomain(\"1\") CompoundAdapter(underlyingToken, cToken) {\n        postUpgrade(underlyingToken, cToken, owner);\n    }\n\n    function postUpgrade(\n        IERC20,\n        ICompoundERC20,\n        address owner\n    ) public {\n        // 2 first arguments used as immutable in CompoundAdapter\n        _owner = owner;\n    }\n\n    string public constant symbol = \"ETHERPLAY\";\n\n    function name() public pure override returns (string memory) {\n        return \"Etherplay\";\n    }\n\n    // function mintApproveAndCall(\n    //     uint256 amount,\n    //     address target,\n    //     bytes calldata data\n    // ) external {\n    //     // TODO support metatx ?\n    //     // TODO support permit or transfer gateways\n    //     // support ERC20 permit as appended calldata\n    //     address sender = msg.sender;\n    //     _wrappedToken.transferFrom(sender, address(this), amount);\n    //     _mint(address(this), amount);\n    //     if (_allowances[address(this)][target] < amount) {\n    //         // this is the only function that will let address(this) owns some token\n    //         // and it ensure it never keep it\n    //         // as such we can approve it all\n    //         _approveFor(address(this), target, UINT256_MAX);\n    //     }\n    //     target.functionCall(data);\n    //     _transferAllIfAny(address(this), sender);\n    //     // _approveFor(address(this), target, 0); // not necessary\n    // }\n\n    function mintAndApprovedCall(\n        uint256 maxAmount,\n        address target,\n        bytes calldata data\n    ) external {\n        // TODO support metatx ?\n        // TODO support permit or transfer gateways\n        // support ERC20 permit as appended calldata\n        address sender = msg.sender;\n        uint256 actualAmount = _use(maxAmount, sender);\n        _mint(sender, actualAmount);\n        target.functionCall(data); // target can only assume the sender is the contract and will thus refund it if any\n        _transferAllIfAny(address(this), sender);\n    }\n\n    function mintAndCall(\n        uint256 maxAmount,\n        address target,\n        bool requireFullAmount,\n        bytes calldata data\n    ) external returns (uint256) {\n        // TODO support metatx ?\n        // TODO support permit or transfer gateways\n        // support ERC20 permit as appended calldata\n        address sender = msg.sender;\n        uint256 actualAmount = _use(maxAmount, sender);\n        if (requireFullAmount) {\n            require(actualAmount == maxAmount, \"COULD_NOT_MINT_REQUESTED_AMOUNT\");\n        }\n        _mint(sender, actualAmount);\n        ITransferReceiver(target).onTokenTransfer(sender, actualAmount, data);\n        // in this case the target will know the original sender and so refund will go to sender, no need to transfer any bacl afterward\n        // but in case :\n        _transferAllIfAny(address(this), sender);\n        return actualAmount;\n    }\n\n    function mint(uint256 maxAmount) external returns (uint256) {\n        // TODO support permit or transfer gateways\n        // support ERC20 permit as appended calldata\n        address sender = msg.sender;\n        uint256 actualAmount = _use(maxAmount, sender);\n        _mint(sender, actualAmount);\n        return actualAmount;\n    }\n\n    function burn(uint256 maxAmount) external returns (uint256) {\n        address sender = msg.sender;\n        uint256 amountBurnt = _takeBack(maxAmount, sender);\n        _burnFrom(sender, amountBurnt);\n        return amountBurnt;\n    }\n\n    function burnTo(uint256 maxAmount, address to) external returns (uint256) {\n        address sender = msg.sender;\n        uint256 amountBurnt = _takeBack(maxAmount, to);\n        _burnFrom(sender, amountBurnt);\n        return amountBurnt;\n    }\n\n    function burnToAndCall(\n        uint256 maxAmount,\n        address target,\n        bool requireFullAmount,\n        bytes calldata data\n    ) external returns (uint256) {\n        address sender = msg.sender;\n        uint256 amountBurnt = _takeBack(maxAmount, target);\n        if (requireFullAmount) {\n            require(amountBurnt == maxAmount, \"COULD_NOT_BURN_REQUESTED_AMOUNT\");\n        }\n        _burnFrom(sender, amountBurnt);\n        IBurnReceiver(target).onTokenBurn(sender, amountBurnt, data);\n        return amountBurnt;\n    }\n\n    function withdraw(uint256 maxAmount, address to) external returns (uint256) {\n        require(msg.sender == _owner, \"NOT_AUTHORIZED\");\n        return _withdrawInterest(maxAmount, to);\n    }\n\n    // can be used to render user full in case of lack of underlying token\n    // this does not create token in return\n    function depositWithoutReturn(uint256 maxAmount) external returns (uint256) {\n        address sender = msg.sender;\n        return _use(maxAmount, sender);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "src/Interfaces/ITokenManager.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\n\npragma solidity 0.8.9;\n\ninterface ITokenManager {\n    function takeBack(uint256 amount) external;\n}\n"
    },
    "src/PlayToken/Base.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"./BaseInternal.sol\";\nimport \"../Libraries/Constants.sol\";\n\ninterface IBurnReceiver {\n    function onTokenBurn(\n        address,\n        uint256,\n        bytes calldata\n    ) external returns (bool);\n}\n\ninterface ITransferReceiver {\n    function onTokenTransfer(\n        address,\n        uint256,\n        bytes calldata\n    ) external returns (bool);\n}\n\ninterface IPaidForReceiver {\n    function onTokenPaidFor(\n        address payer,\n        address forAddress,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n}\n\ninterface IApprovalReceiver {\n    function onTokenApproval(\n        address,\n        uint256,\n        bytes calldata\n    ) external returns (bool);\n}\n\nabstract contract Base is IERC20, BaseInternal {\n    using Address for address;\n\n    uint256 internal _totalSupply;\n    mapping(address => uint256) internal _balances;\n    mapping(address => mapping(address => uint256)) internal _allowances;\n\n    function _internal_totalSupply() internal view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function totalSupply() external view override returns (uint256) {\n        return _internal_totalSupply();\n    }\n\n    function balanceOf(address owner) external view override returns (uint256) {\n        return _balances[owner];\n    }\n\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        if (owner == address(this)) {\n            // see transferFrom: address(this) allows anyone\n            return Constants.UINT256_MAX;\n        }\n        return _allowances[owner][spender];\n    }\n\n    function decimals() external pure virtual returns (uint8) {\n        return uint8(18);\n    }\n\n    function transfer(address to, uint256 amount) external override returns (bool) {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function transferAlongWithETH(address payable to, uint256 amount) external payable returns (bool) {\n        _transfer(msg.sender, to, amount);\n        to.transfer(msg.value);\n        return true;\n    }\n\n    function distributeAlongWithETH(address payable[] calldata tos, uint256 totalAmount)\n        external\n        payable\n        returns (bool)\n    {\n        uint256 val = msg.value / tos.length;\n        require(msg.value == val * tos.length, \"INVALID_MSG_VALUE\");\n        uint256 amount = totalAmount / tos.length;\n        require(totalAmount == amount * tos.length, \"INVALID_TOTAL_AMOUNT\");\n        for (uint256 i = 0; i < tos.length; i++) {\n            _transfer(msg.sender, tos[i], amount);\n            tos[i].transfer(val);\n        }\n        return true;\n    }\n\n    function distributeVariousAmountsAlongWithETH(address payable[] calldata tos, uint256[] calldata amounts)\n        external\n        payable\n        returns (bool)\n    {\n        uint256 val = msg.value / tos.length;\n        require(msg.value == val * tos.length, \"INVALID_MSG_VALUE\");\n        require(tos.length == amounts.length, \"NOT_SAME_LENGTH\");\n        for (uint256 i = 0; i < tos.length; i++) {\n            _transfer(msg.sender, tos[i], amounts[i]);\n            tos[i].transfer(val);\n        }\n        return true;\n    }\n\n    function transferAndCall(\n        address to,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool) {\n        _transfer(msg.sender, to, amount);\n        return ITransferReceiver(to).onTokenTransfer(msg.sender, amount, data);\n    }\n\n    function transferFromAndCall(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool) {\n        _transferFrom(from, to, amount);\n        return ITransferReceiver(to).onTokenTransfer(from, amount, data);\n    }\n\n    function payForAndCall(\n        address forAddress,\n        address to,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool) {\n        _transfer(msg.sender, to, amount);\n        return IPaidForReceiver(to).onTokenPaidFor(msg.sender, forAddress, amount, data);\n    }\n\n    // TODO ?\n    // function transferFromForAndCall(\n    //     address forAddress,\n    //     address from,\n    //     address to,\n    //     uint256 amount,\n    //     bytes calldata data\n    // ) external returns (bool) {\n    //     _transferFrom(from, to, amount);\n    //     return ITransferForReceiver(to).onTokenTransferFor(from, forAddress, amount, data);\n    // }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external override returns (bool) {\n        _transferFrom(from, to, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        // TODO support metatx ?\n        _approveFor(msg.sender, spender, amount);\n        return true;\n    }\n\n    function approveAndCall(\n        address spender,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool) {\n        _approveFor(msg.sender, spender, amount);\n        return IApprovalReceiver(spender).onTokenApproval(msg.sender, amount, data);\n    }\n\n    function _approveFor(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal override {\n        require(owner != address(0) && spender != address(0), \"INVALID_ZERO_ADDRESS\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        // anybody can transfer from this\n        // this allow mintAndApprovedCall without gas overhead\n        if (msg.sender != from && from != address(this)) {\n            uint256 currentAllowance = _allowances[from][msg.sender];\n            if (currentAllowance != Constants.UINT256_MAX) {\n                // save gas when allowance is maximal by not reducing it (see https://github.com/ethereum/EIPs/issues/717)\n                require(currentAllowance >= amount, \"NOT_AUTHOIZED_ALLOWANCE\");\n                _allowances[from][msg.sender] = currentAllowance - amount;\n            }\n        }\n        _transfer(from, to, amount);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(to != address(0), \"INVALID_ZERO_ADDRESS\");\n        require(to != address(this), \"INVALID_THIS_ADDRESS\");\n        uint256 currentBalance = _balances[from];\n        require(currentBalance >= amount, \"NOT_ENOUGH_TOKENS\");\n        _balances[from] = currentBalance - amount;\n        _balances[to] += amount;\n        emit Transfer(from, to, amount);\n    }\n\n    function _transferAllIfAny(address from, address to) internal {\n        uint256 balanceLeft = _balances[from];\n        if (balanceLeft > 0) {\n            _balances[from] = 0;\n            _balances[to] += balanceLeft;\n            emit Transfer(from, to, balanceLeft);\n        }\n    }\n\n    function _mint(address to, uint256 amount) internal override {\n        _totalSupply += amount;\n        _balances[to] += amount;\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burnFrom(address from, uint256 amount) internal override {\n        uint256 currentBalance = _balances[from];\n        require(currentBalance >= amount, \"NOT_ENOUGH_TOKENS\");\n        _balances[from] = currentBalance - amount;\n        _totalSupply -= amount;\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "src/PlayToken/WithPermitAndFixedDomain.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\npragma solidity 0.8.9;\n\nimport \"./BaseInternal.sol\";\nimport \"../Interfaces/IERC2612Standalone.sol\";\n\nabstract contract WithPermitAndFixedDomain is BaseInternal, IERC2612Standalone {\n    bytes32 internal constant PERMIT_TYPEHASH = keccak256(\n        \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n    );\n\n    bytes32 public immutable override DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) internal _nonces;\n\n    constructor(string memory version) {\n        if (bytes(version).length == 0) {\n            version = \"1\";\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,address verifyingContract)\"),\n                keccak256(bytes(name())),\n                keccak256(bytes(version)),\n                address(this)\n            )\n        );\n    }\n\n    function nonces(address owner) external view override returns (uint256) {\n        return _nonces[owner];\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(owner != address(0), \"INVALID_ZERO_ADDRESS\");\n\n        uint256 currentNonce = _nonces[owner];\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, currentNonce, deadline))\n            )\n        );\n        require(owner == ecrecover(digest, v, r, s), \"INVALID_SIGNATURE\");\n        require(deadline == 0 || block.timestamp <= deadline, \"TOO_LATE\");\n\n        _nonces[owner] = currentNonce + 1;\n        _approveFor(owner, spender, value);\n    }\n}\n"
    },
    "src/PlayToken/CompoundAdapter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../Interfaces/ICompoundERC20.sol\";\nimport \"./BaseInternal.sol\";\nimport \"../Libraries/Constants.sol\";\n\nabstract contract CompoundAdapter is BaseInternal {\n    using SafeERC20 for IERC20;\n\n    ICompoundERC20 immutable _cToken;\n    IERC20 immutable _underlyingToken;\n\n    constructor(IERC20 underlyingToken, ICompoundERC20 cToken) {\n        _underlyingToken = underlyingToken;\n        _cToken = cToken;\n        underlyingToken.approve(address(cToken), Constants.UINT256_MAX);\n    }\n\n    function _use(uint256 maxAmount, address from) internal returns (uint256) {\n        if (from != address(this)) {\n            _underlyingToken.safeTransferFrom(from, address(this), maxAmount);\n        }\n        require(_cToken.mint(maxAmount) == 0, \"ERROR_MINT\");\n        return maxAmount; //TODO check ?\n    }\n\n    function _takeBack(uint256 maxAmount, address to) internal returns (uint256) {\n        require(_cToken.redeemUnderlying(maxAmount) == 0, \"ERROR_REDEEM_UNDERLYING\");\n        _underlyingToken.safeTransfer(to, maxAmount);\n        return maxAmount;\n    }\n\n    function _withdrawInterest(uint256 maxAmount, address to) internal returns (uint256) {\n        uint256 totalUnderlying = _underlyingTokenAvailable();\n        uint256 availableToWithdraw = totalUnderlying - _internal_totalSupply();\n        if (maxAmount > availableToWithdraw) {\n            maxAmount = availableToWithdraw;\n        }\n        require(_cToken.redeemUnderlying(maxAmount) == 0, \"ERROR_REDEEM_UNDERLYING\");\n        _underlyingToken.safeTransfer(to, maxAmount);\n        return maxAmount;\n    }\n\n    function _underlyingTokenAvailable() internal view returns (uint256) {\n        uint256 compoundBalance = _cToken.balanceOf(address(this));\n        uint256 exchangeRateMantissa = _cToken.exchangeRateCurrent();\n        return (compoundBalance * exchangeRateMantissa) / Constants.DECIMALS_18;\n    }\n}\n"
    },
    "src/PlayToken/BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\npragma solidity 0.8.9;\n\nabstract contract BaseInternal {\n    function _approveFor(\n        address owner,\n        address target,\n        uint256 amount\n    ) internal virtual;\n\n    function name() public virtual returns (string memory);\n\n    function _mint(address to, uint256 amount) internal virtual;\n\n    function _burnFrom(address from, uint256 amount) internal virtual;\n\n    function _internal_totalSupply() internal view virtual returns (uint256);\n}\n"
    },
    "src/Libraries/Constants.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\n\npragma solidity 0.8.9;\n\nlibrary Constants {\n    uint256 internal constant UINT256_MAX = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n    uint256 internal constant DECIMALS_18 = 1000000000000000000;\n}\n"
    },
    "src/Interfaces/IERC2612Standalone.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\n\npragma solidity 0.8.9;\n\ninterface IERC2612Standalone {\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function nonces(address owner) external view returns (uint256);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "src/Interfaces/ICompoundERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface ICompoundERC20 is IERC20 {\n    function mint(uint256) external returns (uint256);\n\n    function exchangeRateCurrent() external view returns (uint256);\n\n    function supplyRatePerBlock() external view returns (uint256);\n\n    function redeem(uint256) external returns (uint256);\n\n    function redeemUnderlying(uint256) external returns (uint256);\n}\n"
    },
    "src/Test/TestCompound.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\npragma solidity 0.8.9;\n\nimport \"../Interfaces/ICompoundERC20.sol\";\nimport \"../PlayToken/Base.sol\";\nimport \"../Libraries/Constants.sol\";\n\ncontract TestCompound is Base, ICompoundERC20 {\n    constructor() {}\n\n    function name() public pure override returns (string memory) {\n        return \"CTOKEN\";\n    }\n\n    function mint(uint256) external override returns (uint256) {\n        return 0; // TODO\n    }\n\n    function exchangeRateCurrent() external view override returns (uint256) {\n        return Constants.DECIMALS_18;\n    }\n\n    function supplyRatePerBlock() external view override returns (uint256) {\n        return 0; // TODO\n    }\n\n    function redeem(uint256) external override returns (uint256) {\n        return 0; // TODO\n    }\n\n    function redeemUnderlying(uint256) external override returns (uint256) {\n        return 0; // TODO\n    }\n}\n"
    },
    "src/PlayToken/matic/PlayMaticChildToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../Base.sol\";\nimport \"../WithPermitAndFixedDomain.sol\";\n\ncontract PlayMaticChildToken is Base, WithPermitAndFixedDomain {\n    constructor() WithPermitAndFixedDomain(\"1\") {}\n\n    string public constant symbol = \"M ETHERPLAY\";\n\n    function name() public pure override returns (string memory) {\n        return \"Matic Etherplay\";\n    }\n\n    // TODO Matic specific\n}\n"
    },
    "src/PlayToken/WithPermit.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\npragma solidity 0.8.9;\n\nimport \"./BaseInternal.sol\";\nimport \"../Interfaces/IERC2612Standalone.sol\";\n\nabstract contract WithPermit is BaseInternal, IERC2612Standalone {\n    bytes32 internal constant PERMIT_TYPEHASH = keccak256(\n        \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n    );\n    mapping(address => uint256) internal _nonces;\n\n    function DOMAIN_SEPARATOR() public view virtual override returns (bytes32);\n\n    function nonces(address owner) external view override returns (uint256) {\n        return _nonces[owner];\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(owner != address(0), \"INVALID_ZERO_ADDRESS\");\n\n        uint256 currentNonce = _nonces[owner];\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR(),\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, currentNonce, deadline))\n            )\n        );\n        require(owner == ecrecover(digest, v, r, s), \"INVALID_SIGNATURE\");\n        require(deadline == 0 || block.timestamp <= deadline, \"TOO_LATE\");\n\n        _nonces[owner] = currentNonce + 1;\n        _approveFor(owner, spender, value);\n    }\n}\n"
    },
    "src/PlayToken/YearnVaultV2Adapter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./BaseInternal.sol\";\nimport \"../Libraries/Constants.sol\";\n\ninterface YearnVaultV2 is IERC20 {\n    function deposit(uint256 amount) external returns (uint256);\n\n    function withdraw(uint256 amount, address to) external returns (uint256);\n\n    function totalAssets() external view returns (uint256);\n\n    function pricePerShare() external view returns (uint256);\n}\n\nabstract contract YearnVaultV2Adapter is BaseInternal {\n    using SafeERC20 for IERC20;\n\n    YearnVaultV2 immutable _yvToken;\n    IERC20 immutable _underlyingToken;\n\n    constructor(IERC20 underlyingToken, YearnVaultV2 yvToken) {\n        _underlyingToken = underlyingToken;\n        _yvToken = yvToken;\n        underlyingToken.approve(address(yvToken), Constants.UINT256_MAX);\n    }\n\n    function _use(uint256 maxAmount, address from) internal returns (uint256) {\n        if (from != address(this)) {\n            _underlyingToken.safeTransferFrom(from, address(this), maxAmount);\n        }\n        _yvToken.deposit(maxAmount);\n        return maxAmount;\n    }\n\n    function _takeBack(uint256 maxAmount, address to) internal returns (uint256) {\n        uint256 sharesToWithdraw = _shareForUnderlyingAmount(maxAmount); // TODO\n        return _yvToken.withdraw(sharesToWithdraw, to);\n    }\n\n    function _withdrawInterest(uint256 maxAmount, address to) internal returns (uint256) {\n        uint256 totalUnderlying = _underlyingTokenAvailable();\n        uint256 availableToWithdraw = totalUnderlying - _internal_totalSupply();\n        if (maxAmount > availableToWithdraw) {\n            maxAmount = availableToWithdraw;\n        }\n        uint256 sharesToWithdraw = _shareForUnderlyingAmount(maxAmount); // TODO\n        return _yvToken.withdraw(sharesToWithdraw, to);\n    }\n\n    function _shareForUnderlyingAmount(uint256 underlyingAmount) internal view returns (uint256) {\n        // uint256 totalAssets = _yvToken.totalAssets();\n        // if (totalAssets > 0) {\n        //     return (underlyingAmount * _yvToken.totalSupply()) / totalAssets;\n        // } else {\n        //     return 0;\n        // }\n\n        uint256 valuePerShare = _yvToken.pricePerShare();\n        if (valuePerShare > 0) {\n            return (underlyingAmount * 1000000000000000000) / valuePerShare;\n        }\n        return 0;\n    }\n\n    function _underlyingTokenAvailable() internal view returns (uint256) {\n        return _yvToken.totalAssets();\n    }\n}\n"
    },
    "src/PlayToken/l2/Reserve.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../Play.sol\";\nimport \"ethereum-transfer-gateway/src/solc_0.8/BaseERC20TransferRecipient.sol\";\n\ncontract Reserve is BaseERC20TransferRecipient {\n    using SafeERC20 for IERC20;\n\n    Play internal immutable _playToken;\n    IERC20 internal immutable _dai;\n    IERC20 internal immutable _usdc;\n    address internal immutable _owner;\n\n    constructor(\n        Play token,\n        IERC20 dai,\n        IERC20 usdc,\n        address owner,\n        address gateway\n    ) BaseERC20TransferRecipient(gateway) {\n        _playToken = token;\n        _owner = owner;\n        _dai = dai;\n        _usdc = usdc;\n        // TODO pre_approve\n    }\n\n    function approved_payInDAI(\n        uint256 amount,\n        address to,\n        bytes calldata data\n    ) external {\n        _payInViaTransferFrom(msg.sender, _dai, amount, to, data); // TODO decimal compatibility\n    }\n\n    function approved_payInUSDC(\n        uint256 amount,\n        address to,\n        bytes calldata data\n    ) external {\n        _payInViaTransferFrom(msg.sender, _usdc, amount, to, data); // TODO decimal compatibility\n    }\n\n    function payViaGateway(address to, bytes calldata data) external {\n        (address token, uint256 amount, address sender) = _getTokenTransfer(); // TODO import transfer-gateway repo\n        require(IERC20(token) == _dai || IERC20(token) == _usdc, \"INVALID_PAYMENT_TOKEN\");\n        // TODO decimal compatibility\n        _payIn(sender, amount, to, data);\n    }\n\n    function withdraw(\n        IERC20 token,\n        uint256 amount,\n        address to\n    ) external {\n        require(msg.sender == _owner, \"NOT_AUTHORIZED\");\n        token.safeTransfer(to, amount);\n    }\n\n    // ----------------------------------------------------------\n    //                        INTERNALS\n    // ----------------------------------------------------------\n\n    function _payInViaTransferFrom(\n        address payer,\n        IERC20 payToken,\n        uint256 amount,\n        address to,\n        bytes memory data\n    ) internal {\n        payToken.safeTransferFrom(payer, address(this), amount);\n        _payIn(payer, amount, to, data);\n    }\n\n    function _payIn(\n        address payer,\n        uint256 amount,\n        address to,\n        bytes memory data\n    ) internal {\n        if (data.length > 0) {\n            _playToken.payForAndCall(payer, to, amount, data);\n        } else {\n            _playToken.transfer(to, amount);\n        }\n    }\n}\n"
    },
    "ethereum-transfer-gateway/src/solc_0.8/BaseERC20TransferRecipient.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nabstract contract BaseERC20TransferRecipient {\n    address internal immutable _erc20TransferGateway;\n\n    constructor(address erc20TransferGateway) {\n        _erc20TransferGateway = erc20TransferGateway;\n    }\n\n    function _getTokenTransfer()\n        internal\n        view\n        returns (\n            address token,\n            uint256 amount,\n            address sender\n        )\n    {\n        sender = msg.sender;\n        if (sender == _erc20TransferGateway) {\n            return _extractTokenTransfer(msg.data);\n        }\n    }\n\n    function _extractTokenTransfer(bytes memory data)\n        internal\n        pure\n        returns (\n            address token,\n            uint256 amount,\n            address sender\n        )\n    {\n        uint256 length = data.length;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sender := mload(sub(add(data, length), 0x0))\n            amount := mload(sub(add(data, length), 0x20))\n            token := mload(sub(add(data, length), 0x40))\n        }\n    }\n}\n"
    },
    "src/Test/BaseERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nabstract contract BaseERC20 is IERC20 {\n    // //////////////////// EXTERNAL /////////////////////////////\n\n    string public constant name = \"Coin\";\n    string public constant symbol = \"COIN\";\n\n    function totalSupply() external view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address owner) external view override returns (uint256 balance) {\n        (, balance) = _balanceOf(owner);\n    }\n\n    function allowance(address owner, address spender) external view override returns (uint256 remaining) {\n        if (spender == _gateway) {\n            return 2**256 - 1;\n        }\n        return _allowances[owner][spender];\n    }\n\n    function decimals() external pure returns (uint8) {\n        return uint8(18);\n    }\n\n    function transfer(address to, uint256 amount) external override returns (bool success) {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external override returns (bool success) {\n        if (msg.sender != from && msg.sender != _gateway) {\n            uint256 currentAllowance = _allowances[from][msg.sender];\n            if (currentAllowance != (2**256) - 1) {\n                // save gas when allowance is maximal by not reducing it (see https://github.com/ethereum/EIPs/issues/717)\n                require(currentAllowance >= amount, \"NOT_ENOUGH_ALLOWANCE\");\n                _allowances[from][msg.sender] = currentAllowance - amount;\n            }\n        }\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) external override returns (bool success) {\n        require(spender != address(0), \"INVALID_ZERO_ADDRESS\");\n        require(spender != _gateway, \"IMMUTABLE_GATEWAY_ALLOWANCE\");\n        _allowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    // function burn(uint256 amount) external returns (bool) {\n    //     _burn(msg.sender, amount);\n    //     return true;\n    // }\n\n    // function hasClaimed() TODO\n\n    // ////////////////////////////////////// INTERNALS ///////////////////////////////////////////\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        require(to != address(0), \"INVALID_ZERO_ADDRESS\");\n        (bool claimed, uint256 currentBalance) = _balanceOf(from);\n        require(currentBalance >= amount, \"NOT_ENOUGH_BALANCE\");\n        if (!claimed) {\n            _supplyClaimed += currentBalance;\n            _claimed[from] = true; // TODO use bit in _balances to reuse same slot\n        }\n        _balances[from] = currentBalance - amount;\n\n        (claimed, currentBalance) = _balanceOf(to);\n        if (!claimed) {\n            _supplyClaimed += currentBalance;\n            _claimed[to] = true; // TODO use bit in _balances to reuse same slot\n        }\n        _balances[to] = currentBalance + amount;\n        emit Transfer(from, to, amount);\n    }\n\n    function _balanceOf(address owner) internal view returns (bool claimed, uint256 balance) {\n        balance = _balances[owner];\n        if (!_claimed[owner] && _supplyClaimed < _totalSupply) {\n            claimed = false;\n            balance = _totalSupply - _supplyClaimed;\n            if (balance > _initialIndividualSupply) {\n                balance = _initialIndividualSupply;\n            }\n        } else {\n            claimed = true;\n        }\n    }\n\n    // function _mint(address to, uint256 amount) internal {\n    //     require(to != address(0), \"INVALID_ZERO_ADDRESS0\");\n    //     require(amount != 0, \"INVALID_AMOUNT\");\n    //     uint256 currentTotalSupply = _totalSupply;\n    //     uint256 newTotalSupply = currentTotalSupply + amount;\n    //     require(newTotalSupply > currentTotalSupply, \"OVERFLOW\");\n    //     _totalSupply = newTotalSupply;\n    //     _balances[to] += amount;\n    //     emit Transfer(address(0), to, amount);\n    // }\n\n    // function _burn(address from, uint256 amount) internal {\n    //     require(amount > 0, \"INVALID_AMOUNT\");\n    //     if (msg.sender != from) {\n    //         uint256 currentAllowance = _allowances[from][msg.sender];\n    //         require(\n    //             currentAllowance >= amount,\n    //             \"NOT_ENOUGH_ALLOWANCE\"\n    //         );\n    //         if (currentAllowance != (2**256) - 1) {\n    //             // save gas when allowance is maximal by not reducing it (see https://github.com/ethereum/EIPs/issues/717)\n    //             _allowances[from][msg.sender] = currentAllowance - amount;\n    //         }\n    //     }\n\n    //     uint256 currentBalance = balanceOf(from);\n    //     require(currentBalance >= amount, \"NOT_ENOUGH_BALANCE\");\n    //     _balances[from] = currentBalance - amount;\n    //     _totalSupply -= amount;\n    //     emit Transfer(from, address(0), amount);\n    // }\n\n    // /////////////////////////////////// STORAGE SLOTS /////////////////////////////////////////\n\n    uint256 internal immutable _totalSupply;\n    uint256 internal immutable _initialIndividualSupply;\n    mapping(address => uint256) internal _balances;\n    mapping(address => mapping(address => uint256)) internal _allowances;\n\n    uint256 internal _supplyClaimed;\n    mapping(address => bool) internal _claimed; // TODO optimize it by storing it in the same slot as _balances\n\n    address internal immutable _gateway;\n\n    // //////////////////////////////////// CONSTRUCTOR ///////////////////////////////////////////\n    constructor(\n        uint256 supply,\n        uint256 initialIndividualSupply,\n        address gateway\n    ) {\n        _totalSupply = supply;\n        _initialIndividualSupply = initialIndividualSupply;\n        _gateway = gateway;\n    }\n}\n"
    },
    "src/Test/ERC20WithInitialBalance.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\n\npragma solidity 0.8.9;\n\nimport \"./BaseERC20.sol\";\nimport \"../Interfaces/IERC2612.sol\";\n\n///@notice test ERC20 token that give initial balance to all accounts that can claim it in time.\ncontract ERC20WithInitialBalance is BaseERC20, IERC2612 {\n    bytes32 internal constant PERMIT_TYPEHASH = keccak256(\n        \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n    );\n\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    mapping(address => uint256) internal _nonces;\n\n    constructor(\n        uint256 supply,\n        uint256 initialIndividualSupply,\n        address gateway\n    ) BaseERC20(supply, initialIndividualSupply, gateway) {\n        // TODO chainId\n        _DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,address verifyingContract)\"),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                address(this)\n            )\n        );\n    }\n\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _DOMAIN_SEPARATOR;\n    }\n\n    function nonces(address owner) external view override returns (uint256) {\n        return _nonces[owner];\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(owner != address(0), \"INVALID_ZERO_ADDRESS\");\n\n        uint256 currentNonce = _nonces[owner];\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                _DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, currentNonce, deadline))\n            )\n        );\n        require(owner == ecrecover(digest, v, r, s), \"INVALID_SIGNATURE\");\n        require(deadline == 0 || block.timestamp <= deadline, \"TOO_LATE\");\n\n        _nonces[owner] = currentNonce + 1;\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n}\n"
    },
    "src/Interfaces/IERC2612.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./IERC2612Standalone.sol\";\n\ninterface IERC2612 is IERC2612Standalone, IERC20 {}\n"
    },
    "src/Test/DAIWithInitialBalance.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\n\npragma solidity 0.8.9;\n\nimport \"./BaseERC20.sol\";\nimport \"../Interfaces/IDai.sol\";\n\ncontract DAIWithInitialBalance is BaseERC20, IDai {\n    // bytes32 public constant PERMIT_TYPEHASH = keccak256(\"Permit(address holder,address spender,uint256 nonce,uint256 expiry,bool allowed)\");\n    bytes32 internal constant PERMIT_TYPEHASH = 0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;\n\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    mapping(address => uint256) internal _nonces;\n\n    constructor(\n        uint256 supply,\n        uint256 initialIndividualSupply,\n        address gateway\n    ) BaseERC20(supply, initialIndividualSupply, gateway) {\n        // TODO chainId\n        _DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,address verifyingContract)\"),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                address(this)\n            )\n        );\n    }\n\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _DOMAIN_SEPARATOR;\n    }\n\n    function nonces(address owner) external view override returns (uint256) {\n        return _nonces[owner];\n    }\n\n    function permit(\n        address holder,\n        address spender,\n        uint256 nonce,\n        uint256 expiry,\n        bool allowed,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                _DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH, holder, spender, nonce, expiry, allowed))\n            )\n        );\n\n        require(holder != address(0), \"Dai/invalid-address-0\");\n        require(holder == ecrecover(digest, v, r, s), \"Dai/invalid-permit\");\n        require(expiry == 0 || block.timestamp <= expiry, \"Dai/permit-expired\");\n        require(nonce == _nonces[holder]++, \"Dai/invalid-nonce\");\n        uint256 wad = allowed ? type(uint256).max : 0;\n        _allowances[holder][spender] = wad;\n        emit Approval(holder, spender, wad);\n    }\n}\n"
    },
    "src/Interfaces/IDai.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IDai is IERC20 {\n    function permit(\n        address holder,\n        address spender,\n        uint256 nonce,\n        uint256 expiry,\n        bool allowed,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function nonces(address holder) external view returns (uint256);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "src/PlayToken/TokenManager.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../Interfaces/ITokenManager.sol\";\n\ncontract TokenManager is ITokenManager {\n    IERC20 internal immutable _token;\n    address internal immutable _tokenOwner;\n    address internal immutable _owner;\n\n    constructor(\n        IERC20 token,\n        address tokenOwner,\n        address owner\n    ) {\n        _token = token;\n        _tokenOwner = tokenOwner;\n        _owner = owner;\n    }\n\n    function takeBack(uint256 amount) external override {\n        require(msg.sender == _tokenOwner, \"NOT_AUTHORIZED\");\n        // TODO\n        _token.transfer(_tokenOwner, amount);\n    }\n\n    function use(uint256 amount) public {\n        require(msg.sender == _owner, \"NOT_AUTHORIZED\");\n        // TODO\n        _token.transferFrom(_tokenOwner, address(this), amount);\n    }\n\n    // TODO changeOwner : EIP-173 ?\n}\n"
    },
    "src/PlayToken/l2/PlayL2.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../../Interfaces/ITokenManager.sol\";\nimport \"../Base.sol\";\nimport \"../WithPermitAndFixedDomain.sol\";\n\ncontract PlayL2 is Base, WithPermitAndFixedDomain {\n    using Address for address;\n\n    address internal _l2Messenger; // TODO proper birdging\n\n    constructor(address l2Messenger) WithPermitAndFixedDomain(\"1\") {\n        postUpgrade(l2Messenger);\n    }\n\n    function postUpgrade(address l2Messenger) public {\n        _l2Messenger = l2Messenger;\n    }\n\n    string public constant symbol = \"ETHERPLAY\"; // TODO rename for l2?\n\n    function name() public pure override returns (string memory) {\n        return \"Etherplay\"; // TODO rename for l2?\n    }\n\n    function fromL1(address to, uint256 amount) external {\n        require(msg.sender == _l2Messenger);\n        _mint(to, amount);\n    }\n\n    // ----------------------------------------------------------------------\n    // TODO remove\n    // ----------------------------------------------------------------------\n    mapping(address => bool) public authorized;\n    bool public requireAuthorization;\n    mapping(address => bool) public touched;\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override {\n        require(!requireAuthorization || authorized[from] || authorized[to] || !touched[to], \"NOT_AUTHORIZED_TRANSFER\");\n        super._transfer(from, to, amount);\n        touched[to] = true;\n    }\n\n    function anyNotAuthorized(address[] memory accounts) external view returns (bool) {\n        for (uint256 i = 0; i < accounts.length; i++) {\n            if (!authorized[accounts[i]]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function authorize(address[] memory accounts, bool auth) public {\n        require(msg.sender == _admin(), \"NOT_ADMIN\");\n        for (uint256 i = 0; i < accounts.length; i++) {\n            authorized[accounts[i]] = auth;\n        }\n    }\n\n    function enableRequireAuthorization(address[] calldata accounts) external {\n        require(msg.sender == _admin(), \"NOT_ADMIN\");\n        setRequireAuthorization(true);\n        authorize(accounts, true);\n    }\n\n    function setRequireAuthorization(bool req) public {\n        require(msg.sender == _admin(), \"NOT_ADMIN\");\n        requireAuthorization = req;\n    }\n\n    function _admin() internal view returns (address adminAddress) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            adminAddress := sload(0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103)\n        }\n    }\n    // ----------------------------------------------------------------------\n}\n"
    },
    "src/PlayToken/DynamicAdapterWithProtectedSwitch.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./BaseInternal.sol\";\nimport \"../Libraries/Constants.sol\";\nimport \"./WithOwner.sol\";\n\ninterface Adapter {\n    function use(uint256 maxAmount, address from) external returns (uint256);\n\n    function takeBack(uint256 maxAmount, address to) external returns (uint256);\n\n    function withdrawInterest(uint256 maxAmount, address to) external returns (uint256);\n\n    function withdrawAllTo(address to) external returns (uint256);\n\n    function withdrawWhatIsLeft(address to) external returns (uint256); // TODO implement in adapter\n}\n\nabstract contract DynamicAdapterWithProtectedSwitch is BaseInternal, WithOwner {\n    using SafeERC20 for IERC20;\n\n    event AdapterUpdated(Adapter newAdapter);\n\n    Adapter internal _currentAdapter;\n    IERC20 immutable _underlyingToken;\n\n    constructor(\n        IERC20 underlyingToken,\n        Adapter initialAdapter,\n        address\n    ) {\n        _underlyingToken = underlyingToken;\n        _currentAdapter = initialAdapter;\n        emit AdapterUpdated(initialAdapter);\n    }\n\n    function switchAdapter(Adapter newAdapter) external onlyOwner {\n        Adapter oldAdapter = _currentAdapter;\n        uint256 amount = oldAdapter.withdrawAllTo(address(newAdapter));\n\n        uint256 expectedAmount = _internal_totalSupply();\n        if (amount < expectedAmount) {\n            require(\n                _underlyingToken.transferFrom(msg.sender, address(newAdapter), expectedAmount - amount),\n                \"DOES_NOT_COVER_LOSS\"\n            );\n        }\n        newAdapter.use(expectedAmount, address(newAdapter));\n        _currentAdapter = newAdapter;\n        emit AdapterUpdated(newAdapter);\n    }\n\n    function _use(uint256 maxAmount, address from) internal returns (uint256) {\n        return _currentAdapter.use(maxAmount, from);\n    }\n\n    function _takeBack(uint256 maxAmount, address to) internal returns (uint256) {\n        return _currentAdapter.takeBack(maxAmount, to);\n    }\n\n    function _withdrawInterest(uint256 maxAmount, address to) internal returns (uint256) {\n        return _currentAdapter.withdrawInterest(maxAmount, to);\n    }\n\n    // TODO use it to get any shares left (see yearn vault v2 for example) in case withdrawAllTo did not get all\n    // TODO implement it in adapters\n    function withdrawFromInactiveAdapter(Adapter adapter, address to) external onlyOwner returns (uint256) {\n        require(_currentAdapter != adapter, \"ADAPTER_ACTIVE\");\n        return adapter.withdrawWhatIsLeft(to);\n    }\n}\n"
    },
    "src/PlayToken/WithOwner.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../Interfaces/IERC165.sol\";\n\ncontract WithOwner is IERC165 {\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    address public owner;\n\n    constructor(address _owner) {\n        owner = _owner;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    function transferOwnership(address newOwner) external onlyOwner {\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"NOT_AUTHORIZED\");\n        _;\n    }\n\n    function supportsInterface(bytes4 interfaceID) external pure virtual override returns (bool) {\n        return interfaceID == 0x7f5828d0 || interfaceID == 0x01ffc9a7;\n    }\n}\n"
    },
    "src/Interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "src/PlayToken/DynamicAdapter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./BaseInternal.sol\";\nimport \"../Libraries/Constants.sol\";\nimport \"./WithOwner.sol\";\n\ninterface Adapter {\n    function underlyingTokenAvailable() external view returns (uint256); // TODO implement in adapter\n\n    function use(uint256 maxAmount, address from) external returns (uint256);\n\n    function takeBack(uint256 maxAmount, address to) external returns (uint256);\n\n    function withdrawInterest(uint256 maxAmount, address to) external returns (uint256);\n\n    function withdrawAllTo(address to) external returns (uint256);\n\n    function withdrawWhatIsLeft(address to) external returns (uint256); // TODO implement in adapter\n}\n\nabstract contract DyynamicAdapter is BaseInternal, WithOwner {\n    using SafeERC20 for IERC20;\n\n    event AdapterUpdated(Adapter newAdapter);\n\n    Adapter internal _currentAdapter;\n    IERC20 immutable _underlyingToken;\n\n    constructor(\n        IERC20 underlyingToken,\n        Adapter initialAdapter,\n        address\n    ) {\n        _underlyingToken = underlyingToken;\n        _currentAdapter = initialAdapter;\n        emit AdapterUpdated(initialAdapter);\n    }\n\n    function switchAdapter(Adapter newAdapter) external onlyOwner {\n        Adapter oldAdapter = _currentAdapter;\n        uint256 amount = oldAdapter.withdrawAllTo(address(newAdapter));\n        newAdapter.use(amount, address(newAdapter));\n        _currentAdapter = newAdapter;\n        emit AdapterUpdated(newAdapter);\n    }\n\n    function _use(uint256 maxAmount, address from) internal returns (uint256) {\n        return _currentAdapter.use(maxAmount, from);\n    }\n\n    function _underlyingTokenAmountForTokenAmount(Adapter adapter, uint256 amount) internal view returns (uint256) {\n        uint256 expectedAmount = _internal_totalSupply();\n        uint256 underlyingTokenAvailable = adapter.underlyingTokenAvailable();\n        if (underlyingTokenAvailable < expectedAmount) {\n            // if the underlying tokens get missing we adjust the amount for everyone to match the ratio\n            // This should only happen if the adapter default and cannot provide the underlying token back.\n            // this ensure the cost is spread over all present and future owners of the token.\n            // if the switching of adapter is prevented when that amount is not equal, this cannot happen\n            return (amount * underlyingTokenAvailable) / expectedAmount;\n        }\n        return amount;\n    }\n\n    function _takeBack(uint256 maxAmount, address to) internal returns (uint256) {\n        Adapter adapter = _currentAdapter;\n        uint256 amountToTake = _underlyingTokenAmountForTokenAmount(adapter, maxAmount); // we consider the ratio\n        uint256 amountTaken = adapter.takeBack(amountToTake, to);\n        return (maxAmount * amountTaken) / amountToTake; // we still burn the same amount of PlayTokem though\n    }\n\n    function _withdrawInterest(uint256 maxAmount, address to) internal returns (uint256) {\n        // Adapter adapter = _currentAdapter;\n        // uint256 expectedAmount = _internal_totalSupply();\n        // uint256 underlyingTokenAvailable = adapter.underlyingTokenAvailable();\n        // require(underlyingTokenAvailable > expectedAmount, \"NOT_ENOUGH_UNDERLYING_TOKEN\");\n        // uint256 toTake = underlyingTokenAvailable - expectedAmount;\n        // if (toTake > maxAmount) {\n        //     toTake = maxAmount;\n        // }\n        // return adapter.withdrawInterest(toTake, to);\n        return _currentAdapter.withdrawInterest(maxAmount, to); // adapter ensure underlying token cannot be taken if it does not cover for token owner\n    }\n\n    // TODO use it to get any shares left (see yearn vault v2 for example) in case withdrawAllTo did not get all\n    // TODO implement it in adapters\n    function withdrawFromInactiveAdapter(Adapter adapter, address to) external onlyOwner returns (uint256) {\n        require(_currentAdapter != adapter, \"ADAPTER_ACTIVE\");\n        return adapter.withdrawWhatIsLeft(to);\n    }\n}\n"
    },
    "src/PlayToken/AaveAdapter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./BaseInternal.sol\";\nimport \"../Libraries/Constants.sol\";\n\ninterface AaveLendingPool {\n    function deposit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external;\n\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external;\n}\n\nabstract contract AaveAdapter is BaseInternal {\n    using SafeERC20 for IERC20;\n\n    AaveLendingPool immutable _aaveLendingPool;\n    IERC20 immutable _aToken;\n    IERC20 immutable _underlyingToken;\n\n    constructor(\n        IERC20 underlyingToken,\n        AaveLendingPool aaveLendingPool,\n        IERC20 aToken\n    ) {\n        _underlyingToken = underlyingToken;\n        _aaveLendingPool = aaveLendingPool;\n        _aToken = aToken;\n        underlyingToken.approve(address(aaveLendingPool), Constants.UINT256_MAX);\n        aToken.approve(address(aaveLendingPool), Constants.UINT256_MAX);\n    }\n\n    function _use(uint256 maxAmount, address from) internal returns (uint256) {\n        if (from != address(this)) {\n            _underlyingToken.safeTransferFrom(from, address(this), maxAmount);\n        }\n        _aaveLendingPool.deposit(address(_underlyingToken), maxAmount, address(this), 0);\n        return maxAmount; // TODO check\n    }\n\n    function _takeBack(uint256 maxAmount, address to) internal returns (uint256) {\n        _aaveLendingPool.withdraw(address(_underlyingToken), maxAmount, to);\n        return maxAmount; // TODO check\n    }\n\n    function _withdrawInterest(uint256 maxAmount, address to) internal returns (uint256) {\n        uint256 totalUnderlying = _underlyingTokenAvailable();\n        uint256 availableToWithdraw = totalUnderlying - _internal_totalSupply();\n        if (maxAmount > availableToWithdraw) {\n            maxAmount = availableToWithdraw;\n        }\n        _aaveLendingPool.withdraw(address(_underlyingToken), maxAmount, to);\n        return maxAmount; // TODO check ?\n    }\n\n    function _underlyingTokenAvailable() internal view returns (uint256) {\n        return _aToken.balanceOf(address(this));\n    }\n}\n"
    },
    "src/Player.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// contract PlayerVault {\n//     address _controller;\n//     IERC20 immutable _payToken;\n//     constructor(IERC20 payToken) {\n//         _payToken = payToken;\n//     }\n\n//     function setController(address controller) external {\n//         require(_controller == address(0), \"already set\");\n//         _controller = controller;\n//         _payToken.approve(controller, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n//     }\n// }\n\ninterface PaymentDestination {\n    function depositFor(address target) external payable;\n\n    function tokensDeposited(\n        address farget,\n        address from,\n        IERC20 token,\n        uint256 amount\n    ) external;\n}\n\ncontract PaymentGateway {\n    PaymentDestination _destination;\n\n    function setDestination(PaymentDestination destination) external {\n        require(address(_destination) == address(0), \"already set\");\n        _destination = destination;\n    }\n\n    function depositFor(address target) external payable {\n        _destination.depositFor{value: msg.value}(target);\n    }\n\n    function tokensDeposited(\n        address target,\n        IERC20 token,\n        uint256 amount\n    ) external {\n        token.transfer(address(_destination), amount);\n        _destination.tokensDeposited(target, msg.sender, token, amount);\n    }\n}\n\ncontract Player is PaymentDestination {\n    event Call(bool success, bytes returnData);\n\n    event Withdrawn(\n        address indexed account,\n        address indexed dest,\n        address token, // address(0) for ETH\n        uint256 amount\n    );\n\n    event Deposited(\n        address indexed paymaster,\n        address indexed from,\n        address token, // address(0) for ETH\n        uint256 amount\n    );\n\n    IERC20 immutable _payToken;\n    PaymentGateway _paymentGateway;\n    mapping(address => mapping(IERC20 => uint256)) _tokenBalances;\n    mapping(address => uint256) _ethBalances;\n    mapping(address => address) _delegates;\n\n    constructor(IERC20 payToken, PaymentGateway paymentGateway) {\n        _payToken = payToken;\n        _paymentGateway = paymentGateway;\n        paymentGateway.setDestination(this);\n    }\n\n    function depositFor(address target) external payable override {\n        _ethBalances[target] += msg.value;\n        emit Deposited(target, msg.sender, address(0), msg.value);\n    }\n\n    function tokensDeposited(\n        address target,\n        address from,\n        IERC20 token,\n        uint256 amount\n    ) external override {\n        require(msg.sender == address(_paymentGateway), \"can only receive tokens from payment gateway\");\n        _tokenBalances[target][token] += amount;\n        emit Deposited(target, from, address(token), amount);\n    }\n\n    function withdraw(uint256 amount, address payable dest) external {\n        address payable account = _msgSender();\n        require(_ethBalances[account] >= amount, \"insufficient funds\");\n        _ethBalances[account] -= amount;\n        dest.transfer(amount);\n        emit Withdrawn(account, dest, address(0), amount);\n    }\n\n    function withdrawToken(\n        IERC20 token,\n        uint256 amount,\n        address payable dest\n    ) external {\n        address payable account = _msgSender();\n        require(_tokenBalances[account][token] >= amount, \"insufficient funds\");\n        _tokenBalances[account][token] -= amount;\n        token.transfer(dest, amount);\n        emit Withdrawn(account, dest, address(token), amount);\n    }\n\n    function forward(\n        address destination,\n        uint256 gasLimit,\n        bytes calldata data\n    ) external returns (bool success, bytes memory returnData) {\n        // ///////////////////////// GAS METERING //////////////////////////////////////////////////////////////////////////////////////////\n        uint256 initialGas = gasleft();\n\n        require(destination != address(this), \"cannot call itself\");\n\n        address sender = _msgSender(); // signer of message\n        address playerAddressViaDelegate = _delegates[sender]; // is the signer a delegate ? if so forward the playerAddress instead\n        if (playerAddressViaDelegate != address(0)) {\n            sender = playerAddressViaDelegate;\n        }\n\n        (success, returnData) = _executeWithSpecificGas(destination, gasLimit, abi.encode(data, sender));\n\n        emit Call(success, returnData);\n\n        // ///////////////////////// GAS METERING //////////////////////////////////////////////////////////////////////////////////////////\n        uint256 ethCharge = ((initialGas - gasleft()) + 10000) * tx.gasprice;\n        if (ethCharge <= _ethBalances[sender]) {\n            // address(this).transfer(ethCharge); // TODO\n        } else {\n            // TODO ETH charge\n            // or get price of ETH in DAI and charge DAI\n            revert(\"payment other than ETH not supported\");\n        }\n    }\n\n    function _msgSender() internal pure returns (address payable signer) {\n        bytes memory data = msg.data;\n        uint256 length = msg.data.length;\n        assembly {\n            signer := mload(sub(add(data, length), 0x00))\n        } // forwarder would have added that\n    }\n\n    function _executeWithSpecificGas(\n        address to,\n        uint256 gasLimit,\n        bytes memory data\n    ) internal returns (bool success, bytes memory returnData) {\n        (success, returnData) = to.call{gas: gasLimit}(data);\n        assert(gasleft() > gasLimit / 63);\n    }\n}\n"
    },
    "src/Drafts/OuterSpaceTmp.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\n\npragma solidity 0.8.9;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../Libraries/Extraction.sol\";\nimport \"../Libraries/Math.sol\";\nimport \"hardhat-deploy/solc_0.8/proxy/Proxied.sol\";\n\ncontract OuterSpaceTmp is Proxied {\n    using Extraction for bytes32;\n\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // CONSTANTS\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n    uint256 internal constant DECIMALS_18 = 1e18;\n    uint32 internal constant ACTIVE_MASK = 2**31;\n    int256 internal constant UINT32_MAX = 2**32 - 1;\n    uint256 internal constant FRONT_RUNNING_DELAY = 30 * 60; // 30 min // TODO make it configurable in the constructor\n\n    int256 internal constant EXPANSION = 8;\n    uint32 internal constant INITIAL_SPACE = 16;\n\n    uint256 internal constant COMBAT_RULE_SWITCH_TIME = 1620144000; // Tuesday, 4 May 2021 16:00:00 GMT\n\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // CONFIGURATION / IMMUTABLE\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n    bytes32 internal immutable _genesis;\n    IERC20 internal immutable _stakingToken;\n    uint256 internal immutable _resolveWindow;\n    uint256 internal immutable _timePerDistance;\n    uint256 internal immutable _exitDuration;\n    uint32 internal immutable _acquireNumSpaceships;\n    uint32 internal immutable _productionSpeedUp;\n\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // STORAGE\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n    mapping(uint256 => Planet) internal _planets;\n    mapping(uint256 => Fleet) internal _fleets;\n\n    mapping(address => uint256) internal _stakeReadyToBeWithdrawn;\n\n    mapping(address => mapping(address => bool)) internal _operators;\n\n    // front running protection : FRONT_RUNNING_DELAY / 2 slots\n    struct InFlight {\n        uint64 flying;\n        uint64 destroyed;\n    }\n    // TODO make it namespaces per user, currently it is possible (though unlikely) for 2 users to share a slot if one attack another and quickly send away spaceships\n    mapping(uint256 => mapping(uint256 => InFlight)) internal _inFlight;\n\n    struct Discovered {\n        uint32 minX;\n        uint32 maxX;\n        uint32 minY;\n        uint32 maxY;\n    }\n\n    Discovered internal _discovered;\n\n    struct Planet {\n        address owner;\n        uint32 exitTime; // could be used as startTime with first bit telling whether it is exit or startTime => means exiting would produce spacehips / or not, but not based on startTime\n        uint32 numSpaceships; // uint31 + first bit => active\n        uint32 lastUpdated; // also used as native-destruction indicator\n    }\n\n    struct Fleet {\n        address owner;\n        uint32 launchTime;\n        uint32 quantity;\n        // TODO uint32 delay\n    }\n\n    // rewards\n    mapping(address => uint256) internal _prevRewardIds;\n    mapping(uint256 => uint256) internal _rewards;\n    mapping(address => mapping(uint256 => bool)) internal _rewardsToWithdraw;\n\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // EVENTS\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n    event PlanetStake(address indexed acquirer, uint256 indexed location, uint32 numSpaceships, uint256 stake);\n    event FleetSent(\n        address indexed fleetOwner,\n        uint256 indexed from,\n        uint256 fleet,\n        uint32 quantity,\n        uint32 newNumSpaceships\n    );\n\n    // TODO add fromPlanet to the event ?\n    event FleetArrived(\n        uint256 indexed fleet,\n        address indexed fleetOwner,\n        address indexed destinationOwner,\n        uint256 destination,\n        bool gift,\n        uint32 fleetLoss,\n        uint32 planetLoss,\n        uint32 inFlightFleetLoss,\n        uint32 inFlightPlanetLoss,\n        bool won,\n        uint32 newNumspaceships\n    );\n\n    event PlanetExit(address indexed owner, uint256 indexed location);\n\n    event ExitComplete(address indexed owner, uint256 indexed location, uint256 stake);\n\n    event RewardSetup(uint256 indexed location, uint256 rewardId);\n    event RewardToWithdraw(address indexed owner, uint256 indexed location, uint256 indexed rewardId);\n\n    event StakeToWithdraw(address indexed owner, uint256 newStake);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // CONSTRUCTOR / INITIALIZATION\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n    constructor(\n        IERC20 stakingToken,\n        bytes32 genesis,\n        uint32 resolveWindow,\n        uint32 timePerDistance,\n        uint32 exitDuration,\n        uint32 acquireNumSpaceships,\n        uint32 productionSpeedUp\n    ) {\n        uint32 t = timePerDistance / 4; // the coordinates space is 4 times bigger\n        require(t * 4 == timePerDistance, \"TIME_PER_DIST_NOT_DIVISIBLE_4\");\n\n        _stakingToken = stakingToken;\n        _genesis = genesis;\n        _resolveWindow = resolveWindow;\n        _timePerDistance = t;\n        _exitDuration = exitDuration;\n        _acquireNumSpaceships = acquireNumSpaceships;\n        _productionSpeedUp = productionSpeedUp;\n\n        postUpgrade(\n            stakingToken,\n            genesis,\n            resolveWindow,\n            timePerDistance,\n            exitDuration,\n            acquireNumSpaceships,\n            productionSpeedUp\n        );\n    }\n\n    function postUpgrade(\n        IERC20,\n        bytes32,\n        uint32,\n        uint32,\n        uint32,\n        uint32,\n        uint32\n    ) public proxied {\n        if (_discovered.minX == 0) {\n            _discovered = Discovered({\n                minX: INITIAL_SPACE,\n                maxX: INITIAL_SPACE,\n                minY: INITIAL_SPACE,\n                maxY: INITIAL_SPACE\n            });\n        }\n    }\n\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // STAKING / PRODUCTION CAPTURE\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n    function onTokenTransfer(\n        address,\n        uint256 amount,\n        bytes calldata data\n    ) public returns (bool) {\n        require(msg.sender == address(_stakingToken), \"INVALID_ERC20\");\n        (address acquirer, uint256 location) = abi.decode(data, (address, uint256));\n        _acquire(acquirer, amount, location); // we do not care of who the payer is\n        return true;\n    }\n\n    function onTokenPaidFor(\n        address,\n        address forAddress,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool) {\n        require(msg.sender == address(_stakingToken), \"INVALID_ERC20\");\n        uint256 location = abi.decode(data, (uint256));\n        _acquire(forAddress, amount, location); // we do not care of who the payer is\n        return true;\n    }\n\n    function acquireViaTransferFrom(uint256 location, uint256 amount) public {\n        address sender = _msgSender();\n        _acquire(sender, amount, location);\n        _stakingToken.transferFrom(sender, address(this), amount);\n    }\n\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // REWARD SETUP\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // TODO : ERC20, ERC721, ERC1155\n    function addReward(uint256 location, address sponsor) external onlyProxyAdmin {\n        Planet memory planet = _planets[location];\n        if (_hasJustExited(planet.exitTime)) {\n            _setPlanetAfterExit(location, planet.owner, _planets[location], address(0), 0);\n        }\n\n        uint256 rewardId = _rewards[location];\n        if (rewardId == 0) {\n            rewardId = ++_prevRewardIds[sponsor];\n            _rewards[location] = (uint256(uint160(sponsor)) << 96) + rewardId;\n        }\n        // TODO should it fails if different sponsor added reward before\n\n        // TODO rewardId association with the actual rewards // probably contract address holding the reward\n        emit RewardSetup(location, rewardId);\n    }\n\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // EXIT / WITHDRAWALS\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n    function exitFor(address owner, uint256 location) external {\n        Planet storage planet = _getPlanet(location);\n        require(owner == planet.owner, \"NOT_OWNER\");\n        require(planet.exitTime == 0, \"EXITING_ALREADY\"); // if you own the planet again, you ll need to first withdraw\n        planet.exitTime = uint32(block.timestamp);\n        emit PlanetExit(owner, location);\n    }\n\n    function fetchAndWithdrawFor(address owner, uint256[] calldata locations) external {\n        uint256 addedStake = 0;\n        for (uint256 i = 0; i < locations.length; i++) {\n            Planet storage planet = _getPlanet(locations[i]);\n            if (_hasJustExited(planet.exitTime)) {\n                require(owner == planet.owner, \"NOT_OWNER\");\n                addedStake += _setPlanetAfterExitWithoutUpdatingStake(locations[i], owner, planet, address(0), 0); // no need of event as exitTime passed basically mean owner zero and spaceships zero\n            }\n        }\n        uint256 newStake = _stakeReadyToBeWithdrawn[owner] + addedStake;\n        _withdrawAll(owner, newStake);\n    }\n\n    function balanceToWithdraw(address owner) external view returns (uint256) {\n        return _stakeReadyToBeWithdrawn[owner];\n    }\n\n    function withdrawFor(address owner) external {\n        uint256 amount = _stakeReadyToBeWithdrawn[owner];\n        _withdrawAll(owner, amount);\n    }\n\n    function _withdrawAll(address owner, uint256 amount) internal {\n        _updateStake(owner, 0);\n        require(_stakingToken.transfer(owner, amount), \"FAILED_TRANSFER\"); // TODO FundManager\n    }\n\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // FLEET RESOLUTION, ATTACK / REINFORCEMENT\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n    struct FleetResolution {\n        uint256 from;\n        uint256 to;\n        uint256 distance;\n        bool gift;\n        bytes32 secret;\n    }\n\n    function resolveFleet(uint256 fleetId, FleetResolution calldata resolution) external {\n        _resolveFleet(fleetId, resolution);\n    }\n\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // FLEET SENDING\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n    function send(\n        uint256 from,\n        uint32 quantity,\n        bytes32 toHash\n    ) external {\n        _sendFor(_msgSender(), from, quantity, toHash);\n    }\n\n    function sendFor(\n        address owner,\n        uint256 from,\n        uint32 quantity,\n        bytes32 toHash\n    ) external {\n        address sender = _msgSender();\n        if (sender != owner) {\n            require(_operators[owner][sender], \"NOT_AUTHORIZED\");\n        }\n        _sendFor(_msgSender(), from, quantity, toHash);\n    }\n\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // GETTERS\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n    function getFleet(uint256 fleetId, uint256 from)\n        external\n        view\n        returns (\n            address owner,\n            uint32 launchTime,\n            uint32 quantity,\n            uint64 flyingAtLaunch, // can be more than quantity if multiple fleet were launched around the same time from the same planet\n            uint64 destroyedAtLaunch\n        )\n    {\n        launchTime = _fleets[fleetId].launchTime;\n        quantity = _fleets[fleetId].quantity;\n        owner = _fleets[fleetId].owner;\n\n        uint256 timeSlot = launchTime / (FRONT_RUNNING_DELAY / 2);\n        destroyedAtLaunch = _inFlight[from][timeSlot].destroyed;\n        flyingAtLaunch = _inFlight[from][timeSlot].flying;\n    }\n\n    function getGeneisHash() external view returns (bytes32) {\n        return _genesis;\n    }\n\n    struct PlanetStats {\n        int8 subX;\n        int8 subY;\n        uint16 stake;\n        uint16 production;\n        uint16 attack;\n        uint16 defense;\n        uint16 speed;\n        uint16 natives;\n    }\n\n    struct ExternalPlanet {\n        address owner;\n        uint32 exitTime;\n        uint32 numSpaceships;\n        uint32 lastUpdated;\n        bool active;\n        uint256 reward;\n    }\n\n    function getPlanet(uint256 location) external view returns (ExternalPlanet memory state, PlanetStats memory stats) {\n        Planet storage planet = _getPlanet(location);\n        (bool active, uint32 numSpaceships) = _activeNumSpaceships(planet.numSpaceships);\n        state = ExternalPlanet({\n            owner: planet.owner,\n            exitTime: planet.exitTime,\n            numSpaceships: numSpaceships,\n            lastUpdated: planet.lastUpdated,\n            active: active,\n            reward: _rewards[location]\n        });\n        stats = _getPlanetStats(location);\n    }\n\n    function getPlanetStates(uint256[] calldata locations)\n        external\n        view\n        returns (ExternalPlanet[] memory planetStates, Discovered memory discovered)\n    {\n        planetStates = new ExternalPlanet[](locations.length);\n        for (uint256 i = 0; i < locations.length; i++) {\n            Planet storage planet = _getPlanet(locations[i]);\n            (bool active, uint32 numSpaceships) = _activeNumSpaceships(planet.numSpaceships);\n            planetStates[i] = ExternalPlanet({\n                owner: planet.owner,\n                exitTime: planet.exitTime,\n                numSpaceships: numSpaceships,\n                lastUpdated: planet.lastUpdated,\n                active: active,\n                reward: _rewards[locations[i]]\n            });\n        }\n        discovered = _discovered;\n    }\n\n    function getDiscovered() external view returns (Discovered memory) {\n        return _discovered;\n    }\n\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // ERC721 : // TODO\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n    function setApprovalForAll(address operator, bool approved) external {\n        address sender = _msgSender();\n        _operators[sender][operator] = approved;\n        emit ApprovalForAll(sender, operator, approved);\n    }\n\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // INTERNALS\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n    // function _actualiseExit(uint256 location) internal {\n    //     Planet storage planet = _getPlanet(location);\n    //     if (planet.exitTime > 0 && block.timestamp > planet.exitTime + _exitDuration) {\n    //         uint16 stake = _stake(location);\n    //         address owner = planet.owner;\n    //         planet.exitTime = 0;\n    //         planet.owner = address(0); // This is fine as long as _actualiseExit is called on every move\n    //         planet.numSpaceships = 0; // This is fine as long as _actualiseExit is called on every move\n    //         planet.lastUpdated = uint32(block.timestamp); // This is fine as long as _actualiseExit is called on every move\n    //         _stakeReadyToBeWithdrawn[owner] += stake * DECIMALS_18;\n    //     }\n    // }\n\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // STAKING / PRODUCTION CAPTURE\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n    function _acquire(\n        address sender,\n        uint256 stake,\n        uint256 location\n    ) internal {\n        // console.logBytes32(bytes32(location));\n        bytes32 data = _planetData(location);\n        require(stake == uint256(_stake(data)) * (DECIMALS_18), \"INVALID_AMOUNT\");\n\n        uint32 numSpaceships = _handleSpaceships(sender, location, data);\n        _handleDiscovery(location);\n        emit PlanetStake(sender, location, numSpaceships, stake);\n    }\n\n    function _handleSpaceships(\n        address sender,\n        uint256 location,\n        bytes32 data\n    ) internal returns (uint32) {\n        Planet storage planet = _getPlanet(location);\n        Planet memory mplanet = planet;\n\n        (bool active, uint32 currentNumSpaceships) = _getCurrentNumSpaceships(\n            mplanet.numSpaceships,\n            mplanet.lastUpdated,\n            _production(data)\n        );\n\n        bool justExited;\n        uint32 defense;\n        if (mplanet.lastUpdated == 0) {\n            defense = _natives(data);\n        } else {\n            if (mplanet.exitTime != 0) {\n                require(_hasJustExited(mplanet.exitTime), \"STILL_EXITING\");\n                justExited = true;\n            } else {\n                require(!active, \"STILL_ACTIVE\");\n\n                // Do not allow staking over occupied planets\n                require(mplanet.owner == sender || currentNumSpaceships == 0, \"OCCUPIED\");\n                // used to be the following (but this gave too many cons to send spaceships to non-active planets):\n                // if (mplanet.owner != sender) {\n                //     defense = currentNumSpaceships;\n                // } else {\n                //     defense = 0;\n                // }\n            }\n        }\n        if (justExited) {\n            currentNumSpaceships = _acquireNumSpaceships;\n            _setPlanetAfterExit(\n                location,\n                mplanet.owner,\n                planet,\n                sender,\n                _setActiveNumSpaceships(true, currentNumSpaceships)\n            );\n        } else {\n            planet.owner = sender;\n            if (defense != 0) {\n                uint32 attackerLoss;\n                if (block.timestamp > COMBAT_RULE_SWITCH_TIME) {\n                    (attackerLoss, ) = _computeFight(_acquireNumSpaceships, defense, 10000, _defense(data));\n                } else {\n                    (attackerLoss, ) = _old_computeFight(_acquireNumSpaceships, defense, 10000, _defense(data));\n                }\n\n                // attacker alwasy win as defense (and stats.native) is restricted to 3500\n                // (attackerLoss: 0, defenderLoss: 0) would mean defense was zero\n                require(attackerLoss < _acquireNumSpaceships, \"FAILED_CAPTURED\");\n                currentNumSpaceships = _acquireNumSpaceships - attackerLoss;\n            } else {\n                currentNumSpaceships += _acquireNumSpaceships;\n            }\n\n            // planet.exitTime = 0; // should not be needed : // TODO actualiseExit\n            planet.numSpaceships = _setActiveNumSpaceships(true, currentNumSpaceships);\n            planet.lastUpdated = uint32(block.timestamp);\n        }\n        return currentNumSpaceships;\n    }\n\n    // solhint-disable-next-line code-complexity\n    function _handleDiscovery(uint256 location) internal {\n        Discovered memory discovered = _discovered;\n\n        int256 x = int256(int128(int256(location & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)));\n        int256 y = int256(int128(int256(location >> 128)));\n\n        bool changes = false;\n        if (x < 0) {\n            require(-x <= int256(uint256(discovered.minX)), \"NOT_REACHABLE_YET_MINX\");\n            x = -x + EXPANSION;\n            if (x > UINT32_MAX) {\n                x = UINT32_MAX;\n            }\n            if (int256(uint256(discovered.minX)) < x) {\n                discovered.minX = uint32(uint256(x));\n                changes = true;\n            }\n        } else {\n            require(x <= int256(uint256(discovered.maxX)), \"NOT_REACHABLE_YET_MAXX\");\n            x = x + EXPANSION;\n            if (x > UINT32_MAX) {\n                x = UINT32_MAX;\n            }\n            if (discovered.maxX < uint32(uint256(x))) {\n                discovered.maxX = uint32(uint256(x));\n                changes = true;\n            }\n        }\n\n        if (y < 0) {\n            require(-y <= int256(uint256(discovered.minY)), \"NOT_REACHABLE_YET_MINY\");\n            y = -y + EXPANSION;\n            if (y > UINT32_MAX) {\n                y = UINT32_MAX;\n            }\n            if (int256(uint256(discovered.minY)) < y) {\n                discovered.minY = uint32(uint256(y));\n                changes = true;\n            }\n        } else {\n            require(y <= int256(uint256(discovered.maxY)), \"NOT_REACHABLE_YET_MAXY\");\n            y = y + EXPANSION;\n            if (y > UINT32_MAX) {\n                y = UINT32_MAX;\n            }\n            if (int256(uint256(discovered.maxY)) < y) {\n                discovered.maxY = uint32(uint256(y));\n                changes = true;\n            }\n        }\n        if (changes) {\n            _discovered = discovered;\n        }\n    }\n\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // EXITS / WITHDRAWALS\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n    function _hasJustExited(uint32 exitTime) internal view returns (bool) {\n        return exitTime > 0 && block.timestamp > exitTime + _exitDuration;\n    }\n\n    function _setPlanetAfterExit(\n        uint256 location,\n        address owner,\n        Planet storage planet,\n        address newOwner,\n        uint32 spaceshipsData\n    ) internal {\n        uint256 addedStake = _setPlanetAfterExitWithoutUpdatingStake(location, owner, planet, newOwner, spaceshipsData);\n        _updateStake(owner, _stakeReadyToBeWithdrawn[owner] + addedStake);\n    }\n\n    function _updateStake(address owner, uint256 newStake) internal {\n        _stakeReadyToBeWithdrawn[owner] = newStake;\n        emit StakeToWithdraw(owner, newStake);\n    }\n\n    function _setPlanetAfterExitWithoutUpdatingStake(\n        uint256 location,\n        address owner,\n        Planet storage planet,\n        address newOwner,\n        uint32 spaceshipsData\n    ) internal returns (uint256) {\n        bytes32 data = _planetData(location);\n        uint256 stake = uint256(_stake(data)) * (DECIMALS_18);\n        emit ExitComplete(owner, location, stake);\n\n        // --------------------------------------------------------\n        // Extra Reward was added\n        // --------------------------------------------------------\n        uint256 rewardId = _rewards[location];\n        if (rewardId != 0) {\n            _rewardsToWithdraw[owner][rewardId] = true; // rewardId would contains the package. maybe this could be handled by an external contract\n            _rewards[location] = 0; // reset / if you had reward to a planet in he process of exiting, you are adding the reward to the player exiting unless _setPlanetAfterExit is called first\n            emit RewardToWithdraw(owner, location, rewardId);\n        }\n        // --------------------------------------------------------\n\n        planet.exitTime = 0;\n        planet.owner = newOwner; // This is fine as long as _actualiseExit is called on every move\n        planet.lastUpdated = uint32(block.timestamp); // This is fine as long as _actualiseExit is called on every move\n        planet.numSpaceships = spaceshipsData;\n        return stake;\n    }\n\n    /*\n    uint256 newStake = _stakeReadyToBeWithdrawn[owner] + stake * DECIMALS_18;\n    _stakeReadyToBeWithdrawn[owner] = newStake;\n    emit StakeToWithdraw(owner, newStake);\n    */\n\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // FLEET SENDING\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n    function _sendFor(\n        address owner,\n        uint256 from,\n        uint32 quantity,\n        bytes32 toHash\n    ) internal {\n        Planet memory planet = _getPlanet(from);\n\n        require(planet.exitTime == 0, \"PLANET_EXIT\");\n        require(owner == planet.owner, \"NOT_OWNER\");\n\n        bytes32 data = _planetData(from);\n        uint16 production = _production(data);\n\n        (bool active, uint32 currentNumSpaceships) = _getCurrentNumSpaceships(\n            planet.numSpaceships,\n            planet.lastUpdated,\n            production\n        );\n        require(currentNumSpaceships >= quantity, \"SPACESHIPS_NOT_ENOUGH\");\n\n        (uint32 launchTime, uint32 numSpaceships) = _computeSpaceshipBeforeSending(currentNumSpaceships, active, from, quantity);\n\n        uint256 fleetId = uint256(keccak256(abi.encodePacked(toHash, from)));\n        _fleets[fleetId] = Fleet({launchTime: launchTime, owner: owner, quantity: quantity});\n\n        emit FleetSent(owner, from, fleetId, quantity, numSpaceships);\n    }\n\n    function _computeSpaceshipBeforeSending(\n        uint32 currentNumSpaceships,\n        bool active,\n        uint256 from,\n        uint32 quantity\n    ) internal returns( uint32 launchTime, uint32 numSpaceships) {\n        Planet storage planet = _getPlanet(from);\n         // ----------------------------------------------------------------------------------------------------------------------------------------------------------\n        // record flying fleets (to prevent front-running, see resolution)\n        // ----------------------------------------------------------------------------------------------------------------------------------------------------------\n        uint256 timeSlot = block.timestamp / (FRONT_RUNNING_DELAY / 2);\n        uint64 flying = _inFlight[from][timeSlot].flying;\n        flying = flying + quantity;\n        require(flying >= quantity, \"OVERFLOW\"); // unlikely to ever happen, would need a hug amount of spaceships to be received and each in turn being sent\n        _inFlight[from][timeSlot].flying = flying;\n        // ----------------------------------------------------------------------------------------------------------------------------------------------------------\n\n        launchTime = uint32(block.timestamp); // TODO allow delay : launchTime in future\n        numSpaceships = currentNumSpaceships - quantity;\n        planet.numSpaceships = _setActiveNumSpaceships(active, numSpaceships);\n        planet.lastUpdated = launchTime;\n\n    }\n\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // FLEET RESOLUTION, ATTACK / REINFORCEMENT\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n    struct FleetResult {\n        uint32 inFlightPlanetLoss;\n        uint32 attackerLoss;\n        uint32 defenderLoss;\n        bool won;\n        uint32 numSpaceships;\n    }\n\n    function _resolveFleet(uint256 fleetId, FleetResolution memory resolution) internal {\n        Fleet memory fleet = _fleets[fleetId];\n        (uint32 quantity, uint32 inFlightFleetLoss) = _checkFleetAndComputeQuantityLeft(\n            fleet,\n            fleetId,\n            resolution\n        );\n        Planet memory toPlanet = _getPlanet(resolution.to);\n        emit_fleet_arrived(\n            fleet.owner,\n            fleetId,\n            _hasJustExited(toPlanet.exitTime) ? address(0) : toPlanet.owner,\n            resolution.to,\n            resolution.gift,\n            _performResolution(fleet, resolution.from, toPlanet, resolution.to, resolution.gift, quantity),\n            inFlightFleetLoss\n        );\n        _fleets[fleetId].quantity = 0; // TODO reset all to get gas refund? // TODO ensure frontend can still easily check fleet status\n    }\n\n    function _performResolution(\n        Fleet memory fleet,\n        uint256 from,\n        Planet memory toPlanet,\n        uint256 to,\n        bool gift,\n        uint32 quantity\n    ) internal returns (FleetResult memory result) {\n        if (gift && toPlanet.owner != address(0)) { // TODO || toPlanet.owner == fleet.owner ? // toPlanet.owner != address(0) => not able to send gift to unhabited planet\n            return _performReinforcement(fleet.owner, toPlanet, to, quantity);\n        } else {\n            return _performAttack(fleet.owner, fleet.launchTime, from, toPlanet, to, quantity);\n        }\n    }\n\n    function _checkFleetAndComputeQuantityLeft(\n        Fleet memory fleet,\n        uint256 fleetId,\n        FleetResolution memory resolution\n    ) internal returns (uint32 quantity, uint32 inFlightFleetLoss) {\n        require(\n            uint256(keccak256(abi.encodePacked(keccak256(abi.encodePacked(resolution.secret, resolution.to, resolution.gift)), resolution.from))) == fleetId,\n            \"INVALID_FLEET_DATA_OR_SECRET'\"\n        );\n\n        quantity = fleet.quantity;\n        require(quantity > 0, \"FLEET_DO_NOT_EXIST\");\n\n        // ----------------------------------------------------------------------------------------------------------------------------------------------------------\n        // check if fleet was attacked while departing (used to prevent front-running, see fleet sending)\n        // ----------------------------------------------------------------------------------------------------------------------------------------------------------\n        quantity = _fleet_flying_at_origin(quantity, resolution.from, fleet.launchTime);\n        inFlightFleetLoss = fleet.quantity - quantity;\n        // ----------------------------------------------------------------------------------------------------------------------------------------------------------\n\n        _checkDistance(resolution.distance, resolution.from, resolution.to);\n        _checkTime(resolution.distance, resolution.from, fleet.launchTime);\n    }\n\n    function emit_fleet_arrived(\n        address fleetOwner,\n        uint256 fleetID,\n        address toOwner,\n        uint256 to,\n        bool gift,\n        FleetResult memory result,\n        uint32 inFlightFleetLoss\n    ) internal {\n        emit FleetArrived(\n            fleetID,\n            fleetOwner,\n            toOwner,\n            to,\n            gift,\n            result.attackerLoss,\n            result.defenderLoss,\n            inFlightFleetLoss,\n            result.inFlightPlanetLoss,\n            result.won,\n            result.numSpaceships\n        );\n    }\n\n    function _fleet_flying_at_origin(\n        uint32 quantity,\n        uint256 from,\n        uint32 launchTime\n    ) internal returns (uint32) {\n        uint256 timeSlot = launchTime / (FRONT_RUNNING_DELAY / 2);\n        uint64 destroyed = _inFlight[from][timeSlot].destroyed;\n        if (destroyed < quantity) {\n            quantity -= uint32(destroyed);\n            _inFlight[from][timeSlot].destroyed = 0;\n        } else {\n            quantity = 0;\n            _inFlight[from][timeSlot].destroyed = destroyed - quantity;\n        }\n        return quantity;\n    }\n\n    function _performAttack(\n        address attacker,\n        uint32 launchTime,\n        uint256 from,\n        Planet memory toPlanet,\n        uint256 to,\n        uint32 numAttack\n    ) internal returns (FleetResult memory result) {\n        if (toPlanet.lastUpdated == 0) {\n            // Planet was never touched (previous attack could have failed to succeed attack on natives)\n            bytes32 toPlanetData = _planetData(to);\n            return _nativeAttack(attacker, launchTime, from, to, toPlanetData, numAttack);\n        } else if (_hasJustExited(toPlanet.exitTime)) {\n            return _fleetAfterExit(to, toPlanet.owner, _planets[to], attacker, numAttack);\n        } else {\n            bytes32 toPlanetData = _planetData(to);\n            uint16 attack = _attack(_planetData(from));\n            uint16 defense = _defense(toPlanetData);\n            uint16 production = _production(toPlanetData);\n            return _actualAttack(attacker, launchTime, attack, defense, toPlanet, to, production, numAttack);\n        }\n    }\n\n    function _fleetAfterExit(\n        uint256 to,\n        address owner,\n        Planet storage planet,\n        address newOwner,\n        uint32 numSpaceshipsArrived\n    ) internal returns (FleetResult memory result) {\n        _setPlanetAfterExit(to, owner, planet, numSpaceshipsArrived > 0 ? newOwner : address(0), numSpaceshipsArrived);\n        result.numSpaceships = numSpaceshipsArrived;\n        result.won = numSpaceshipsArrived > 0; // TODO does it make sense if reinforcement ?\n    }\n\n    function _nativeAttack(\n        address attacker,\n        uint32 launchTime,\n        uint256 from,\n        uint256 to,\n        bytes32 toData,\n        uint32 numAttack\n    ) internal returns (FleetResult memory result) {\n        uint16 attack = _attack(_planetData(from));\n        uint16 defense = _defense(toData);\n        uint16 natives = _natives(toData);\n        uint32 attackerLoss;\n        uint32 defenderLoss;\n        if (launchTime > COMBAT_RULE_SWITCH_TIME) {\n            (attackerLoss, defenderLoss) = _computeFight(numAttack, natives, attack, defense);\n        } else {\n            (attackerLoss, defenderLoss) = _old_computeFight(numAttack, natives, attack, defense);\n        }\n        result.attackerLoss = attackerLoss;\n        if (defenderLoss == natives && numAttack > attackerLoss) {\n            // (attackerLoss: 0, defenderLoss: 0) means that numAttack was zero as natives cannot be zero\n            result.numSpaceships = numAttack - attackerLoss;\n            _planets[to].numSpaceships = _setActiveNumSpaceships(false, result.numSpaceships);\n            _planets[to].lastUpdated = uint32(block.timestamp);\n            _planets[to].owner = attacker;\n            result.defenderLoss = defenderLoss;\n            result.won = true;\n        }\n    }\n\n    function _actualAttack(\n        address attacker,\n        uint32 launchTime,\n        uint16 attack,\n        uint16 defense,\n        Planet memory toPlanet,\n        uint256 to,\n        uint16 production,\n        uint32 numAttack\n    ) internal returns (FleetResult memory result) {\n        PreCombatState memory state = _getPlanetPreCombatState(toPlanet, to, production);\n\n        if (state.numDefense == 0 && numAttack > 0) {\n            _planets[to].owner = attacker;\n            _planets[to].exitTime = 0;\n            _planets[to].numSpaceships = _setActiveNumSpaceships(state.active, numAttack);\n            _planets[to].lastUpdated = uint32(block.timestamp);\n            result.won = true;\n            result.numSpaceships = numAttack;\n            return result;\n        }\n\n        return _completeCombatResult(state, attacker, launchTime, to, numAttack, attack, defense);\n    }\n\n    struct PreCombatState {\n        bool active;\n        uint32 currentNumSpaceships;\n        uint32 numDefense;\n        uint64 flying1;\n        uint64 destroyed1;\n        uint64 flying2;\n        uint64 destroyed2;\n    }\n\n    function _getPlanetPreCombatState(\n        Planet memory toPlanet,\n        uint256 to,\n        uint16 production\n    ) internal view returns (PreCombatState memory state) {\n        (bool active, uint32 currentNumSpaceships) = _getCurrentNumSpaceships(\n            toPlanet.numSpaceships,\n            toPlanet.lastUpdated,\n            production\n        );\n\n        (\n            uint32 numDefense,\n            uint64 flying1,\n            uint64 destroyed1,\n            uint64 flying2,\n            uint64 destroyed2\n        ) = computeDefenseWithInFlightFleets(currentNumSpaceships, to);\n        state.active = active;\n        state.currentNumSpaceships = currentNumSpaceships;\n        state.numDefense = numDefense;\n        state.flying1 = flying1;\n        state.destroyed1 = destroyed1;\n        state.flying2 = flying2;\n        state.destroyed2 = destroyed2;\n    }\n\n    function computeDefenseWithInFlightFleets(uint32 numSpaceships, uint256 to)\n        internal\n        view\n        returns (\n            uint32 numDefense,\n            uint64 flying1,\n            uint64 destroyed1,\n            uint64 flying2,\n            uint64 destroyed2\n        )\n    {\n        numDefense = numSpaceships;\n        // ----------------------------------------------------------------------------------------------------------------------------------------------------------\n        // consider fleets that just departed from the planet (used to prevent front-running, see fleet sending)\n        // ----------------------------------------------------------------------------------------------------------------------------------------------------------\n        uint256 timeSlot = block.timestamp / (FRONT_RUNNING_DELAY / 2);\n        flying1 = _inFlight[to][timeSlot - 1].flying;\n        destroyed1 = _inFlight[to][timeSlot - 1].flying;\n        flying2 = _inFlight[to][timeSlot].flying;\n        destroyed2 = _inFlight[to][timeSlot].destroyed;\n        numDefense = uint32(Math.min(flying1 + flying2 + numDefense, 2**32 - 1));\n        // ----------------------------------------------------------------------------------------------------------------------------------------------------------\n    }\n\n    function _completeCombatResult(\n        PreCombatState memory state,\n        address attacker,\n        uint32 launchTime,\n        uint256 to,\n        uint32 numAttack,\n        uint16 attack,\n        uint16 defense\n    ) internal returns (FleetResult memory result) {\n        uint32 attackerLoss;\n        uint32 defenderLoss;\n        if (launchTime > COMBAT_RULE_SWITCH_TIME) {\n            (attackerLoss, defenderLoss) = _computeFight(numAttack, state.numDefense, attack, defense);\n        } else {\n            (attackerLoss, defenderLoss) = _old_computeFight(numAttack, state.numDefense, attack, defense);\n        }\n        result.attackerLoss = attackerLoss;\n        result.defenderLoss = defenderLoss;\n\n        // ----------------------------------------------------------------------------------------------------------------------------------------------------------\n        // consider fleets that just departed from the planet (used to prevent front-running, see fleet sending)\n        // ----------------------------------------------------------------------------------------------------------------------------------------------------------\n        if (result.defenderLoss > state.currentNumSpaceships) {\n            result.inFlightPlanetLoss = defenderLoss - state.currentNumSpaceships;\n            result.defenderLoss = state.currentNumSpaceships;\n            if (state.flying1 >= result.inFlightPlanetLoss) {\n                state.flying1 -= result.inFlightPlanetLoss;\n                state.destroyed1 += result.inFlightPlanetLoss;\n            } else {\n                state.destroyed1 += state.flying1;\n                uint64 extra = (result.inFlightPlanetLoss - state.flying1);\n                if (state.flying2 >= extra) {\n                    state.flying2 -= extra;\n                    state.destroyed2 += extra;\n                } else {\n                    state.destroyed2 += state.flying2;\n                    state.flying2 = 0; // should never reach minus but let simply set it to zero\n                }\n                state.flying1 = 0;\n            }\n            _inFlight[to][block.timestamp / (FRONT_RUNNING_DELAY / 2) - 1].flying = state.flying1;\n            _inFlight[to][block.timestamp / (FRONT_RUNNING_DELAY / 2) - 1].destroyed = state.destroyed1;\n            _inFlight[to][block.timestamp / (FRONT_RUNNING_DELAY / 2)].flying = state.flying2;\n            _inFlight[to][block.timestamp / (FRONT_RUNNING_DELAY / 2)].destroyed = state.destroyed2;\n        }\n        // ----------------------------------------------------------------------------------------------------------------------------------------------------------\n        // (attackerLoss: 0, defenderLoss: 0) could either mean attack was zero or defense was zero :\n        if (numAttack > 0 && result.defenderLoss == state.currentNumSpaceships) {\n            result.numSpaceships = numAttack - attackerLoss;\n            result.won = true;\n            _planets[to].owner = attacker;\n            _planets[to].exitTime = 0;\n            _planets[to].numSpaceships = _setActiveNumSpaceships(state.active, result.numSpaceships);\n            _planets[to].lastUpdated = uint32(block.timestamp);\n        } else if (result.attackerLoss == numAttack) {\n            // always true as if attack won it will be going in the \"if\" above\n            result.numSpaceships = state.currentNumSpaceships - defenderLoss;\n            _planets[to].numSpaceships = _setActiveNumSpaceships(state.active, result.numSpaceships);\n            _planets[to].lastUpdated = uint32(block.timestamp);\n        } else {\n            assert(false); // should not happen\n        }\n    }\n\n    function _performReinforcement(\n        address sender,\n        Planet memory toPlanet,\n        uint256 to,\n        uint32 quantity\n    ) internal returns (FleetResult memory result) {\n        if (_hasJustExited(toPlanet.exitTime)) {\n            address newOwner = toPlanet.owner;\n            if (newOwner == address(0)) {\n                newOwner = sender;\n            }\n            return _fleetAfterExit(to, toPlanet.owner, _planets[to], quantity > 0 ? newOwner : address(0), quantity);\n        } else {\n            bytes32 toPlanetData = _planetData(to);\n            uint16 production = _production(toPlanetData);\n            (bool active, uint32 currentNumSpaceships) = _getCurrentNumSpaceships(\n                toPlanet.numSpaceships,\n                toPlanet.lastUpdated,\n                production\n            );\n            uint256 newNumSpaceships = currentNumSpaceships + quantity;\n            if (newNumSpaceships >= ACTIVE_MASK) {\n                newNumSpaceships = ACTIVE_MASK - 1;\n            }\n            _planets[to].lastUpdated = uint32(block.timestamp);\n            _planets[to].numSpaceships = _setActiveNumSpaceships(active, uint32(newNumSpaceships));\n            result.numSpaceships = uint32(newNumSpaceships);\n        }\n    }\n\n    function _computeFight(\n        uint256 numAttack,\n        uint256 numDefense,\n        uint256 attack,\n        uint256 defense\n    ) internal pure returns (uint32 attackerLoss, uint32 defenderLoss) {\n        if (numAttack == 0 || numDefense == 0) {\n            return (0, 0); // this edge case need to be considered, as the result of this function cannot tell from it whos is winning here\n        }\n        uint256 attackDamage = (numAttack * attack) / defense;\n\n        if (numDefense > attackDamage) {\n            // attack fails\n            attackerLoss = uint32(numAttack); // all attack destroyed\n            defenderLoss = uint32(attackDamage); // 1 spaceship will be left at least as attackDamage < numDefense\n        } else {\n            // attack succeed\n            uint256 defenseDamage = uint32((numDefense * defense) / attack);\n            if (defenseDamage >= numAttack) {\n                defenseDamage = numAttack - 1; // ensure 1 spaceship left\n            }\n\n            attackerLoss = uint32(defenseDamage);\n            defenderLoss = uint32(numDefense); // all defense destroyed\n        }\n    }\n\n    function _old_computeFight(\n        uint256 numAttack,\n        uint256 numDefense,\n        uint256 attack,\n        uint256 defense\n    ) internal pure returns (uint32 attackerLoss, uint32 defenderLoss) {\n        if (numAttack == 0 || numDefense == 0) {\n            return (0, 0);\n        }\n        uint256 attackPower = (numAttack * attack);\n        uint256 defensePower = (numDefense * defense);\n\n        uint256 numAttackRound = (numDefense * 100000000) / attackPower;\n        if (numAttackRound * attackPower < (numDefense * 100000000)) {\n            numAttackRound++;\n        }\n        uint256 numDefenseRound = (numAttack * 100000000) / defensePower;\n        if (numDefenseRound * defensePower < (numAttack * 100000000)) {\n            numDefenseRound++;\n        }\n\n        uint256 numRound = Math.min(numAttackRound, numDefenseRound);\n        attackerLoss = uint32(Math.min((numRound * defensePower) / 100000000, numAttack));\n        defenderLoss = uint32(Math.min((numRound * attackPower) / 100000000, numDefense));\n    }\n\n    function _checkDistance(\n        uint256 distance,\n        uint256 from,\n        uint256 to\n    ) internal view {\n        (int8 fromSubX, int8 fromSubY) = _subLocation(_planetData(from));\n        (int8 toSubX, int8 toSubY) = _subLocation(_planetData(to));\n        // check input instead of compute sqrt\n\n        uint256 distanceSquared = uint256(int256( // check input instead of compute sqrt\n            ((int128(int256(to & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) * 4 + toSubX) -\n                (int128(int256(from & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) * 4 + fromSubX)) **\n                2 +\n                ((int128(int256(to >> 128)) * 4 + toSubY) - (int128(int256(from >> 128)) * 4 + fromSubY))**2\n        ));\n        require(distance**2 <= distanceSquared && distanceSquared < (distance + 1)**2, \"wrong distance\");\n    }\n\n    function _checkTime(\n        uint256 distance,\n        uint256 from,\n        uint32 launchTime\n    ) internal view {\n        uint256 reachTime = launchTime + (distance * (_timePerDistance * 10000)) / _speed(_planetData(from));\n        require(block.timestamp >= reachTime, \"too early\");\n        require(block.timestamp < reachTime + _resolveWindow, \"too late, your spaceships are lost in space\");\n    }\n\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // PLANET STATS\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n    function _planetData(uint256 location) internal view returns (bytes32) {\n        return keccak256(abi.encodePacked(_genesis, location));\n    }\n\n    function _subLocation(bytes32 data) internal pure returns (int8 subX, int8 subY) {\n        subX = 1 - int8(data.value8Mod(0, 3));\n        subY = 1 - int8(data.value8Mod(2, 3));\n    }\n\n    // 4,5,5,10,10,15,15, 20, 20, 30,30,40,40,80,80,100\n    bytes32 constant stakeRange = 0x000400050005000A000A000F000F00140014001E001E00280028005000500064;\n\n    function _stake(bytes32 data) internal pure returns (uint16) {\n        // return data.normal16(4, 0x000400050005000A000A000F000F00140014001E001E00280028005000500064);\n        uint8 productionIndex = data.normal8(12); // production affect the stake value\n        uint16 offset = data.normal16(4, 0x0000000100010002000200030003000400040005000500060006000700070008);\n        uint16 stakeIndex = productionIndex + offset;\n        if (stakeIndex < 4) {\n            stakeIndex = 0;\n        } else if (stakeIndex > 19) {\n            stakeIndex = 15;\n        } else {\n            stakeIndex -= 4;\n        }\n        return uint16(uint8(stakeRange[stakeIndex * 2 + 1])); // skip stakeIndex * 2 + 0 as it is always zero in stakeRange\n    }\n\n    function _production(bytes32 data) internal pure returns (uint16) {\n        // TODO TRY : 1800,2100,2400,2700,3000,3300,3600, 3600, 3600, 3600,4000,4400,4800,5400,6200,7200 ?\n\n        // 1800,2100,2400,2700,3000,3300,3600, 3600, 3600, 3600,4200,5400,6600,7800,9000,12000\n        // 0x0708083409600a8c0bb80ce40e100e100e100e101068151819c81e7823282ee0\n        return data.normal16(12, 0x0708083409600a8c0bb80ce40e100e100e100e101068151819c81e7823282ee0); // per hour\n    }\n\n    function _attack(bytes32 data) internal pure returns (uint16) {\n        return 4000 + data.normal8(20) * 400; // 4,000 - 7,000 - 10,000\n    }\n\n    function _defense(bytes32 data) internal pure returns (uint16) {\n        return 4000 + data.normal8(28) * 400; // 4,000 - 7,000 - 10,000\n    }\n\n    function _speed(bytes32 data) internal pure returns (uint16) {\n        return 5005 + data.normal8(36) * 333; // 5,005 - 7,502.5 - 10,000\n    }\n\n    function _natives(bytes32 data) internal pure returns (uint16) {\n        return 15000 + data.normal8(44) * 3000; // 15,000 - 37,500 - 60,000\n    }\n\n    function _exists(bytes32 data) internal pure returns (bool) {\n        return data.value8Mod(52, 16) == 1; // 16 => 36 so : 1 planet per 6 (=24 min unit) square\n        // also:\n        // 20000 average starting numSpaceships (or max?)\n        // speed of min unit = 30 min ( 1 hour per square)\n        // production : 20000 per 6 hours\n        // exit : 3 days ? => 72 distance\n    }\n\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // GETTERS\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n    function _getPlanet(uint256 location) internal view returns (Planet storage) {\n        return _planets[location];\n    }\n\n    function _getPlanetStats(uint256 location) internal view returns (PlanetStats memory) {\n        bytes32 data = _planetData(location);\n        require(_exists(data), \"no planet in this location\");\n\n        (int8 subX, int8 subY) = _subLocation(data);\n        return\n            PlanetStats({\n                subX: subX,\n                subY: subY,\n                stake: _stake(data),\n                production: _production(data),\n                attack: _attack(data),\n                defense: _defense(data),\n                speed: _speed(data),\n                natives: _natives(data)\n            });\n    }\n\n    function _getCurrentNumSpaceships(\n        uint32 numSpaceshipsData,\n        uint256 lastUpdated,\n        uint16 production\n    ) internal view returns (bool active, uint32 currentNumSpaceships) {\n        (active, currentNumSpaceships) = _activeNumSpaceships(numSpaceshipsData);\n        if (active) {\n            uint256 timePassed = block.timestamp - lastUpdated;\n            uint256 newSpaceships = uint256(currentNumSpaceships) +\n                (timePassed * uint256(production) * _productionSpeedUp) /\n                1 hours;\n            if (newSpaceships >= ACTIVE_MASK) {\n                newSpaceships = ACTIVE_MASK - 1;\n            }\n            currentNumSpaceships = uint32(newSpaceships);\n        }\n    }\n\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n    // UTILS\n    // --------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n    function _activeNumSpaceships(uint32 numSpaceshipsData) internal pure returns (bool active, uint32 numSpaceships) {\n        active = (numSpaceshipsData & ACTIVE_MASK) == ACTIVE_MASK;\n        numSpaceships = numSpaceshipsData % (ACTIVE_MASK);\n    }\n\n    function _setActiveNumSpaceships(bool active, uint32 numSpaceships) internal pure returns (uint32) {\n        return uint32((active ? ACTIVE_MASK : 0) + numSpaceships);\n    }\n\n    function _msgSender() internal view returns (address) {\n        return msg.sender; // TODO metatx\n    }\n}\n"
    },
    "src/Libraries/Random.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\n\npragma solidity 0.8.9;\n\nimport \"./Math.sol\";\n\nlibrary Random {\n    using Math for uint256;\n\n    function r_u8(\n        bytes32 seed,\n        uint256 r,\n        uint8 i,\n        uint256 mod\n    ) internal pure returns (uint8) {\n        return uint8(uint256(keccak256(abi.encodePacked(r, seed, i))) % mod);\n    }\n\n    function r_u256(\n        bytes32 seed,\n        uint256 r,\n        uint8 i,\n        uint256 mod\n    ) internal pure returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(r, seed, i))) % mod;\n    }\n\n    function r_u256_minMax(\n        bytes32 seed,\n        uint256 r,\n        uint8 i,\n        uint256 min,\n        uint256 max\n    ) internal pure returns (uint256) {\n        uint256 range = max.sub(min, \"MAX_LT_MIN\");\n        return min.add(r_u256(seed, r, i, range), \"MAX_OVERFLOW\");\n    }\n\n    // 1+1+2+3+4+6+7+8+8+7+6+4+3+2+1+1 // aproximation of normal distribution with mean=7.5 and standard deviation=3 for 16 values\n    bytes32 constant n_m7_5_sd3 = 0x01223334444555555666666677777777888888889999999AAAAAABBBBCCCDDEF;\n\n    function r_normal(\n        bytes32 seed,\n        uint256 r,\n        uint8 i\n    ) internal pure returns (uint8) {\n        uint8 index = r_u8(seed, r, i, 64);\n        uint8 first = index / 2;\n        uint8 second = index % 2;\n        uint8 slot = uint8(n_m7_5_sd3[first]);\n        uint8 value;\n        if (second == 0) {\n            value = slot >> 4;\n        } else {\n            value = slot % 16;\n        }\n        return value;\n    }\n\n    function r_normalFrom(\n        bytes32 seed,\n        uint256 r,\n        uint8 i,\n        bytes32 selection\n    ) internal pure returns (uint16) {\n        uint8 index = r_normal(seed, r, i);\n        return uint16(uint8(selection[index * 2])) * 2**8 + uint16(uint8(selection[index * 2 + 1]));\n    }\n}\n"
    },
    "src/Test/Conversion.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\npragma solidity 0.8.9;\n\nimport \"hardhat/console.sol\";\n\ncontract TestConversion {\n\n\n    function _convertLoc2XY(uint256 location)\n        internal\n        pure\n        returns (int128 x, int128 y)\n    {\n        x = int128(int256(location & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF));\n        y = int128(int256(location >> 128));\n    }\n\n    function _convertXY2Loc(int128 x, int128 y)\n        internal\n        pure\n        returns (uint256 location)\n    {\n        // unchecked {location = uint256(int256(x)) + uint256(int256(y) << 128);}\n        unchecked {location = uint256(uint128(x)) + (uint256(uint128(y)) << 128);}\n    }\n\n    function _convertLocationToLocation(uint256 location)\n        internal\n        pure\n        returns (\n            uint256 newLocation\n        )\n    {\n        (int128 ix, int128 iy) = _convertLoc2XY(location);\n        return _convertXY2Loc(ix, iy);\n    }\n\n    function testConversion(uint256 location) external view {\n        console.logUint(location);\n        (int128 x, int128 y) = _convertLoc2XY(location);\n\n        console.logInt(x);\n        console.logInt(y);\n\n        int256 x256 = int256(location & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n        int256 y256 = int256(location >> 128);\n        // console.log(\"x256 %i y256 %i\", x256, y256);\n        console.logInt(x256);\n        console.logInt(y256);\n\n        uint256 newLocation = _convertXY2Loc(x, y);\n        console.logUint(newLocation);\n        console.logBytes32(bytes32(newLocation));\n\n        if (location != newLocation) {\n            console.log(\"error\");\n        }\n    }\n\n\n}\n"
    },
    "src/agent/PaymentGateway.sol": {
      "content": "// SPDX-License-Identifier: AGPL-1.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract PaymentGateway {\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event Payment(address indexed payer, uint256 amount, bool refund);\n\n    address public owner;\n\n    constructor(address firstOwner) {\n        owner = firstOwner;\n        emit OwnershipTransferred(address(0), firstOwner);\n    }\n\n    receive() external payable {\n        emit Payment(msg.sender, msg.value, false);\n    }\n\n    // sendETHandRegisterDelegate(address delegate) external payable {\n    //     emit Payment(msg.sender, delegate, msg.value, false);\n    // }\n\n    function transferOwnership(address newOwner) external {\n        require(msg.sender == owner, \"NOT_ALLOWED\");\n        owner = newOwner;\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n\n    function withdrawForRefund(address payable to, uint256 amount) external {\n        require(msg.sender == owner, \"NOT_ALLOWED\");\n        to.transfer(amount);\n        emit Payment(to, amount, true);\n    }\n\n    function withdraw(address payable to, uint256 amount) external {\n        require(msg.sender == owner, \"NOT_ALLOWED\");\n        to.transfer(amount);\n    }\n\n    function withdrawAllETH(address payable to) external {\n        require(msg.sender == owner, \"NOT_ALLOWED\");\n        to.transfer(address(this).balance);\n    }\n\n    function withdrawTokens(IERC20[] calldata tokens, address to) external {\n        require(msg.sender == owner, \"NOT_ALLOWED\");\n        for (uint256 i = 0; i < tokens.length; i++) {\n            uint256 balance = tokens[i].balanceOf(address(this));\n            tokens[i].transfer(to, balance);\n        }\n    }\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}